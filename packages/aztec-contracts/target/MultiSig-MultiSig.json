{
  "file_map": {
    "102": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "103": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "106": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "109": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "111": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "112": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "114": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "115": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "116": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "117": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "135": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "147": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "150": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "154": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "155": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "156": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "157": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "158": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "159": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "164": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "165": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "167": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "169": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "172": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "174": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "188": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "208": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "211": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "212": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "214": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "215": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "218": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "229": {
      "path": "/Users/yashgoyal/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "251": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "292": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "317": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "330": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "331": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "332": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "333": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "340": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "345": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "361": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "363": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "364": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "382": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "386": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "421": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/Users/yashgoyal/development/grants/aztec/chameleon-money/packages/aztec-contracts/src/main.nr",
      "source": "// Private Multi-Signature Wallet Contract\n//\n// Features:\n// 1. Initialize with list of signers and threshold\n// 2. Add new signers (requires threshold approval)\n// 3. Remove existing signers (requires threshold approval)\n// 4. Change signature threshold (requires threshold approval)\n// 5. Execute arbitrary transactions (requires threshold approval)\n//\n// Privacy Features:\n// - Signatures are private - only the fact that threshold was met is public\n// - Uses nullifiers to prevent double-signing without revealing signer identity\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract MultiSig {\n    use dep::aztec::{\n        keys::getters::get_public_keys,\n        macros::{functions::{external, initializer, internal}, storage::storage},\n        state_vars::{Map, PublicMutable},\n    };\n\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress},\n        hash::poseidon2_hash,\n        traits::{Hash, ToField},\n    };\n\n    use dep::wormhole::Wormhole;\n\n    // Operation types\n    global OPERATION_ADD_SIGNER: u8 = 1;\n    global OPERATION_REMOVE_SIGNER: u8 = 2;\n    global OPERATION_CHANGE_THRESHOLD: u8 = 3;\n    global OPERATION_EXECUTE_TRANSACTION: u8 = 4;\n\n    // Proposal expiration time (in blocks)\n    global PROPOSAL_EXPIRY: u32 = 1000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Mapping of address -> whether they are a signer\n        signers: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n\n        // Current threshold required for operations\n        threshold: PublicMutable<u8, Context>,\n\n        // Current number of signers\n        signer_count: PublicMutable<u8, Context>,\n\n        // Wormhole contract address\n        wormhole_address: PublicMutable<AztecAddress, Context>,\n\n        // Proposal fields (simplified storage)\n        proposal_operation_type: Map<Field, PublicMutable<u8, Context>, Context>,\n        proposal_proposer: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        proposal_target: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        proposal_new_threshold: Map<Field, PublicMutable<u8, Context>, Context>,\n        proposal_transaction_token: Map<Field, PublicMutable<EthAddress, Context>, Context>,\n        proposal_transaction_receipient: Map<Field, PublicMutable<EthAddress, Context>, Context>,\n        proposal_transaction_amount: Map<Field, PublicMutable<Field, Context>, Context>,\n        proposal_signature_count: Map<Field, PublicMutable<u8, Context>, Context>,\n        proposal_executed: Map<Field, PublicMutable<bool, Context>, Context>,\n        proposal_created_at: Map<Field, PublicMutable<u32, Context>, Context>,\n\n        // Next available proposal ID\n        next_proposal_id: PublicMutable<Field, Context>,\n    }\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        initial_signers: [AztecAddress; 20],\n        initial_signer_count: u8,\n        initial_threshold: u8,\n        wormhole_address: AztecAddress,\n    ) {\n        // Validate input parameters\n        assert(initial_signer_count > 0, \"Must have at least one signer\");\n        assert(initial_signer_count <= 20, \"Too many signers\");\n        assert(initial_threshold > 0, \"Threshold must be positive\");\n        assert(initial_threshold <= initial_signer_count, \"Threshold cannot exceed signer count\");\n\n        // Initialize threshold and signer count\n        storage.threshold.write(initial_threshold);\n        storage.signer_count.write(initial_signer_count);\n        storage.next_proposal_id.write(1);\n        storage.wormhole_address.write(wormhole_address);\n\n        // Add all initial signers\n        for i in 0..20 {\n            if (i as u8) < initial_signer_count {\n                let signer_address = initial_signers[i];\n                assert(!signer_address.eq(AztecAddress::zero()), \"Invalid signer address\");\n                storage.signers.at(signer_address).write(true);\n            }\n        }\n    }\n\n    // Propose adding a new signer\n    #[external(\"public\")]\n    fn propose_add_signer(new_signer: AztecAddress) -> Field {\n        let proposer = context.msg_sender().unwrap();\n\n        // Validate proposer is a signer\n        assert(storage.signers.at(proposer).read(), \"Only signers can propose\");\n\n        // Validate new signer\n        assert(!new_signer.eq(AztecAddress::zero()), \"Invalid signer address\");\n        assert(!storage.signers.at(new_signer).read(), \"Address is already a signer\");\n        assert(storage.signer_count.read() < 20, \"Maximum signers reached\");\n\n        // Create proposal\n        let proposal_id = storage.next_proposal_id.read();\n\n        storage.proposal_operation_type.at(proposal_id).write(OPERATION_ADD_SIGNER);\n        storage.proposal_proposer.at(proposal_id).write(proposer);\n        storage.proposal_target.at(proposal_id).write(new_signer);\n        storage.proposal_new_threshold.at(proposal_id).write(0); // not used\n        storage.proposal_transaction_token.at(proposal_id).write(EthAddress::zero()); // not used\n        storage.proposal_transaction_receipient.at(proposal_id).write(EthAddress::zero()); // not used\n        storage.proposal_transaction_amount.at(proposal_id).write(0); // not used\n        storage.proposal_signature_count.at(proposal_id).write(0); // no automatic signature\n        storage.proposal_executed.at(proposal_id).write(false);\n        storage.proposal_created_at.at(proposal_id).write(context.block_number());\n\n        storage.next_proposal_id.write(proposal_id + 1);\n\n        proposal_id\n    }\n\n    // Propose removing an existing signer\n    #[external(\"public\")]\n    fn propose_remove_signer(signer_to_remove: AztecAddress) -> Field {\n        let proposer = context.msg_sender().unwrap();\n\n        // Validate proposer is a signer\n        assert(storage.signers.at(proposer).read(), \"Only signers can propose\");\n\n        // Validate signer to remove\n        assert(storage.signers.at(signer_to_remove).read(), \"Address is not a signer\");\n\n        // Ensure we don't go below threshold\n        let current_count = storage.signer_count.read();\n        let current_threshold = storage.threshold.read();\n        assert(current_count > 1, \"Cannot remove last signer\");\n        assert((current_count - 1) >= current_threshold, \"Removing signer would break threshold\");\n\n        // Create proposal\n        let proposal_id = storage.next_proposal_id.read();\n\n        storage.proposal_operation_type.at(proposal_id).write(OPERATION_REMOVE_SIGNER);\n        storage.proposal_proposer.at(proposal_id).write(proposer);\n        storage.proposal_target.at(proposal_id).write(signer_to_remove);\n        storage.proposal_new_threshold.at(proposal_id).write(0); // not used\n        storage.proposal_transaction_token.at(proposal_id).write(EthAddress::zero()); // not used\n        storage.proposal_transaction_receipient.at(proposal_id).write(EthAddress::zero()); // not used\n        storage.proposal_transaction_amount.at(proposal_id).write(0); // not used\n        storage.proposal_signature_count.at(proposal_id).write(0); // no automatic signature\n        storage.proposal_executed.at(proposal_id).write(false);\n        storage.proposal_created_at.at(proposal_id).write(context.block_number());\n\n        storage.next_proposal_id.write(proposal_id + 1);\n\n        proposal_id\n    }\n\n    // Propose changing the signature threshold\n    #[external(\"public\")]\n    fn propose_change_threshold(new_threshold: u8) -> Field {\n        let proposer = context.msg_sender().unwrap();\n\n        // Validate proposer is a signer\n        assert(storage.signers.at(proposer).read(), \"Only signers can propose\");\n\n        // Validate new threshold\n        assert(new_threshold > 0, \"Threshold must be positive\");\n        let current_signer_count = storage.signer_count.read();\n        assert(new_threshold <= current_signer_count, \"Threshold cannot exceed signer count\");\n        assert(new_threshold != storage.threshold.read(), \"Threshold is already set to this value\");\n\n        // Create proposal\n        let proposal_id = storage.next_proposal_id.read();\n\n        storage.proposal_operation_type.at(proposal_id).write(OPERATION_CHANGE_THRESHOLD);\n        storage.proposal_proposer.at(proposal_id).write(proposer);\n        storage.proposal_target.at(proposal_id).write(AztecAddress::zero()); // not used\n        storage.proposal_new_threshold.at(proposal_id).write(new_threshold);\n        storage.proposal_transaction_token.at(proposal_id).write(EthAddress::zero()); // not used\n        storage.proposal_transaction_receipient.at(proposal_id).write(EthAddress::zero()); // not used\n        storage.proposal_transaction_amount.at(proposal_id).write(0); // not used\n        storage.proposal_signature_count.at(proposal_id).write(0); // no automatic signature\n        storage.proposal_executed.at(proposal_id).write(false);\n        storage.proposal_created_at.at(proposal_id).write(context.block_number());\n\n        storage.next_proposal_id.write(proposal_id + 1);\n\n        proposal_id\n    }\n\n    // Propose executing a transaction\n    #[external(\"public\")]\n    fn propose_execute_transaction(\n        token: EthAddress, \n        recipient: EthAddress, \n        amount: Field\n    ) -> Field {\n        let proposer = context.msg_sender().unwrap();\n\n        // Validate proposer is a signer\n        assert(storage.signers.at(proposer).read(), \"Only signers can propose\");\n\n        // Create proposal\n        let proposal_id = storage.next_proposal_id.read();\n\n        storage.proposal_operation_type.at(proposal_id).write(OPERATION_EXECUTE_TRANSACTION);\n        storage.proposal_proposer.at(proposal_id).write(proposer);\n        storage.proposal_target.at(proposal_id).write(AztecAddress::zero());\n        storage.proposal_new_threshold.at(proposal_id).write(0); // not used\n        storage.proposal_transaction_token.at(proposal_id).write(token);\n        storage.proposal_transaction_receipient.at(proposal_id).write(recipient);\n        storage.proposal_transaction_amount.at(proposal_id).write(amount);\n        storage.proposal_signature_count.at(proposal_id).write(0); // no automatic signature\n        storage.proposal_executed.at(proposal_id).write(false);\n        storage.proposal_created_at.at(proposal_id).write(context.block_number());\n\n        storage.next_proposal_id.write(proposal_id + 1);\n\n        proposal_id\n    }\n\n    // Sign a proposal privately\n    #[external(\"private\")]\n    fn sign_proposal(proposal_id: Field) {\n        let signer = context.msg_sender().unwrap();\n\n        MultiSig::at(context.this_address())._assert_is_signer(signer).enqueue(&mut context);\n\n        let msg_sender_nullifier_public_key_message_hash = get_public_keys(signer).npk_m.hash();\n\n        let secret = context.request_nsk_app(msg_sender_nullifier_public_key_message_hash);\n\n        // Generate deterministic nullifier to prevent double-signing\n        // Using proposal_id and signer ensures uniqueness per signer per proposal\n        let nullifier = poseidon2_hash([proposal_id, signer.to_field(), secret]);\n\n        // Push nullifier to prevent double-signing - Aztec protocol handles the rest\n        context.push_nullifier(nullifier);\n\n        // Enqueue public function to update signature count\n        MultiSig::at(context.this_address()).increment_signature_count(proposal_id).enqueue(\n            &mut context,\n        );\n    }\n\n    // Internal public function to increment signature count\n    #[external(\"public\")]\n    #[internal]\n    fn increment_signature_count(proposal_id: Field) {\n        // Validate proposal exists and is still active\n        let operation_type = storage.proposal_operation_type.at(proposal_id).read();\n        assert(operation_type != 0, \"Proposal does not exist\");\n        assert(!storage.proposal_executed.at(proposal_id).read(), \"Proposal already executed\");\n\n        // Check proposal hasn't expired\n        let created_at = storage.proposal_created_at.at(proposal_id).read();\n        assert(context.block_number() <= (created_at + PROPOSAL_EXPIRY), \"Proposal has expired\");\n\n        // Increment signature count (nullifier uniqueness is enforced by Aztec protocol)\n        let current_count = storage.proposal_signature_count.at(proposal_id).read();\n        storage.proposal_signature_count.at(proposal_id).write(current_count + 1);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn _assert_is_signer(signer: AztecAddress) {\n        assert(storage.signers.at(signer).read(), \"Only authorized signers can sign proposals\");\n    }\n\n    // Execute a proposal if it has enough signatures\n    #[external(\"public\")]\n    fn execute_proposal(proposal_id: Field) {\n        // Validate proposal exists\n        let operation_type = storage.proposal_operation_type.at(proposal_id).read();\n        assert(operation_type != 0, \"Proposal does not exist\");\n        assert(!storage.proposal_executed.at(proposal_id).read(), \"Proposal already executed\");\n\n        // Check threshold is met\n        let required_threshold = storage.threshold.read();\n        let signature_count = storage.proposal_signature_count.at(proposal_id).read();\n        assert(signature_count >= required_threshold, \"Insufficient signatures\");\n\n        // Check proposal hasn't expired\n        let created_at = storage.proposal_created_at.at(proposal_id).read();\n        assert(context.block_number() <= (created_at + PROPOSAL_EXPIRY), \"Proposal has expired\");\n\n        // Execute based on operation type\n        if operation_type == OPERATION_ADD_SIGNER {\n            // Add new signer\n            let target = storage.proposal_target.at(proposal_id).read();\n            storage.signers.at(target).write(true);\n            storage.signer_count.write(storage.signer_count.read() + 1);\n        } else if operation_type == OPERATION_REMOVE_SIGNER {\n            // Remove signer\n            let target = storage.proposal_target.at(proposal_id).read();\n            storage.signers.at(target).write(false);\n            storage.signer_count.write(storage.signer_count.read() - 1);\n        } else if operation_type == OPERATION_CHANGE_THRESHOLD {\n            // Change threshold\n            let new_threshold = storage.proposal_new_threshold.at(proposal_id).read();\n            storage.threshold.write(new_threshold);\n        } else if operation_type == OPERATION_EXECUTE_TRANSACTION {\n            // transaction execution\n            let wormhole_address = storage.wormhole_address.read();\n            let token = storage.proposal_transaction_token.at(proposal_id).read();\n            let recipient = storage.proposal_transaction_receipient.at(proposal_id).read();\n            let amount = storage.proposal_transaction_amount.at(proposal_id).read();\n\n            let field_bytes_token: [u8; 32] = token.to_field().to_be_bytes();\n            let field_bytes_recipient: [u8; 32] = recipient.to_field().to_be_bytes();\n            let field_bytes_amount: [u8; 32] = amount.to_be_bytes();\n            let mut payload_1 = [0; 31];\n            let mut payload_2 = [0; 31];\n            let mut payload_3 = [0; 31];\n            let payload_4 = [0; 31];\n            let payload_5 = [0; 31];\n            let payload_6 = [0; 31];\n            let payload_7 = [0; 31];\n            let payload_8 = [0; 31];\n\n            for i in 0..31 {\n                payload_1[i] = field_bytes_token[i + 1];\n                payload_2[i] = field_bytes_recipient[i + 1];\n                payload_3[i] = field_bytes_amount[i + 1];\n            }\n\n            let _ = Wormhole::at(wormhole_address).publish_message_in_public(\n                proposal_id as u64,\n                [\n                    payload_1, \n                    payload_2, \n                    payload_3, \n                    payload_4, \n                    payload_5, \n                    payload_6, \n                    payload_7, \n                    payload_8\n                ],\n                0,\n                2,\n                context.msg_sender().unwrap(),\n                0,\n            ).call(&mut context);\n        }\n\n        // Mark proposal as executed\n        storage.proposal_executed.at(proposal_id).write(true);\n    }\n\n    // View functions\n\n    #[external(\"public\")]\n    fn get_threshold() -> u8 {\n        storage.threshold.read()\n    }\n\n    #[external(\"public\")]\n    fn get_signer_count() -> u8 {\n        storage.signer_count.read()\n    }\n\n    #[external(\"public\")]\n    fn is_signer(address: AztecAddress) -> bool {\n        storage.signers.at(address).read()\n    }\n\n    #[external(\"public\")]\n    fn get_proposal_operation_type(proposal_id: Field) -> u8 {\n        storage.proposal_operation_type.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    fn get_proposal_signature_count(proposal_id: Field) -> u8 {\n        storage.proposal_signature_count.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    fn get_proposal_executed(proposal_id: Field) -> bool {\n        storage.proposal_executed.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    fn get_next_proposal_id() -> Field {\n        storage.next_proposal_id.read()\n    }\n\n    #[external(\"public\")]\n    fn get_wormhole_address() -> AztecAddress {\n        storage.wormhole_address.read()\n    }\n\n    #[external(\"private\")]\n    fn send_message_to_wormhole(\n        wormhole_address: AztecAddress,\n        nonce: u64,\n        payload_1: [u8; 31],\n        payload_2: [u8; 31],\n        payload_3: [u8; 31],\n        payload_4: [u8; 31],\n        payload_5: [u8; 31],\n        payload_6: [u8; 31],\n        payload_7: [u8; 31],\n        payload_8: [u8; 31],\n        message_fee: u128,\n        consistency: u8,\n        token_nonce: Field,\n    ) {\n        // Call the Wormhole contract's publish_message_in_private_flat function\n        let _ = Wormhole::at(wormhole_address).publish_message_in_private_flat(\n            nonce,\n            payload_1,\n            payload_2,\n            payload_3,\n            payload_4,\n            payload_5,\n            payload_6,\n            payload_7,\n            payload_8,\n            message_fee,\n            consistency,\n            context.msg_sender().unwrap(),\n            token_nonce,\n        ).call(&mut context);\n    }\n\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "61": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "68": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "69": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "70": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "71": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "76": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "93": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "97": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/Users/yashgoyal/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15620477697740044721": {
            "error_kind": "string",
            "string": "Function _assert_is_signer can only be called internally"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9506626199212044257": {
            "error_kind": "string",
            "string": "Only authorized signers can sign proposals"
          }
        },
        "parameters": [
          {
            "name": "signer",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5kCiKovIqRVGkqVsYMJzATRZYFHn3JTUkbRcYreukvYg/051/SPEgjf1r82379fXHl93h+9PPzf2nX5uvx91+v/vxZf/0+PCyezqI9dcm6Z+cy+Ye7+SVN/dNXkHe5yRQskBWIANEhy6gF1W1kEI3oGIfERs0tbACG7BbenagBSCJU5AVqgAI5OTABuohdAU2KODQDNAt6JbqlkoGlByqQzdo6CC3KLIa0PsCJRUH+6hkt2S3gFugGehiLkAGmByqg99CV3UBDVCWpRA4NIOWHaoBJwd08Mt7cTALJnAgg2yCWDQKWWfUNVygGVS3VLeQW4gMWnKoDt1AHVtAb1EEOjjQAlULYMBYzCowVkxKq44VG4AObDAcG9AMSBecFarBcGyAW9gt7Jbulm4WSqrTFaqBFuQCYekGgA7iGEoGSStzATLQKBaQq1BKnWpxaAbqPIICGWhBLtANui14Gx4OsAVvOTmExVLQAB0sBa2Ag6WgoaWgVUtBa5aCxskBHSwFrYODpYCTpYCTLSbn5OAWcAu4pbiluAUtBYy24FyTQ1gsBUzoYCngBg6WAubkoIspM4q1QbAq8AJd+2KA9sUAXTqUCdm1L5AVyED9WQAd2EDn4QKyLFVu2rVzFyADdgu7pbulmyWnlIO0THTWpuHbQjWoO+kUqnkQO2m2Kw5qThg2jcNI9GpX0lqkca0W40ItbBoDgZJWxELaRLpQQhjERlknj5FeW5TAlk2oO5Ww6UCisUVhCQqbtj7VQc2vGP2zEDm1sGn/L8Qp6GQLD3oJcmVIrjL2pYVGT9VB7DS6aiFy0r4izQxUa5oMWh5GYdOCpbEVt+bEYdMaoXFfLZLlijGtlEpKQSdbd8oYFDYoQc2p5KBQwbjWx0Ie25KRR1nGmF0ILd7is0HI7zF2ICOy2MYeZBQ2nRAjXgT3BcG9x4JBYcMS5GuKNWw1PKAcFMoUKmPnp7e3u40fmr68HLdbPTOdnaLkbPX8cNweXjb3h9f9/m7zz8P+dfynn88Ph/H68nCUT6Vzt4dv8iqC33f7rdLb3enqtH6ptExiu1y4c0hIC12I5IkIaNMtGkDtTKJcSMBEgqXxXYMTn0KhfqFR1jUKVB0rQ0O41TWNWSgF0N2QslwNpX5AKPSXQwEuEUpazwqvSzRuLiF7cF9zok8CKVTBAynU3x0IrgcyKXNu3SWYc14v8lmJdshR5h1gPZRpjRJQJJYwr4rMPcF08qTDqsikTIsePIYEStOGQr1pSSGtL2mb1BdFebWTCwhX+8CxmMxI6z70D2hXSB/Qr9cuKK4P4tk0h1JPk7icuVEvdwSYlCiV5hqEcNZujS81cOJI9bxAOlWnlNylwqQ8m2ySXhv1rNdKbpcasykao0f2/FAA+C2vkwIF+RrBA4HU1zUmQ7SCV0Yt6TaFHgnJ9bY4gN0JKGcZ+V2jzMZwhRg69WwM/5kG9dDgfpuGHDpjOwBe18BZdXllNKSbFHqMT3keu0lBjlsQJy9az2uZ5BWRvD4Rzw9vf7KceDrx1BvTWqJCBfkmjY8IJZeo0Ix8W6e0HKOrTfoVy9/VkKfLiIUa36bR4viWW1/veqT3dspM4bpOmSlc2ynY311e0+Xsp8Ej57/18pptrjV5KCRHhtXNtU6Of9SK+yHVdX6YvfSjzkqUc2wIXM5OTsw3HjaY1w4bdXYKLfH4WeTfqh91ts2nXkIk9br6nFLbTARODyryILx6MK88O3BQpFe4rB4D/yccOAun4erz4yQ5FI8q8jXx6fBE5cbs9rSW3WnrJ5focOPwIF/P3up7x89EYbrVXxXFVOGqKK48bvyu8FnePjzujhc/wL2p1HH38HW/tbffXw+PZ5++/Pvsn/gPeM/Hp8ftt9fjVpVOv+LJn09FNjR5fP+sX7fq24R3Upr6NutbOaKU0j+/qTP/AQ==",
      "is_unconstrained": true,
      "name": "_assert_is_signer"
    },
    {
      "abi": {
        "error_types": {
          "109802946059602463": {
            "error_kind": "string",
            "string": "Too many signers"
          },
          "12597309932721628587": {
            "error_kind": "string",
            "string": "Must have at least one signer"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17182889816689385946": {
            "error_kind": "string",
            "string": "Threshold must be positive"
          },
          "775178390595568676": {
            "error_kind": "string",
            "string": "Threshold cannot exceed signer count"
          },
          "9932853091537900381": {
            "error_kind": "string",
            "string": "Invalid signer address"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "initial_signers",
            "type": {
              "kind": "array",
              "length": 20,
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            "visibility": "private"
          },
          {
            "name": "initial_signer_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "initial_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15932786771847369930": {
            "error_kind": "string",
            "string": "Insufficient signatures"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2586041097980296483": {
            "error_kind": "string",
            "string": "Proposal already executed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "508691203383958144": {
            "error_kind": "string",
            "string": "Proposal does not exist"
          },
          "9822098815390167648": {
            "error_kind": "string",
            "string": "Proposal has expired"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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Fi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYCFi0OAxYAIhYC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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "execute_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAHseAgABAB4CAAIAMyoAAQACAAMnAgEBASQCAAMAAABrJQAAAKEnAgEADy8KAAEAAi0KAgEmKAAABAR4RQwAAAQDJAAAAwAAAKAqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZTNjoMgEMffhbMHYPj0VZqmsZY2JkQN1U02je++Q7doPcBltx6YAeTH/IGZB7m483w7df11uJP68CDn0Hnf3U5+aJupG3ocfRAaG81ILSqiFal1RQz2GEVr0bKKWPFrGeXJ0egodFgcUctSkQQ9TcG5yHzbBfcem+D6idT97H1Fvho/P3+6j03/tFMTcBY3df0FLQKvnXfRW6ptNc0vxeCoeS1H35oVwajaQVgBwoVODK70GwJ2CF5AGKpZYhhqNinK7hiQZwCX0r4Y6GuZY5SkABcpDBAiK0X+gxT1YSncwCqF5m/F5BHa6ITQlttcELYgBJTkSQgo+2chIi+k9MyVhZWhrOIrRO5ThfGSljVVAL8tDmP2jNIbpRZWCLUye6ZMlCB8O1RMWpaFFJ4pSEVXiFSwv5kj9pq2C7uqt0Ra6Jqzd6/ude7bt9npe0wzqWqOYWjdZQ4ukrbSybA9YKpxe4z1EDtAK+DHJW79Aw==",
      "is_unconstrained": true,
      "name": "get_next_proposal_id"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZjbblo7EIbfhWsu7Bkf+ypVVdGUVkiIRDTZ0laVd98zXvMPUGl5p6TtRfgY6p852R7Wz83X/ZeX758Pp2+PPzYfPv7cfDkfjsfD98/Hx4fd8+HxJNafm6B/mvxN203Lmw91u+nyLgZ5bfIat5sY2CBGQBFoAhQB2YADAJYES3JLN8gMaAaFANWg6ld0gU6AsgCFCIAlwhJhoQBIgG7ADGgGiQDVIKtgVcgGJQASoBlUBlSDhuWtGHRYOgR7X4BDAsDCsook4aw5XCAbZFgyLAUWdWyBZqCOLVANGgH0K0hAy75AArQFkiaTpEES60dZoRloxhYoBsOxARkg4ZCEkwoDmkGFpcLSYGmwdFg0USQtkbUhF2gGEZZYDYgA6piUMmtnLpAAzUDLzdLyWcu9QAbIl7IkKmtWB1QCVINuCc/DQ4ESGGAlKBGWaCUoRAArQeEASAArQclWglKtBKVaCUojgJWg9ADIACtBDQyw9NYIS4SFYCFYGBa2EtTEACtBzbBkK0EtBLAS1BoACWAlqE2TyQK6QTgplAWa7osFuoGmjouA7guuCgnQDDIBikGJAC1uV+gG6s8CsDRYGiwdlm6WHlQnK3QDTeYC1UBPyKSnqVZ5gFY5sUI2SLCo8wM0makpiHLWVdp+C8AyXC16TjOgGowcDpCvyOMMH57VQQ1EbiNZmWmc9eTktiRymQcVrMjBKYOK20py6qDqtuoeNHJy5e4qHWvjaNI0qII0s0bZSZMzSLe0tn6MmZzcpq2QFyqg6raqWStKLWBFS04d1N3WbTNGGhtsIbdFciogCk5QGRfSQglRjgvIKDt1kJ6oI95x0yxrm39Hd9vogzyu5+B0sXWLlyN84QjvmdjJbUxOyCknt+EuiIzLQMiVs6uUsfb1dbvBTPL5+bzf60hyNaTI6PK0O+9Pz5sPp5fjcbv5Z3d8Gf/px9PuNF6fd2f5VDbF/vRVXkXw2+G4V3rdXlaH9aWyA0Kz5cK9uYR08I1InIhI2aBBpV5J8I0ETSRaqBEaLbRLKKXfaPC6BkundNMQrnlNYxYKa38tbnBKq6HkPxBK+cuhUGMPJaxXpa1LyOUEidqprznRJ4Fw0aN0CYTlXn5vIGk9kFmblxbghjBfapJvt0qc9GiRKdI0SqIrP2q71Zj0aNTjZkhQIFeQ6fZWIU1qIiMjapLpkk+O9VZj0qLsNZER1xXkB8KtwqRBKXb0uJzofV2jrmtkQovnq4L8lkL3gsR8XxzU4ATxVUV+1aBZc2XCCRzzVX/+nkbprtH6fRpyn/k+obauwbPuQmfUVO5S6CmbQs/3+SD3kO/VUNbrSpO6ys8y9GdK17fa76QzXa6CfGdZ2TtUsN2l8SdCiewdGlO7b6fU6EdXnexXpr+rIYOrxyK/Be/TqH6vRbnY1jXye3fKTOFtO2Wm8Nadwu3d7TVNZ78cPJ3W0zm9XLNf0EVmn9XLNU0GhVIZfkh3xatB4daPNGvRFv1CaHwpbGztzmHjar/9MmykNBucfC5n+bfqR5pd86Gzi4SeVwe4NBtFA10mOPmFEFdF6mzgKJ4SYV4dA/8nHLoKp6ZVkclAWqKPDHw1gBV++7YNUJBHG/dt/IJc9Jrfe3RMFKbX9JuimCq8KYo3jgq/KnySt7uHw/nmof2rSp0Puy/Hvb399nJ6uPr0+d8nfIKH/k/nx4f915fzXpUuT/7lz0d5AL3l2D/pE5fxNmzleYG+lccHH1kuVCb69KrO/Ac=",
      "is_unconstrained": true,
      "name": "get_proposal_executed"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEUlAAAASy0CAUUnAgIERScCAwQBOw4AAwACJwBDBAMmJQAABWUeAgACAB4CAAMAMyoAAgADAAQnAgIBASQCAAQAAAB0JQAABYsnAgMAAC0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQYtDgMGACIGAgYtDgMGACIGAgYtDgMGKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFAAgBBwEnAwYEAQAiBgIHLQoHCC0OAwgAIggCCC0OAwgAIggCCC0OAwgAIggCCC0OBQgtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQcAAAECAScCCAQALQ4IBy0IAQkAAAECAScCCgEALQ4KCScCCwAFJwIMBAEkAgAKAAABlyMAAAFQLQgBDScCDgQEAAgBDgEnAw0EAQAiDQIOLQoODy0OCw8AIg8CDy0OAw8AIg8CDy0OAw8tDg0FLQ4GBC0ODActDgoJIwAAAiMtCggGIwAAAaAMIgZDDSQCAA0AAATfIwAAAbItCwUGLQsEDS0LCQ4tCw0PACIPAg8tDg8NLQgBDycCEAQFAAgBEAEnAw8EAQAiDQIQJwIRBAQAIg8CEj8PABAAEi0CBgMnAAQEBCUAAAWdLQgFDQAqDQwQLQ4LEC0ODQUtDg8ELQ4MBy0ODgkjAAACIy0LBQYtCwQLLQsJDQoqDQoOJAIADgAAAkUnAg8EADwGDwEkAgAKAAAChyMAAAJSJwINBAItAgYDJwAEBAQlAAAFnS0IBQ4AKg4NDy0OAQ8tDg4FLQ4LBC0ODQctDgoJIwAAAxMtCggGIwAAApAMIgZDCyQCAAsAAARZIwAAAqItCwUGLQsECy0LCQ0tCwsOACIOAg4tDg4LLQgBDicCDwQFAAgBDwEnAw4EAQAiCwIPJwIQBAQAIg4CET8PAA8AES0CBgMnAAQEBCUAAAWdLQgFCwAqCwwPLQ4BDy0OCwUtDg4ELQ4MBy0ODQkjAAADEy0LCQYKKgYKCyQCAAsAAAMtJwINBAA8Bg0BLQoIASMAAAM2DCIBQwYkAgAGAAAD0yMAAANILQsFAS0LBAYtCwcILQsGCwAiCwILLQ4LBi0IAQsnAg0EBQAIAQ0BJwMLBAEAIgYCDScCDgQEACILAg8/DwANAA8tDgEFLQ4LBC0OCActDgIJACoLDAItCwIBCioBAwIKKgIKAyQCAAMAAAO5JQAABgEvCgABAAIcCgIDAhwKAwEAHAoBAgItCgIBJi0LBQYtCwQILQsHCy0LCQ0MKgELDiQCAA4AAAP1IwAABEsAIggCDwAqDwEQLQsQDgAiBgIQACoQAREtCxEPACoODxAtAggDJwAEBAUlAAAFnS0IBQ4AIg4CDwAqDwERLQ4QES0OBgUtDg4ELQ4LBy0ODQkjAAAESwAqAQwGLQoGASMAAAM2LQsFCy0LBA0tCwcOLQsJDwwqBg4QJAIAEAAABHsjAAAE0QAiDQIRACoRBhItCxIQACILAhIAKhIGEy0LExEAKhAREi0CDQMnAAQEBSUAAAWdLQgFEAAiEAIRACoRBhMtDhITLQ4LBS0OEAQtDg4HLQ4PCSMAAATRACoGDAstCgsGIwAAApAtCwUNLQsEDi0LBw8tCwkQDCoGDxEkAgARAAAFASMAAAVXACIOAhIAKhIGEy0LExEAIg0CEwAqEwYULQsUEgAqERITLQIOAycABAQFJQAABZ0tCAURACIRAhIAKhIGFC0OExQtDg0FLQ4RBC0ODwctDhAJIwAABVcAKgYMDS0KDQYjAAABoCgAAAQEeEYMAAAEAyQAAAMAAAWKKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmLQEDBgoABgIHJAAABwAABbMjAAAFvC0AAwUjAAAGAC0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAX2LQEKCC0ECAsAAAoCCgAACwILIwAABdInAQUEAQIABgIGJioBAAEFursh14IzGGQ8BAIBJg==",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZjbblo7EIbfhWsu7Bkfxn2VqqpoSiskRCKabGmryrvvGa/5DVRa3ilpexE+hvpnTraH9XPzdf/l5fvnw+nb44/Nh48/N1/Oh+Px8P3z8fFh93x4PKn15ybYH9G/abuRvPlQt5um72LQV9HXuN3EwA4xAoqCKFAEZAcOAFgSLGlYmkNmgDgUAlSHal/RFBoBygIUIgCWCEuEhQIgAZoDM0AcEgGqQzbBapAdSgAkgDhUBlQHwXIpDg2WBsHWFuCQALCwriJNOFsOF8gOGZYMS4HFHFtAHMyxBaqDEMC+ghSs7AskgCyQLJmkDZLYPsoG4mAZW6A4dMc6ZICGQxpOKgwQhwpLhUVgEVgaLJYo0pbI1pALiEOEJVYHIoA5pqXM1pkLJIA4WLlZWz5buRfIAP1S1kRly2qHSoDq0DzhuXuoUAIDvAQlwhK9BIUI4CUoHAAJ4CUo2UtQqpegVC9BEQJ4CUoLgAzwEtTAAE9vjbBEWAgWgoVhYS9BTQzwEtQMS/YS1EIAL0GtAZAAXoIqlkxWsA3CyaAsILYvFmgOljouCrYvuBokgDhkAhSHEgFW3GbQHMyfBWARWASWBktzSwumkw2agyVzgepgJ2Sy09Sq3MGqnNggOyRYzPkOlswkBqqcbZW13wKwdFeLndMMqA49hx30K3I/w7tntZOAaNhIV2bqZz0NGrakcpk7FazIYVAGlWEraVAD1WGrwwOhQUO5DZWGtbE3aepUQZZZpzzIktPJtrS1foyZBg2btUJeqIDqsFXLWjGSgBWSBjVQG7bmmzFS32ALDVukQQVEYRBU+oW0UEKU/QJyyoMayE7UHm+/aZa1Mr6jDVvvg9yv5zDoYmseL0f4whHeM/GgYWMahJxyGjbcBZFxGSgN5TxUSl/7+rrdYCb5/Hze720kuRpSdHR52p33p+fNh9PL8bjd/LM7vvT/9ONpd+qvz7uzfqqbYn/6qq8q+O1w3Bu9bi+rw/pS3QFBfLlykyGhHXwjEiciWjZoUKlXEnwjQRMJCTVCQ4JcQintRoPXNVg7pbmGcs1rGrNQ2PprcYNTWg0l/4FQyl8OhYRHKGG9KrIuoZcTJGqjtuZEmwTCxY7SJRDWe/m9gaT1QGZtXpIUaKhHl5rk260SJz1adIp0jZLoyo8qtxqTHo0ZblCgoaDT7a1CmtRER0bUJNMlnxzrrcakRXnUREfcoaA/EG4VJg1KsaHH9URv6xp1XSMTWlxH1PsU2ihIzPfFQQIniK8q8qsGzZorE07gmK/68/c0Shsa0u7T0Pts7BOSdQ2edRc6o6Zyl0JL2RVavs8HvYdoXEllva40qav+LEN/pnR9q/1OOtPlKsh3lpVHhyrKXRp/IpTIo0Njkvt2So3j6KqT/cr0dzV0cB2x6G/B+zTquNeiXmzrGvm9O2Wm8LadMlN4605heXd7TdPZLgdPo/V0Ti/XHBBK0dln9XJNk0GhVIYf2l3xalC49SPNWlTiuBCEL4WNIncOGyxrw0ZKs8FpzOWs/1b9SLNrPjQeIqHl1QEuzUbRQJcJTn8hxFWROhs4yiivMq+Ogf8TDl2FU9OqyGQglYpNJ+1yAHHht2/bgCNdH23ct/ELctFqfu/RMVGYXtNvimKq8KYo3jgq/KrwSd/uHg7nm4f2ryZ1Puy+HPf+9tvL6eHq0+d/n/AJHvo/nR8f9l9fzntTujz51z8f9QH0lmP7ZE9c+tuw1ecF9lYfH3xkvVCZ6NOrOfMf",
      "is_unconstrained": true,
      "name": "get_proposal_operation_type"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZjbblo7EIbfhWsu7Bkfxn2VqqpoSiskRCKabGmryrvvGa/5DVRa3ilpexE+hvpnTraH9XPzdf/l5fvnw+nb44/Nh48/N1/Oh+Px8P3z8fFh93x4PKn15ybYH9G/abuRvPlQt5um72LQV9HXuN3EwA4xAoqCKFAEZAcOAFgSLGlYmkNmgDgUAlSHal/RFBoBygIUIgCWCEuEhQIgAZoDM0AcEgGqQzbBapAdSgAkgDhUBlQHwXIpDg2WBsHWFuCQALCwriJNOFsOF8gOGZYMS4HFHFtAHMyxBaqDEMC+ghSs7AskgCyQLJmkDZLYPsoG4mAZW6A4dMc6ZICGQxpOKgwQhwpLhUVgEVgaLJYo0pbI1pALiEOEJVYHIoA5pqXM1pkLJIA4WLlZWz5buRfIAP1S1kRly2qHSoDq0DzhuXuoUAIDvAQlwhK9BIUI4CUoHAAJ4CUo2UtQqpegVC9BEQJ4CUoLgAzwEtTAAE9vjbBEWAgWgoVhYS9BTQzwEtQMS/YS1EIAL0GtAZAAXoIqlkxWsA3CyaAsILYvFmgOljouCrYvuBokgDhkAhSHEgFW3GbQHMyfBWARWASWBktzSwumkw2agyVzgepgJ2Sy09Sq3MGqnNggOyRYzPkOlswkBqqcbZW13wKwdFeLndMMqA49hx30K3I/w7tntZOAaNhIV2bqZz0NGrakcpk7FazIYVAGlWEraVAD1WGrwwOhQUO5DZWGtbE3aepUQZZZpzzIktPJtrS1foyZBg2btUJeqIDqsFXLWjGSgBWSBjVQG7bmmzFS32ALDVukQQVEYRBU+oW0UEKU/QJyyoMayE7UHm+/aZa1Mr6jDVvvg9yv5zDoYmseL0f4whHeM/GgYWMahJxyGjbcBZFxGSgN5TxUSl/7+rrdYCb5/Hze720kuRpSdHR52p33p+fNh9PL8bjd/LM7vvT/9ONpd+qvz7uzfqqbYn/6qq8q+O1w3Bu9bi+rw/pS3QFBfLlykyGhHXwjEiciWjZoUKlXEnwjQRMJCTVCQ4JcQintRoPXNVg7pbmGcs1rGrNQ2PprcYNTWg0l/4FQyl8OhYRHKGG9KrIuoZcTJGqjtuZEmwTCxY7SJRDWe/m9gaT1QGZtXkoq0ChF4hDJt1slTnq06BTpGiXRlR9VbjUmPRoz3KBAQ0Gn21uFNKmJjoyoSaZLPjnWW41Ji/KoiY64Q0F/INwqTBqUYkOP64ne1jXqukYmtLiOqPcptFGQmO+LgwROEF9V5FcNmjVXJpzAMV/15+9plDY0pN2noffZ2Cck6xo86y50Rk3lLoWWsiu0fJ8Peg/RuJLKel1pUlf9WYb+TOn6VvuddKbLVZDvLCuPDlWUuzT+RCiRR4fGJPftlBrH0VUn+5Xp72ro8T1i0d+C92nUca9FvdjWNfJ7d8pM4W07Zabw1p3C8u72mqazXQ6eRuvpnF6uOSCUorPP6uWaJoNCqQw/tLvi1aBw60eatajEcSEIXwobRe4cNlpbGzZSmg1OYy5n/bfqR5pd86HxEAktrw5waTaKBrpMcPoLIa6K1NnAUUZ5lXl1DPyfcOgqnJpWRSYDqVRsOmmXA4gLv33bBhzp+mjjvo1fkItW83uPjonC9Jp+UxRThTdF8cZR4VeFT/p293A43zy0fzWp82H35bj3t99eTg9Xnz7/+4RP8ND/6fz4sP/6ct6b0uXJv/75qA+gtxzbJ3vi0t+GrT4vsLf6+OAj64XKRJ9ezZn/AA==",
      "is_unconstrained": true,
      "name": "get_proposal_signature_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAIoeAgABAB4CAAIAMyoAAQACAAMnAgEBASQCAAMAAABrJQAAALAnAgEAAy8KAAEAAhwKAgMCHAoDAQAcCgECAi0KAgEmKAAABAR4RQwAAAQDJAAAAwAAAK8qAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZTLboMwEEX/xWsW9oyf+ZUqighxIiQEyIFKVcS/d0gxj4W9acvCc23j47l+vdjNX8fHpW7v3ZOdPl7sGuqmqR+XpqvKoe5aan0xPhdGsJMsmNHsZApmqSY4RUdRFMzJnyg4RGFIaBICorAkLAnAKN4t01SwON9lCN7P0+0SoLT6Mvh2YKd2bJqCfZbN+P7p2ZftOw5loF7Kx7c3igS8142f1VRso3l6KOXN7TKctLMrQnB9gIgMBKSJDNBmh8ADAjIIy42IDMvtZkW7AwPTDASl3MIgbVSKkbOCIGMaKGXSivoDK/qfrYDF1QpP74pNI4w1EWEcuFQSLmMEtYJoBLX7tRGZNpI75hpgPeYaFK4QdbwqAnJe1quC9G15WHtk5M4od7hCuFPJNRUyB4FtUenSiiQkc0xRab5ClMb0zuTtwM6OkUmISUOsUQvCuu2yoKbdPVO1rOpweJenGRXq8tr4pXof22rXO3z1sSe+633oKn8bg59J2+MuqPwAUyCc54eaKogFqvM0T/0N",
      "is_unconstrained": true,
      "name": "get_signer_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAIoeAgABAB4CAAIAMyoAAQACAAMnAgEBASQCAAMAAABrJQAAALAnAgEAAi8KAAEAAhwKAgMCHAoDAQAcCgECAi0KAgEmKAAABAR4RQwAAAQDJAAAAwAAAK8qAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZTLbsMgEEX/hTULYHjmV6oochwSWUK2RexKVeR/7zg1fixg09YLz8WYw1wGeJGbv46PS9Peuyc5fbzINTYhNI9L6OpqaLoWv74Im1+Gk5OkxGhyMpRYbHGG0WHklDj5EzkTSRgUGgUXSVgUFoWAJN5fpomSNN9liN7P0+0SwLT6Kvp2IKd2DIGSzyqM75+efdW+41BF7MV8fHvDiMB7E/ysJrqNZvmhmDezy3DUzq4IzvQBwgsQIU1iCG12CDggRAFhmeGJYZndrGh3YECeAUIptzBQG5VjlKyAkCkNkDJrRf2BFf3PVoSF1QrLV8XmEcaahDBOuFwSrmAEtBLJCGj3ayMyb6S0zTVCEkNztdVEHY8KFyUv61EBfLY8rD0ySnuUOVghzKnsmnJZgohtUfHQ8iyksE1BabZClIZ8Zcp2xM6OkVmIyUOsUQvCuq0woLG6Z2xWdRMP9/I0o2JTXYNfmvexrXe9w1efetK93seu9rcx+pm0Xe4c3x/CUBDn+aLGBgAFdZ7mqb8B",
      "is_unconstrained": true,
      "name": "get_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAHseAgABAB4CAAIAMyoAAQACAAMnAgEBASQCAAMAAABrJQAAAKEnAgEABC8KAAEAAi0KAgEmKAAABAR4RQwAAAQDJAAAAwAAAKAqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZTNjoMgEMffhbMHYPj0VZqmsZY2JkQN1U02je++Q7doPcBltx6YAeTH/IGZB7m483w7df11uJP68CDn0Hnf3U5+aJupG3ocfRAaG81ILSqiFal1RQz2GEVr0bKKWPFrGeXJ0egodFgcUctSkQQ9TcG5yHzbBfcem+D6idT97H1Fvho/P3+6j03/tFMTcBY3df0FLQKvnXfRW6ptNc0vxeCoeS1H35oVwajaQVgBwoVODK70GwJ2CF5AGKpZYhhqNinK7hiQZwCX0r4Y6GuZY5SkABcpDBAiK0X+gxT1YSncwCqF5m/F5BHa6ITQlttcELYgBJTkSQgo+2chIi+k9Mw1leu9ampghch9qjBe0rKmCuC3xWHMnlF6o9TCCqFWZs+UiRKEb4eKScuykMIzBanoCpEK9jdzxF7TdmFX9ZZIC11z9u7Vvc59+zY7fY9pJlXNMQytu8zBRdJWOhm2B0w1bo+xHmIHaAX8uMStfwA=",
      "is_unconstrained": true,
      "name": "get_wormhole_address"
    },
    {
      "abi": {
        "error_types": {
          "12195054196221641452": {
            "error_kind": "string",
            "string": "Function increment_signature_count can only be called internally"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2586041097980296483": {
            "error_kind": "string",
            "string": "Proposal already executed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "508691203383958144": {
            "error_kind": "string",
            "string": "Proposal does not exist"
          },
          "9822098815390167648": {
            "error_kind": "string",
            "string": "Proposal has expired"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "increment_signature_count"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZjbblo7EIbfhWsu7Bkf+ypVVdGUVkiIRDTZ0laVd98zXvMPUGl5p6TtRfgY6p852R7Wz83X/ZeX758Pp2+PPzYfPv7cfDkfjsfD98/Hx4fd8+HxJNafm6B/mvxN203Lmw91u+nyLgZ5bfIat5sY2CBGQBFoAhQB2YADAJYES3JLN8gMaAaFANWg6ld0gU6AsgCFCIAlwhJhoQBIgG7ADGgGiQDVIKtgVcgGJQASoBlUBlSDhuWtGHRYOgR7X4BDAsDCsook4aw5XCAbZFgyLAUWdWyBZqCOLVANGgH0K0hAy75AArQFkiaTpEES60dZoRloxhYoBsOxARkg4ZCEkwoDmkGFpcLSYGmwdFg0USQtkbUhF2gGEZZYDYgA6piUMmtnLpAAzUDLzdLyWcu9QAbIl7IkKmtWB1QCVINuCc/DQ4ESGGAlKBGWaCUoRAArQeEASAArQclWglKtBKVaCUojgJWg9ADIACtBDQyw9NYIS4SFYCFYGBa2EtTEACtBzbBkK0EtBLAS1BoACWAlqE2TyQK6QTgplAWa7osFuoGmjouA7guuCgnQDDIBikGJAC1uV+gG6s8CsDRYGiwdlm6WHlQnK3QDTeYC1UBPyKSnqVZ5gFY5sUI2SLCo8wM0makpiHLWVdp+C8AyXC16TjOgGowcDpCvyOMMH57VQQ1EbiNZmWmc9eTktiRymQcVrMjBKYOK20py6qDqtuoeNHJy5e4qHWvjaNI0qII0s0bZSZMzSLe0tn6MmZzcpq2QFyqg6raqWStKLWBFS04d1N3WbTNGGhtsIbdFciogCk5QGRfSQglRjgvIKDt1kJ6oI95x0yxrm39Hd9vogzyu5+B0sXWLlyN84QjvmdjJbUxOyCknt+EuiIzLQMiVs6uUsfb1dbvBTPL5+bzf60hyNaTI6PK0O+9Pz5sPp5fjcbv5Z3d8Gf/px9PuNF6fd2f5VDbF/vRVXkXw2+G4V3rdXlaH9aWyA0Kz5cK9uYR08I1InIhI2aBBpV5J8I0ETSRaqBEaLbRLKKXfaPC6BkundNMQrnlNYxYKa38tbnBKq6HkPxBK+cuhUGMPJaxXpa1LyOUEidqprznRJ4Fw0aN0CYTlXn5vIGk9kFmby2ThLVrEJxfJt1slTnq0yBRpGiXRlR+13WpMejTqcTMkKJAryHR7q5AmNZGRETXJdAmEY73VmLQoe01kxHUF+YFwqzBpUIodPS4nel/XqOsamdDiMqLep9C9IDHfFwc1OEF8VZFfNWjWXJlwAsd81Z+/p1G6a7R+n4bcZ75PqK1r8Ky70Bk1lbsUesqm0PN9Psg9RH4llfW60qSu8rMM/ZnS9a32O+lMl6sg31lW9g4VbHdp/IlQInuHxtTu2yk1+tFVJ/uV6e9qyODqschvwfs0qt9rUS62dY383p0yU3jbTpkpvHWncHt3e03T2S8HT6f1dE4v1xwQSpHZZ/VyTZNBoVSGH9Jd8WpQuPUjzVq0Rb8QGl8KG1u7c9iofW3YSGk2OPlczvJv1Y80u+ZDZxcJPa8OcGk2iga6THDyCyGuitTZwFG8vMK8Ogb+Tzh0FU5NqyKTgbREHxn4agAr/PZtG6Agjzbu2/gFueg1v/fomChMr+k3RTFVeFMUbxwVflX4JG93D4fzzUP7V5U6H3Zfjnt7++3l9HD16fO/T/gED/2fzo8P+68v570qXZ78y5+P8gB6y7F/0icu423YyvMCfSuPDz6yXKhM9OlVnfkP",
      "is_unconstrained": true,
      "name": "is_signer"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwez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qmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTfmyuvISVsQA0p4fzWkFLjJp6H1fPfGxCvIaVGI07iu3ZqSKkxiEncxHftzPkjjlcDeh44iYvor4bq+YtJpBt7frLnJ3t+sucne36y5+d6V+pcPJOLZ3LxTFbPowbnmXSeSfb8ZM9P9vxkz0/2/GTPT/b8ZM9P9HzVEDyTwTMZPJPBM1k9X28na6Cpsc4k1t3E87B6/mIdmxcacRIX0YlBTOImlls1TvX8RV7g1ehePVSNftGJQeSlUY1+kZt1uFmHm3V42R9e9oebdbhZh5t1uFmHm3XeZtUUU+MgGrGOYhcGMYl1FKfwW7fegtfPsjUOohEncRGdGMR8WKFQb+1ruqnRiJNY69ZRVChcDGIS6yYHeB5WKFwcRCNO4iI6sW72gOdhtf/FQayjmIV1EwkMYhK/desBRU03XaxGv1hnxwvfDXJNNzUuIt2cbk63avSL73Z8xY84iHQLWlQf11uCGnRqPA+rjwM4iHVK6uKqPr64iF/pWZdG9fHFJH5u9QykBp0uVh9fHMTPLaveaumLi+jEcqtTXc1bz1Zq/KlxEGvdKJzERXRiEJO4ieX2nZ0aimocRCNO4iI6MR5Wx9YDoJqEinoAVJNQjU4MYhI38SuyHgvVJFTjIBpxEhfRiUEst1m4iedhdezFQTTi7G2psapGJwaxzvqXJfUrZvfsVJtenMRFrNJXIU9JtSmw2vRiFVlu1aYXJ7FOSRRyA5wb4NwAp5vTLehWbXrRiNzu4HYH3YIW+Z4NOh67AY1Yi+3CRXTiV3o9YKvBrMZN/EqvR0g1mNU4iF/p9QipBrMaF9GJQUziJp6H1bwXB5Fuh26Hboduh26Hbodu57nVuFbjIBpxEhfRiUEstyjcxPOwuruelNVoV2O5ZeEkLuKfW9ajtBrtaswPrXATz4ffDtVoV+Mg2odVztfzjYvoxCDmw1nrVmWzVqijmLXCKXRiEJP41VuPZGoi7OL3etw4iEb83OqpT02ENToxiEncxHKrGvxHHEQjfm71+KYmwhqd+LnVDUZNhGU9camJsMbPzeqcfe3f+LlZnb6v/RsncRGdGMQkbuJ5mD8i3ZJuSbekW9It6ZZ0S7ol3TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dTrl9V3X9xFjjIBrxc6snZfUTY41ODGISN/E8/PKhcRCNSLdBt0G3QbdBt0G3QTejm9GtkuD7AN9r2i2/+V+vabfGWuF7Ga9pt8ZBNOIkLqITa90vmGqCDRtQE2z3/FbPX1xEJ9YRe2ESN/E89Hft1ARboxEncRGdGMQk7leO89oJXjvBayd4bNXz3/SC11xbY52dWrd6/mISN/FzqyenNe3WOIhGnMRFdGIQP7d69lrTbher0bFZ1ej13rRG3BoncRH9bcDmZm1u1uZmbW5WNfrFQeRmsdGTjZ5s9GSjJxs92eh5Xqzs349YRzELF9GJdaJWYZ0oL9zE87Ba+uIgGnESF9GJtW4UnofVvBcHsdato6gX94uL6MR6ad6FSdzE8xAv+cBBNOIkLmL2R98YZrt4HtZLfj2+qWG2RiN+6zr+t4voxNqLcqv2v7iJ31HU/EMNvjUOovWH8hh8u7iITgxiEjfxPKyP3y8OIt2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLelW7e91VVf7X9zE0yMLGJK7WGeyrr5KgouTWPtWe1FJcDGISdzE87CS4OIgGnES6Xboduh26Hbodp5bjcNlPUqrwbesR141+Jb1RKsG3xo38Tysnq9HSPWLXI1GnMRFLDcvDGISy62KrCQAVhJcLLcsNOIkLqITg5jETTwPKwku0m3SrZKgHgvVQF3WA6AaqGsMYhI38TysfLg4iEacRLpVPtQTohqoa0xiudVmVT4AKx8ullud9bo9uDiJn1s9zKiBusYgfm71/KEG6hrPw7o9qGcKNVDXaMTPrd6N1y9yNTqx3Kqcuj24uImfW73JrOG7xkH83Gpeo4bvGhfxz23XG8cavmtM4v6w3L58uPjlQ+Of265HqzV81ziJ68M6Z18+NAbxc6u3XDV813gefvmw69P1Gr5rNOLnVu/Javiu0YmfW93e1vBd4yZ+bt89V9TwXeMgfm7f9/Wihu8aF/Fz+17Ro4bvGpP4uX0v41HDdxe/LGn83L7XrKjhu8ZJ/Ny+rI4avmsM4uf2PWqPGr5rPA+/LNlRi31Z0mjEz+3r7qjhu0YnBjGJm3gezh9xEI1It0m3SbcvS3bW2fmypHETP7esHfqypHEQP7ddZ+fLksZF/Nx27dCXJY1J/Nx27fGXJRe/LGn83E6dvi9LGifxczvl9mVJYxD/3M731Cdq1K/xPPyy5HxDRlGjfo1GnB+W25cljU78czsDiyVxEz+3UYt9WdI4iJ/bqJP6ZUnjIn5uo05JBjEf1vuLrJNa9w9ZB1/3DxedGMQkbuJ5WPcPF6veunaOESdxEZ0YxCRu4nd2vmdBUZN8jYP4uX1xFTXJ17iI9XochUFM4iaeh7jXAJbbLDTiJJYb/rdODOJ3bN9vhERN8jWeh1bHtgsH0Yif2/dOLWqSr9GJQUziJp6HXz40DqIR6TbpNuk2y62ObZ5X5FpEJwYxiZvIFbwqAw6iEauyU7iITgxiEjfxPKzuvjiIRqRb0K26e9XVV919MYmbeB5Wd1/83OrFp+b7GidxEcstC4OYxHKryr47heN12X893/i5fQMHUfN9jZ+bVzlfEjQ6MYhJ3MTz8PyIg2hEuh26Hboduh26Hbqd51ZTf42DaMRJXEQnBjGJm0i3QbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejWyVB3dnULGDjIBrxJYExCYxJYDOISdzElzs1C9g4iHUUqzA7Vmq+7zj+B+dh5cPFQTTiJC5inYdaN3h+g0ccPOLq+YuLWOc3C4OYxE3kbibdkruZ3M3kbiZ3M7mb1fOooXr+4iZyN9HzVQN6HmhEurHnjT1v7Hljzxt73tjzdnjtHJ7JwzN5eCbR81XD4Zk8PJPseWPPG3t+sucne36y5yd7fv7evk30PDCISXz7NtHzheNHpBt7frLnJ3t+sucne36y5yd7fo63b9N+xEE04iSW2y50YrmdwiRu4nlYPV9vS2oWsNGIk7iITgxiEj+3ejdTs4AXq+etjNfsLqypv/ON8kRN/TUGMYncocUdcu6QD6IRJ3ERuUPOHXLukHOHnFcfU2MGr4fg9RC8HiofvgdLUfN9jZtYZ6fOQ+VDVGWVDxeNOImL6MQgJnE/3P3EJWqor3ESF9GJQax1awsrCS6eh5UE3xOiqKG+RiN+R/E9AIoa6mt0YhCTuImnsYb6GgfRiJO4iE4MYhI3kW6DboNug26DbpUE3wP4qFG/U2+NatSvMYmbeB5WElwcRCNO4iLSzfpJWdQAYOMm9pOyqAHAxkGsJ2V1FPXM8eIiOjGISdzE87CeOV4cRLotulUS1NVXA4CnninUAODfg7HCQTTiJH4rfEM7UUN9Z9cOVR9fHEQjTuIifucXp6+6+2ISN/E8rO6+OIhGrHpP4SI6MYjlVjtU3X2x3o3X2cG7fOAgGnES69jq/FbHfg9Goyb5Gidx3SenUZN8jUFM4iaexprkaxxEI07iIjoxiEncRLoNug26DboNug26DboNug26DboNuhndjG5Gt+rYemBVA4CNTgxiEjfxu6K+J9NRA4CN377Vc64aAGycxEV0YhCTuInnYb12X6TbKrdVOIn9JD1qQrAxiPmw+vgb7YqaBTynTlQ9rfvVYu7EIOZ9+B01C9h4HkY9Ha8iv+5uNOIkLqITg5jETTwPk25Jt+rjb7wsagDwfI/7A3+P9FfPFPEHSS/XX+tpHsKr2IqzuFbfW/iQz094CJvwLK4zdZawC4dwCm/h8xh/dbQZvqPYhKfwEoZvFIcwfHfxFj7k8RMewiY8hZewC4ew+I7+PCRq8O9iPcW/2J+HRA3+NU5iffpyCp0YxCRu4nlYT/EvDqIRJ5Fuk24TZ6+4/ojXr54o46+L/r5PiQJ/XrR5CbtwrfP95Evgz4b+Ru24m/AUXsIuHMJ1tusBNv56aPMh19/pah7CJjyFlzB8Z3EIp/AWhm/tfv6Ex/0wK/A3QX/YfzT05UNGQ+MSQENftvuRV9TUXuMiOhFrF6OZ6zFzzeLhU7GaxWtcRO9PxQIfvAGTWB+8VZfhg7cPEx+8AQfRiJO4iE4MYhI3kW5o0Xrsjb/h+TP8/9cmfZNCgb/i2byFD9mwzimudb45u8Cf52xO4S18yPVn9ZrrbNcu4I90Nk/hJezCIZzCWxj1f3uBP9bZPIRNGL6zeAnD14tDOIW38CH7T3gIm/AUXsLi6+/D1prYa9zE92FrTew1DuJ3ha26EOqF+eIiOjGISdzE87BemC8OIt2SbomzV/Wgj6tT8Cc5f/W8H3+Ts9mEp3Ct843zBf7W5q+e9OOPbTYPYROewku4zjbqxAvz5RTewucx/uxm8xA2Yfj+ipewC4cwfL14C8P360r8Uc1ffRqBv6rZHMIpvIUP2X7CQ9iEp7D41uttPS2rWbzGJO7+5L5m8S7W6+3FmgiwQiNO4iI6MYhJ3MTzsD41v0i3RTf0eH2Cgz+a+bv//3WWcCDo5ctD2ISxTu0UXmjrERz+HuZlvNBeHsImPIXrbNejR/xVzOYQTuEtfMh4ob08hOFbe5FTeAm7MHxr9/Eqfbl8v+GxwN/IvIzuvjyEy7ceXOLvZDYvYRcO4RTewoeMNLg8hMW3XtpryKJm7hqdGD1kUTN3jZtYsxnfhtcP0zUOohEncRGdGMQkbiLdBt1w810PcPFnMH/1wBN/B/NXTybxhzCbDxm9fxnrnOJap54oHryyX97Ch4xX9stDuM52Pac7eGW/vIRdOIRTeAsfMl7Zv8nBOHhlv2zCUxi+s9iFsX6dT7wi1/4evCJfduEQTuEtfMjo+stD2ITFt16Z61l/Dcs1BrEGk6r2emW+eB7WK3O1Wg3LNRpxEhfRiUFM4iaeh5tum27o5XpIeNCz9ZTwoGc3/jeHjJ69PIRrnXqOd/CKXE/kDl6RL5/m/OEV+fIQNuE6299zo/zhFfmyC4dwCm/hQ8Zb5cvwtWITnsJLGL5ZHMLwPcVb+JDRxZfL93v4kz+8gl+ewkvYhUM4hbfwIaPrL4vv7IG0xPjbxUXsgbTE+NvFJNZA2iw8D+uF/OIgGnESF9GJQUwi3Rbd8Mp+anfQ+6eKR++fqhO9f3kLHzJ6/NRu4hX8G1zNH17BL6fwFj5kvIJf/s72+B5gZQ2tPZ7CS9iFQziFtzB860rGK/jlIWzC8K3d30sY69f53Fv4kKvrm4ewCWP9Ov9nCeO46jyfEIZv1Xa2MHy/vaght8fw3cUmDN9TvITL95sqzBp1e1y+36OfrGG3x+X7PeLJGnd7XL7fY5GsgbfH5fs9BsoaeXsMXy8OYfhG8RaGbx2j/YThW8doJgzfOkZbwuVrdYyVEs09H5vjzcfmePOxOd58bI43H5vjzcdmzb/9rVZnqe4Kml0YjnUG6q6geQsfct0VNA9hE57CS9iFxXeJr2P9OvOOdepsO9apM+wuHMIpvIWl/pD6Q+oPqT+k/pD6Q+oPqT+k/pDzFuKb4oskwTEiMXCMKfWn1J+HvH/CQ1jq31L/lvq31L+l/i31b6l/S/1H6j9y3o74HvFFYuAYkQx1jPZj/fYbwiY8hZcw67dfCKfwFmb9Nn7CQ9iEp/ASFt8hvkiAOkZDp+MYTeo3qd9cOIRTeAtj/S89asTtcb1AA404iYuItb88MPTu94wwa3Kt5suzfsWucRJ76jzrV+wag/jlU72E15Rb43lYM+4XB9GIk7iITgwi3Zxu6ODv68hp6NRZxaNTZ9WJTr2cwpuM1/xZu4fX9lk7gNf2yyGcwlv4kNGps848OvWyCU/hJezCIZzC8K2rD50KRqdeHsLlu2r30amXy3fV+cRr/uUQTuEtfB5PdPblIWzCU3gJ1zcNfoVBTGJ9r2EUnofjR6wr7BQacRIX0YlBTOImnof1udlFuhnd0N/fl4Bzoo+/J4s50cff0+Kc6OPLQ9iEsc4uxjq1Pl6Hwejly0PYhKdwnW2vc4XX4cshnMJb+JDx+nx5CMM3i6fwEnZh+Nbu43X7MnzrPOB1G4zXba9/i673Oj/4Ekud8vcllpzvSyw535dYEiNtF5O4iedhDb1cHES6Jd2QGFEXKhLjcgin8BY+ZCTG5SFswlMYvnX+kRiXQziFt/Aho9OjrlV0+uUtfB4vdPrlIYw6o3iS8dr7PQnLhdfeyyaM//0pXsIu3F9CSoygXdzE/hJSYgTt4iDW/tViNdBycRGdGMQkbuJ5WAMtFweRbpNuuOPOKhgd/T1vy4WO/p6Z5UJHXzbhKYx16syjQ7PONjr08hA24Sm8hOtsf0+VcqFDL6fwFj5kdOjlIWzC8F3FS9iFQxi+dd7wen25fOvpzsKddT38WHgdv2zCU3gJu3AIp/AWPuQtvjWnXm//alKtcRLre2N1DrYTg1gXdG1CTadePA9rOvXiIBpxEhfRiUGk23lujl6up0SOV+d6Tua47677Scd99+UU3mT0+PfnYtPRy/XsytHLl0M4hbfwIeMddt2aOt5hXzbhKbyEXTiEUxj1n+JDxuv15SEM31U8hff9enU6hkYLMTQKHESsUecenX15CbtwCKfwFj5kJMHlISy+Lr4uvi6+Lr4uvi6+Lr4hviG+Ib5IgnqK50iCevrmSILLIZzCW/iQkQSXh7AJT2HxrR+6uRjEJO77rfes0beLNa168dvYehRZP37XOImL6MQgJnETz8P6pupFuh264f4d9dSrt9XdMYbd7BvESwy7NQ9hE/biVYx1vPiQx094CJvwFF7FWezCIZzCW/iQ7Sc8hOE7i6fwEnZh+O7iFC7fuqGoObbmSoLmIWzCU3gJu3AIp7D41oP5eoxZP3vXOIg1P1fHUe/ZLy5izc+NwiAmcRPPw3rPfnEQjTiJi0g3p5vj7BUHzlLVFjhLdXXFEnbhEMY6X27Ur9T9ce14TuEl7MIhnMI426f4kPdPeAib8BRewi4M37rydwpv4UOud+1WT34xLddcvvWstgbjHodwrW91btH1l2v9elaV6PrLQxjre/EUXsIuHMIpvIUPGSlxeQiL7xDfIb5DfIf4DvEd4jvE18TXxNfE18TXxNfEFylRz/Uwh9e8hQ8ZKXF5CNe3FoDxLue8AQDewrzkMWJn9UgQo3S4hDFK1+zCKHkXp/AWRsnfpYpRuvtvfQibsPi6+Lr4egin8BY+5BDfEC/EQD2mTMTA5RSuNb9xxEzEA7huAZqHcK1fDwcTsXF5CbswfKtFEA/1EA0Ddc1DGOvXfiEeLi9hFw7hFN7C8K1zgni4PIRNeAovYReOxxius3qYiCE6qweCGKJrduEQTuEtXDXXQ72N1r88hE14Ci9hFw5h+M7iLXzIaP3LQ9iE59s7DN01u3AIY1++uN1oa5w3vPhfnsJLGMeyiuVcocfB6PHLqLl8lwlPYZyrKJY9WrJHS/Zoie8SXxdf9P5lE5Zrw+XacPF18UJf180jxvCaTXgKY826JtHjdcOIcbtm3nhi3M7q8SjG7ZpNGDXX+UeP33/rwiEsvim+Kb77JzyETXgKi+8WL/S117lCX18ewrVmPRLd6OvLS9iFa32vaxu3A5e38Hl80Pvf2GEe9P43WpkHvX/ZhbF+FKfwFj5k9P7lIWzC8M3iJezCIZzCW/iQ0fuXseYprn9bj00xaNd8yHjpvjyETbhq/ubEEoN2zS4cwim8hQ8ZvX8ZvrVH6P3LU3gJu3AIJ/cOvX/5kNH7l7Evo9h53vCafjmFtzCOpa6lkHOFHr+8hFFz+eL1/XIK41zVdRKyRyl7lLJHKb4pvim+6P3LISzXRsq1keK7xQuP3Q/YhUM4hbFmXZP4QK4eaR18IHd5CqPmXezCIYya6/yfLf/2PTLbGNVrHsImPIWXsAuHcApv8hAv9PX3gHtjDK/ZhetYvgffG2N4zVv4kNHX34PvjTG8ZhOewvBdxVjfi7fwIaP3v/vzjXG7ZhOewkvYhUMYvlm8hQ8ZvX95CJvwFF7CWPN8jNfuXecWvXx5Ci9hFw7hqnnXOUePXz5kvL5fHsImPIWXMHxrj9D7l1N4Cx8yev/y4N6h9y9P4SWMfanrE32N84bX9MtD2IRxLHUtbTlXuG+/vIVRc/ni9f3yEMa5quvkyB4d2aMje3TE94jvEV+8vhdjAK95CJvwFHZhfNDixYeMHr88hLFmFuODnCgO4RRGzbv4kNHjl1HzKTb+W5vCS1h8TXxNfPGI//Ihz5/wEBbfKV7o61PnCn19+ZDR19+QysaYXLMJT+Ha9++jiI0xueYQTmH4ftfkQO+f2gv0/uUpjPWrfvT+5RBO4S18yOj9y/CtfUfvX57CS9iFQziFNxl9feoaqNfu+atzW73cnMJb+JCrx5tHcZ3z6vHmKbyEXTiEU3gLw7f26PyEh7AJT+El7Nw79P7lFN6PMVZn9fqL8TmcN4zPNbtwCONYvmsJY3I4VxiTazZh1Fy+Ywm7MM5VFKf82y3MParfi3ssvia+NoWXsAuHsPiaeN1Rm108hZewC2PNLH4jONs4grONIzi75un+/vf1b9cUXsKoGf/7kH+bwltYfF18XXzdhKfwEnZh8XXxqr6eo85V9XXzFK5j+T6L2Bi2aw7hFK59/x7/7/phueZ6TW8ewvCtaxK9P+q6Qu9fTmGsX9cbeh+M3r88hE14Ci9h+Na+o/cvp/AWPmT0/uUhbMJYs855vXbP75H/xiBd8xA24Sm8hKvm70v3uybpHqfwFj5k9P7lIWzC8J3FS9iFQziFt/B5ezfR+5eHsAljX0ZxvvOGMbvmQ54/YRzLKpZzNV04hFFz+c4tfMgL5yqKZY+W7NGSPVriu8R3ie9K4S0s14bLteHi6+KFvp5VGz6uv7yFDzmwZhZjIBW8hF0YNe/iFN7CqLnOPz6Wx7+9g7ZgExbfFN8UXw7g7skB3D05gLsnB3D3Hae7LF7o61nnCn19OYXrWGZd8+hrMPr68hCufZ91beM1/fISdmH41jWJ3v+eM2+M1jUPYawfxVN4CbtwCKfwFobvd04wotc8hE14Ci9hFw4y+vp7Br4XXru/58N7oZcvu3AIp/AWrpq/zwL2Qo9fHsImPIWXsAuHMHxn8RY+ZPT+5SFswpN7h96/7MIhjH358g1De/e8uQlP4SWMY1nFcq78kNHjl1Fz+eL1/fIUxrmq6yRkj0L2KGSPQnxDfFN88fp+2YTl2ki5NlJ8U7zwmr7qGsNret2nLbymX57CS9iFQziFkSfwOuTzEx7CJjyFl7AL4ysedZ7R+3Xf5ej9y0PYhOu4vs8INkb0ml04hFN4Cx/y/WpMFA9hE57CS9iFQziFNxmje3XsGN27x3XzAbyEXViOy+S4TI7L5LiQD5eHsAnLcU05rinHNeW4phzXlOOah7zkfC45n/ercHXsS44LOXA5hbewHJfLcbkcl8txuVwnLteJy3Xiclwux+VyXC7HFXJcIccVcp2EnM+Q83m/IlfHHnJcIdd/yvWfcv2nHFfKcaUcV8pxpVwnKddJynWSclxbjmvLcW05ri3HteW4tlwnW87nlvOJr97XM437q3aXTXgK47hG8fvy8r6/Xnf5PMZA3/w+B9wY6Gs2YZy3Wbzk37pwCKfwFhZffCX/8hA24SksvkO88F7g+yxyY7iveQjjWKJ4Ci9hF8Y1kMUpvIUP+WZF1YN7hu+zrY0hvmYXrvW/z4M2hviat/Ah457h8hA24fL9vpKx8Rt2zS4cwim8hQ8ZWXEZa9Y14Pi3dW5xz3D5kHHPcHkImzBqrnOOe4bLLhzCKbyFDxk5cBm+tUfIgctTeAm7cAgn9+7mAPiQcV9xGdebFzvPG+4ZLqfwFsax1LV05FzhfcHlJYz1yxfvCy6ncK1fn51hrA//FmN9zUPYhKfwEnbhEE7hLSy+Q7zuT23MYhcO4RTGsXzXJEbz6mdD9v0pvMtTuGquzwExmtccwlVzffZ3fyLv/ttDxk9qXBbfKb5TfPFDOpddOIRTWHyXeKGvE7yEXRjHEsUpvIUPGX1dnwNiZq/ZhKcwfHcx1j/FW/iQ0fv1eVCi9y+b8BRewi4cwuW7a9/R+5cPGb1/eQib8BRewlizrgG8L8D5Ry9fnsJL2IVDGDXXOUePXz5kPBO4PIRNeAovYfjWHqH3L6fwFj6PMb/XPN7e4cfxmqfwEsb15sXnnTfM7DUPYRPGsexinivM5jVvYaxfvnh9vzyEa/367Ayzefff2hJ2YfE18TXxxes7GK/vl4ewCYvvFC/0deUwZvYu3x/IAg9hHMsortyo3MZsXnMKV831OSBm8y6jxy9XzfXZ3/1ZPPzb+4Na4CUsvi6+Lr73B7XAh3x/UAs8hMU3xAt9XZ9FYmav+ZDR1/W5IWb2mk14Cte+1/0wZvaaQziF4VvXJHq/PtvCbF7zFP7WX/V5EH4KrzmEU3gLH3L1fvMorn2v3m+ewkvYhUM4hffj+r27P57F+LerOIRTeAsf8vgJo+YoNuEpvIRdOIRTeAvD99sjzOY1D2ETnsJL2N/e4Qf0mlN4k9Hv9dkoZvbueZtL2IVDGMfyXUuYzbvnag1hE8b65buWsAvX+vXZGWbz+t/KHi3ZIxdfF18XX5/CS1iuDZdrw8XXxev+PGadq/vzmOAl7MI4lrom789g1l7fn8EED+GquT4HxGxe8xKumuuzv3N/BhP/NoW3sPhu8d3iix/RujyFl7ALi+8WL/R1fRaJmb3mKYxjwf/ehUM4hWvf63NAzOwVH8zsNQ9h+O5irH+KQziFa/3v86CDn9G7jN6/PIRNeAov4fL9vnJ0ML/XnMJb+JDR+5eHsAljzVmMf7s+nj/hIWzCU3gJo+YoDuEU3sKHjN6/PIRNGL61R+j9yy4cwim8hQ/3Dr1/eQibMK43L06eN9/Chxw/YRxLXUsh5ypcOISxfvnGFj7k6v016zpJ2aOUPUrZoxTfFN8U30zhLSzXxpZrY4vvFi/+qPXBzF7zFj5kvKZPcOXG99nQ+fFHrc/v/qg1uGqe4BTewlXz99nfGfdHra14CJvwFF7CLhzCKbyFD3mI7xAv9PX3WeTBzF5zCuNYoviQ0deXh3Dt+/c54MHMXvMSdmH47mKs/11XmM1rHsK1/vd50MHP3DUvYRcO4RTewuVb1wDm95qHsAlP4SXswkFGX6+6BvDavercopcvu3AIp/AWRs11ztHjl4ewCU/hJezCIQzf2iP0/uVDRu9fHsImPLl36P3LLhzCuN6+fMPM3j1v24Sn8BLGsdS1tOVc4b4djB6/jPXLF6/vl6dwre91nRzZoyN7dGSPjvge+mJOr3kIm/AUXsIuTC/M7NWfkDiY2Ws24SmMYxnFlRuV25jNaz5k9Pj3OcLBbF6zCVfN3+cLB7N5/W9dOITF18TXxJd/0uLY/ZMWYBOewuI7xQt97XWu0NeXhzCOJYqn8BJ24dr377ODg5m95i18yOj97/OFg9m85bUX6P3LLlzrR9WP3r+8hQ8ZvX95CJtw+UbtO3r/sguHcApv4UNG71/GmnUN4LU76tyily8fMl67Lw9hE0bNdc7R45ddOIRTeAsfMnr/Mnxrj9D7l6fwEnbhEE7uHXr/8nmMub5mXG9e7O+8YWavOYW3MI7lu5Ywm4dzhdm85iWM9csXr++XU7jW/57nHMzm3X9rP+EhLL4mvia+eH2/HMIpvIXFd4oXXtO/zwsOZvbW98z/YGavOYW38CGj9y8PYeRknVv8oP3lJezCIZzCW/iQ69czrLa6fj3j4iLioOpg0fiXU3gLHzIa//IQNuEpvITFN8Q3xDfEN8Q3xTfFN8U3xTfFF3/zYoBDOIW3MHzrXOFN/QBP4SWM44riEE5hHFcWH/5bfFh/eQiL7xHfI754U3A5hFN4C9MXw37NOFe72IVDuI7l+2DlYKiv+ZDxZv9y7dH3QcnBUF/zFF7C5ft9aesshMP38P8shAMY4XAZ669iE57CS9iFQziF4VvnBOEAxpuCy0PYhKfwEnZhrPldAxjeW7vOLW4ALi9hFw7hFK6aT51z3ACAcQNweQib8BRewi5cvqf2CPlweQsfMvLh8hA27h3y4fISdmH0zvdigaG+e97Q+5dNeArjWOpaSjlXuDG4fMi4MTjlixuDyyaMc1XXyZY92rJHW/Zoi+8W3y2+uDG4PITl2jhybRzxPeJ1/7Tkd7x+/7QkeAibMI7Fiys3vgfRx++fkARvYezvl2MY3msewjhXWTz5b++fkAS7sPgO8R3iizcFYPxdjMtD2ITF18QLff19WHMwsHcZfX35W9O/D1YOBvaap/AS9uJRHMIpvIVPcZ3/hfWrtjWFlzDWX8UhnMJb+JCr95uHMHxr330KL2EXDuEU3sKHHFizroHAv61zGym8hQ85f8JDuGoedc6rx5uXsAuHcApv4UOu3vdRe1S932zCU3gJu3Bw73YKb+FDRr9/Hx4dDODd83ZcOIRTGMfyXUsYwMO5wgBe8xRGzbPYhUMY52oVb/m33CMM4DWL7xDfIb5jCbtwCKew+Jp4Gc6/F+NYotiFQziFt/Ahz5/wuH9N+QT+JjRwEhfRiUFM4n5Yf/25bodq7q5xEhcRx5LF+/4J9VOzdRfrzz9fxIVaJwdNfXkK40SdYuc/DWIS6eh0DDq+P/t+4v3Z9xPvz76feH/2/UTQLWiBBq9PdjBl12zCVb/VhY0Gv+zCIVwbXe96MGXXfMho8MvwrYscjVxviDBx1xzCWL82E418+ZDPT3gIm/AUhm9tNJr9cgin8BY+jzGJ1zyEseYprn9bT6UwTXcZjXx5CJvwFK6a65MFTNw1h3AKb+FDRlNfHsLwncVTeAm7cAin8H57h0m8y2j2y0MY+zKKg+cNL+KXt/AhLxzLKpZzhRfxyy6MmssXL+KXtzDO1XedYOLu/luXPXLZIxdfF18XX7yIX05huTZcro0Q3xCvwJp1jeHF/XIKb2Gs+WURpuyah7AJ/x1L1oPDGrJrdGIQk7iJ52H9TO5FnKPaM/T8ZRcO4TqehX+7hQ8ZPX/573i8Ho7VAF7jJC6iE4OYxN2ICTuvT3IwYdc8hZewC4cw6v76DFN1Xp9aYKrO64k+fgmv2YWxjhenMM5LFB8y+vsy6s9iE57CS9iFQziF4VvnB/0NRn9fHsImPIW/LUGZaHWcHrT6ZTltaPX6YAaDd80mPIWXcB1WfZCDgbzmFN7C5VsfcmAgr3kIl299kICBvOYlDN/aLkTA5RSGb10miID6sAEDeV4fJGAgz+uDBAzkNU9hrF/Hizi4vIUPGXFQ7YkhvHtJ4iX/sguH8CZ/L+dIzpq7a5zEb58rTmvorjGISdzE8/Dr9MZBNGLVWR9IYKiuOYW3cJ2H78fXDn4Ur3kIm3AdzShcRCcGMYmbeB6OH3EQv3XrXUCN2zXiYMApvIUPGb1fT9AxbddswlN4CbvwdzwDmMRNPA+/vm8cRCNO4iI6EUfjxYeMlr88hHE0UTyFl7ALf0dT72JqDK9xE8/Dr90bB9GIk4jdyeIU3sKHjJa+PIT/Vse70BrFa1xEJwYxiXUsv8LzMH/EQTTiJOJY6rhw516fEWHOrnkI1yrVHdXrFxfRiUFM4iaeh9XrFweRboduh26Hboduh26Hbqfd/h5Nocu/j8A+MVUsFa6iTtX30dQnUsVWcUTgZr/FUGEqpgpUgEJxR9AiVKQKVDAhjghEQ4uhwnpbPzFVLBWuIlSkiq3iiJg/FTjSBbFUuAocqUPgSANiqzgiEBstcKQJYSqmiqUCFaBQ3C9sbAluGFpsFUcE7hlaDBWmYqpYKlyFVvDlTH2S8fEWPuQvZ9bG8X8589iEv6DZOMmVNM0uHMIpvIUPOX/CQ9iExTfFF08RNq5ihM79vyB17qHhiWCLqWKpwGrYTrxR+J7Sf2KoMBVTxVLhKmo3DqIANxgttopDgeG/J4YKUzFVoIKAcBWhIlWgggFxRCB/zoRABQ5hKqaKpcJVhIpUsVUcEcifFlqB1cufgafwEq5XQJRvIZzC32V5j/cLnuYvdx4PYROewkvYhUM4hcV3ii/S5mBrkClnQ+D8HYhUsVUcEZUc8cPSlQ+B1zCMDD6RKraKI6JuRZ4YJRaEqZgqlgpXESpSxVaBCnB950/FUGEqUAGulFwqUAHOaIaKVLFVHBH7p2KoMBVVwcCJr5R5wlWEilSxVRwRlUxP1KWJM3VMeAovYRcOYTjU1mLEMMaEmCpqqQC7cAin8BY+5PETHsImjBO1IHCiHCJVbBVHhP1UDBWmAgcIU1sqXEWoQAUJsVUcEfOnYqgwFVMFKtgQqOBAhIpUsVUcEeunYshWLt3kpZu8lgpXESpSxVZxRGgEYaDxiaXCVZSP/SAkgkwjyG4EXVE+hgUQQS2WivKx+29CF0gVW4VWkFpBagU3gq6YKpYKV6EVpJoiWwwnEdnSYqrAweFSRra0CBWponwMlzKy5QpkS4uhAhXgGj3wwTV6QkWqgA8uPiQMBAYcnxgqTMVUsVRUBfMHESpSxVZxRNS9zRNDhanA0gaBBerEY97xiaHCVEwVSwUOwSFCRarYKo4IpEuLocJUoIKAWCpcRahIFVvF4QZjTvKJocJUYOcWRMoZRWy0OCL8pwIHlxB6EhEbLUIFfFAB7mlaHBEIlImrKnQbQ7cxdBtDKwitILQCBEqLrUIvpNQLKbWCVFM8a8G7k5mpYqs4InCzsnApb3mrMvdS4SrqENaASBVbRR3Cwv7om6Wpb5amvlma+mZp6pulqW+WMBD5RKrYKg4Ffg3xCVNR+7MmRKhIFTg4hzgikBQthoq6QlZATBVLhatABQkBHxSKQGkxVMDnQEwVS4WrCBWpYquoCryuEExLPjFUmIqpYqlwFSECSeEGgQVw4hEOLVxFqEgVWwUOAVuC2GgxVJiKqWKpcBWhAhVgGxEoLY4IBEqLocJUTNlgBEoLVxEqsHOVoxin7DOKW48WU8VSgYPDxZd6EvEe5wrERgv4oALch7SYKuCDq2rrNm7dxq3buLWCrRUcrQD3IS1MhV5IRy+koxUcMcWYZcQPopaOAWEqpoqlIkUgHMIghgqsBlNEQNTOYSAywiGGClOBCgJiqXAVIT5o9P6/bBVHBBq9xff+C7tY85OPp/AS1uPHvcE9ZNwbXLH0zKxa6zIOJSFwKFgZDd8iVWwVRwQavsVQgZN5IKaKpaIqwFN6zE0GHqVjcDLwjByTk4GH3zU6ue71VM9Nm4fwd8rw7hV/qjjyCnhgk3GP0GKrOCJwj9BiqDAVdZR4iI05yydcBSrADuC5R+KcIRPwEBvDlrFxZr5MWHjHXNOWj034z2Ti3XtNVT5O4XLAI1uMVbZAz+P5LYYsnzAVdYx4ZIv5yydcRR0j7oMwgvnEVnEo8POIT1QFeK6K+cwnpoqlwlWEilSxRSA08PSv5i7rd2o+xj8xiK3iiECa4GkmfgjxCRS9IKaKpQJFO0SoSBVbxRGBNGkxVKCCgJgqlgpXESpSxebJwZuNFqZiqlgqYLMhQkWq2Cr+DrR+eOqPv6h5PIRNeAovYRcOYZxICNw6tBgqTMVU8R1h/rDjlTNPhIpUsVUcEZUz+cP5qpx5wlRMFagA5ytdRahABag6t4ojou49Ek83MfWZeCqJH1pMJCr+sPITS4WrCBUp4sAHh3CGClMxVSwVToHRzcQDK/xC4hNliodPmN5MPLnB+OYTpmKqWCpchOH/siBcRahIFVvFETF/KoYKUzFVaAVTK5hawdQKplYwtYIFH4fAagGB1TZEqtgqsFpdSJjCfGKoMBVTxVJRPngOhNnKnNjGas2cqLpa84mpolbD23cMYT4RKlLFVnFEoDXxTAejmE+gApwqtGaLpQI+uGDRZngGgp9AfAKrGQRWwwlBm7VwFaGifPDQAXOYTxwRaEA8TcCPIT5hKrSCoxUcreBoBSdVbNnTI1cIfhXxiaHCVEwVwYsCA5r3osDvId6txw8iPmEqJvcU05tPuIpQkSq2isPrADOcTwxuPaY4n5gqghcFBjPvdYDJzCcGLwrMZt7Ti+HMJ5YKVxHcekxuPrFVHG49hjefGCq0gqUVLK1gaQVLrhD8KGHi0c9Ga7YIFSgUZxSt2eKIQGu2GCpMxVSxVLgKVIBC0bQttoojAu3cYqioCvCeBL9r+MRS4SqqAscFi3ZusVVUBXg6gp83fGKoQAW43tDOLZYKV4EKcFmiafHuE5OXTwwVpqJ88C4ff6o48Y4Vv4eYeF+KH0R8IlVsFVUB3mPjRxGfGCpMBSpwCJgmBExRKHobbz8xoZl5Fzgi0NsthgpTMVUsFVUB3oLidxGfQAUoB/cHLY4I5EGLocJUVAV4S4ffUHzCVYSKqmCjUORBiyMCeYC3gRjtfMJUoIKAQAWoDXnQIlSkiq3iiMA9Bd434ccWnzAVU8VS4SpCRarYKo6I0ApCKwitAJGG9034FcYnUgSiBm+P8AOKT6ACHDai5gpETYuhwlRMFTgHB+KrbWNSA7+k+ESq2CqOiIqaJ4YKUzFVLBVawdEKjlZwtILDCgZ+e/EJ+AwIrGYQ3NOBMc8njggESr1pHxjzfMJUTBVLhatABVekChzPNT0i7KcCx+MQWC0gUgWOB0eKpKgNHhjZfGKoMBXwSYilwlXEu5AGhjmf2Cq0gqUVLK1gaQVIiisc184VU8VSgRzF2UEHt0gVW8URgQ5uUVfvwIVUHfzEVLFUuIpQkSLqpmQPXJY5VJiKqWKpcBWhIlVsFUfE1gq2VrC1gq0VbK1gawVbK9hawdYKtlZwtIKjFRyt4GgFRys4WsHRCo5WcLSCIxVgiPOJocJUTBVLhasIFaliq9AKhlYwtIKhFQytYGgFQysYWsHQCoZWMLQC0wpMKzCtwLQC0wpMKzCtwLQC0wpMK5hawdQKplYwtYKpFUytYGoFUyuYWsHUCpZWsLSCpRUsrWBpBUsrWFrB0gqWVrC0AtcKXCtwrcC1AtcKXCtwrcC1AtcKXCsIrSC0gtAKQisIrSC0gtAKQisIrSC0As3EoZk4NBOHZuLQTByaiUMzcWgmDs3EoZk4NBOHZuLQTByaieNm4oRwFaFiM/3HjUGIG4NXDBWmYqpYKlxFqEgVWsGRCuz3UzFUmIqpYqlwFaEiVWwVWsHQCoZWMLSCoRUMrWBoBUMrGFrB0AqGVmBagWkFphWYVmBagWkFphWYVmBagWkFUyuYWsHUCqZWMLWCqRVMrWBqBVMrmFrB0gqWVrC0gqUVLK1gaQVLK1hawdIKllbgWoFrBa4VuFbgWoFrBa4VuFbgWoFrBaEV6A2g6Q2g6Q2g6Q2g6Q2g6Q2g6Q2ghVYQWkFqBakVpFaQWkFqBakVpFaQWkFqBakVbK1gawVbK9hawdYKtlawtYKtFWgmmmaiaSaaZqJpJppmot1MDAhXESpQwYbYKg7FvJmYEEOFqZgqlgpXURXU50wDM7BPbBVHBDKxxVBhKqaKpcJVaAVDKxhaATKxPh0bGKJ9YqgwFVPFUoEKJkSoSBWoYEEcEcjEFkMFfBxCV0O+tTgikG+GLUG+tTAVOB5cB8i3Fq4iVKCCA7FVHBHItxblM3GqkFUTu4CsarFV4BrFAjerrhgqTMVUsVS4ClSA04usarFVHBHIqhZDhamYKpYKV6EVpFaQWkFqBVsr2FrB1gq2VrC1AmTVxBWCrGqRKraKIwJZ1WKoMBVTxVKhFRytAFk1cZEjq+qToYHx2iswXvvEUGEqpoqlwlWEilSxVaCCunYwhfvEUIEKEmKqWCqqgvoAaWAK94lUURWsu/QRgaxqMVSYiqliqXAVoSJVaAXIqhqiHZjPfWKoMBVTxVLhKkJFqtgqtIKlFSytAPlWI34DA75PLBWoAFuCfGuRKraKIwL51mKoMBVTxVKhFbhW4FoBMtFxUSATr0AmtqgKarBzYMD3iamiKqgPgwYGfJ8IFVVB4owiE1scEcjERAXIxBamYqpYKlxFqEgVW8URsbWCrRVsrQCZWJ8MDUwIP+EqUAGueGRii62iKtgIB2Rii6GiKtjYRmRii6WiKjgoFJnYIlVUBXjIjJ9rvQKDxE98FRw8aMcg8RNTxSqxIFxFqPgqOHj7j99zfeKIqEw8NR41MHz8hKmoCvAajF91fcJVVAW4r8IPuz6xVVQFuCnBKPMTQ0VVgPsQjDI/sVRUBXj9wSjzE6liqzgiKhOfGCpMxVSxVGgFUyuYWkFl4lk4o5WJLSoTn6gKFna7MvGJqaIqQHRiBvqJUFEVIGowA/3EEVGZeBzXTmXiE6ZiqlgqXEWoSBVbxRERWkFoBaEVhFYQWkFoBaEVhFYQWkFoBakVpFaQWkFqBakVpFaQWkFqBakVpFawtYKNCnCRb1MxVVQFgd2uTHwiVKSKreKIqEx8YqgwFVOFVnC0gqMVHFQQEFvFocAE9ak5h4EJ6idMBSo4EEuFq6gK8i6dKraKqiCxNDKxxVBRFdQswcCP3T6xVFQFNUsw8Hu3T6SIezc4IHDP94NYKlxFqEgVW8URgXu+FnU8NeE+MFz9xFSxVLiKUJEqtoo6ozX0MPAH6Z8YKlABdgH51mKpwL2/QYSKVIEKsPVIsYPDRoq1mCqWClcRKlLFVnFEIMVaaAWhFYRWEFpBaAWhFYRWEFpBaAWpFaRWkFpBagWpFaRWkFpBagWpFaRWsLWCrRVsrWBrBVsr2FrB1gq2VrC1gq0VHK3gaAVHKzhawdEKjlZwtIKjFRyt4EgF+IHeJ4YKUzFVLBWuIlSkiq1CKxhawdAKhlYwtIKhFQytYGgFQysYWsHQCkwrMK3AtALTCkwrMK3AtALTCkwrMK1gagVTK5hawdQKplYwtYKpFUytYGoFUytYWsHSCpZWsLSCpRUsrWBpBUsrWFrB0gpcK9BMTM3E1ExMzcTUTEzNxNRMTM3EvJlYL215M/GKocJUTBVLhasIFakCFSyII+Jm4hWowCBMxVSxVLiKUJEqtooj4mbiFVrB1gq2VnAzMSBcRaj4q8B+eHdYw/IUR8SXiRRDhamYKpYKVxEqtIKjFRypoIbl/8SCmDyEffPNIVIFVtsQR8T4qRgqTMVUUceD97Q1LE8RKlJFVYAPyGtY/gn7qagKBg7OTMVUgQpwcOYqQkWqQAU4VYYKcDwTPgdiqlgqXEX54JOUGqP/EzjSWT746KLG6P8EKlg/FUOFqagKDIWupcJVhApUgONZMEWhXqb45KF+AflPoFAvU7yrrt9AplgqXEWoSBVbRVWAp8f1U8gUJhds6NUbS4WrCBWpYqs4Im5WXTFUaAWpFaRWkFpBagWJw8a5zq3iiNg4bOzCHipMxVSxVLiKUJEqtooj4mgFRytAVuFJyUZWtVgqXEWoSBVVwcLZQVZBHGRVi6ECFSTEVLFUoIIDURXgiUx9R4CiKsBDmIN8uwL5hmfeB/nWwlRMFUuFqwgVqWKrOCJMKzCtwLQC0wpMKzCtwLQC0wpMKzCtYGoFUyuYWsHUCqZWMLWCqRVMrWBqBVMrWFrB0gqWVrC0gqUVLK1gaQVLK1hawdIKXCtwrcC1AtcKXCtwrQAxWF/SGQcx2GKrOCJC7hzqCwMUpmKqWCpcRahIFXLnUD8c/VfBgsBqV+B4HCJUpIqt4ohAvrUYKnDe0Ohb92fr2dl6dpBVLYYK7A/yAFnVYqlwFXqFHK3g6BVyeIXY7/dTMVSYivlqsx+yqoWrCBX5arPfzaorjoihFQytYGgFklX2k6yyn2SV/SSr7DdSyhlbxRFhPxVDajNTMVVoBaYVmFYgWWU/ySr7me7C1HMwh5Rzs+oK3YWpuzBdartZdYXuwtQKplawtIKlu7B0F5buwtJzsPQcLL0Olu7C0l1Yuguuu3CzakOYClRwIJYKVxEqqoJAbciqFkcEsqrFUGEqpoqloioIHAKyqgXu37AL+XtJYT9kVX1Oa/XVCIqpYqnQ3U7d7dTdTu251J67KXaFXvFbd3vrbm/d7a27vfWK33rFb73etl5vR6835Ft9CG0/5FsLV4EzivOGfAtUjXxrcSgG8q3FUGEqpoqlwlXwGbHhaw4t8MSsxVBhKqaKpcJVhIpUoRUMrcC0AtMKTCswrcC0AtMKTCswrcC0AtMKplYwtYKpFUytYGoFUyuYWsHUCqZWMLWCpRUsrWBpBUsrWFrB0gqWVrC0gqUVLK3AtQLXClwrcK3AtQLXClwrcK3AtQLXCkIrCK0gtILQCkIrCK0gtILQCkIrCK0gtYLUClIrSK0gtYLUClIrSK0gtYLUCrZWsLWCrRVsrWBrBVsr2FrB1gq2VrC1gqMVHK3gaAVHKzhawdEKjlZwtIKjFRypAN95eGKoMBVTxVLhKkJFqtgqtALNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTDTNRNNMNM1E00w0zUTTTJyaiVMzcWomTs3EqZk4NROnZuLUTJyaiVMzceLdbv34hk28221hKqaKpcJVhIpUsVUcEaYVmFZgWoFpBaYVmFZgWoFpBaYVmFYwObti9zsPLUzFVLFUuIqqoEZTbeLdboutoipI/Bu8220xVNQ5qB/dtIl3uy2WClcRKlLFVnFE4N1ui6FCK3CtwLUC1wpcK3CtwLUC1wpCKwitILQCvNutX3GxiXe79eMBNvFut0WoSBVbxRGB98EthgpTMVVoBcmJdrvfrWiRKjhPbve7FVfsnwpcibhGMUfcYqpYKlxFqEgVW8URgTniFlrB0QrwPrgGzmzi3W7e/wvOaB3pwrvdFkOFqajV6o9z2cKTufopHFt4MncFsqrFUGEqporanxpSs4WsahEqUsVWcUQgq1oMFajgBzFVLBWuAhU4RKrA/kyII+Jm1RVDhalABbU/C+lSc962kC4tTAW/pWD6LQXrbylcESpSxVZxRNxvKVwxVJgKrcC1AtcKXCtwrcC1AtcKQisIrSC0gtAKQisIrSC0gtAKQisIrSC1gtQKkC54QV5IlxZLhasIFamirt5zlz4i8JTt4ILFU7YWpmKqWCpcRahIFVvFEXG0Any+cHDF4/OFFvy2it1vKbRwFaECPnXFO9IFjzfxjQN8V8TwjYMnXAW/92H4xsETW0XtaU3kGr5x8MRQYSqmiqXCVYSKVLFVaAWmFSB36isYVt8e+J43QmQJHELdCT1xRNRz/ydmiQmB1RZEqtgqjoj1UzFUWAls1poqlgpXESpSxVZxRDgqMIihwlRMFagA1467ClSAc+2pYqs4IuKnYqgwFVPFUuEqtALkDjIe3wR44ohA7iDj8U2AJ0wFvhnkEEuFqwgVqWKrOCJwV9NiqDAVWsHWCipdxsClXBkyBjarMmQMXKOVIU9MFUsFVqula0L/e74NMVSYiqliqXAVtT810GQ1oU+xVRwR46diqDAVUwUqWBCuIlSkClRwII4IZEgNHlogNuyKVLFV1AI1bGWB2GhRG4wQwlD+E1PFUgGf2p9AbBiqXvwimd0B+xZTBb9IZhiwPy1CRb0pRqPfAfsWRwQeELUYKkzFVLFUuIpQoRW4VoBwMFyWiID6erwFIsBwqhABLVLFFlFvX0YNnFmNxH+fgEC4ilCRKraKI6JuI8bEid9DhamYKpYKVxEqUgWOB9foPiIQAS2GClSA3UYEtEAF6NPjKkJFqtgqDkUiNloMFaZiqlgq8FXDAREqUgW+7GgQR4R82dHuSDwC8o7Et5gqlgpXESpSxVZxROBhdgutwLQCw7lOCJzRA1FndOF/hgxpMVSYilpt4bBx64G3PIlbjyuQIS2GClMxVdT+1K8OW+LWo0WoSBVbxRGBW48WQwUqwAbj1qPFUuEqUAGuHdx6tEAF1fWJ2wg8P0hkSAtXESpSxVZxRNTDkSeGClOhFSS/XGt37LxFqOCXa+2Onbc4IvDAGK+Ad+y8hamYKpYKVxEqUsVWcUQcreBoBUgXx2YhQzA5ghHyUbNfhhHyKzBC/sRQgdUCAqslxFZxROA2osVQYSqwPwdiqXAVoSJVbBVHhP1UoAKHMBVTxVJRFdQ3LA0j5E9UBZhqwQj5E0cEMqRFVYAJFQyXPzFVLBWuIlSkiq3iiEDutNAK7pefUdv98vMVS0Vdo0gk/Eb7E6kCX78eEEcE7l1aDBWmYqpYKlxFqEgVWoFrBXhjgxmZjdzBuMpG7uCp+0butNgqjgikC96jb9y74J34xr1Li1SxVRwRuHdpUfuDR8kYB39iqlgqXEWoSBVbBY4HjYF7lxZDhalABbh2kC4t4FPhgAHugUevGOB+YqlwFaEiVWwVRwTSpcVQoRXgbsOuWCpcRV1VuGU796cVrtgqkP517Zz70wpXDBWmYqpYKlxFqEgVW4VWMLUCZAieX2MYe+D5NYaxBx4/Yxj7iSMCSdGiVsOjZAxWD7z1xWD1E1vFEYG7jRZDRe0P3uRjsPqJpcJVhIpUsVUcEXjQUV8aNwxWP2EqpgpUgIsCSdGiKqgv4BkGq5/YKo4I3KHgWSdGrp8wFVPFUuEqQkWq2CqOiK0V3J88QG33Jw+umCrqGsWdA34L/olQgezF9YY7lBZHBO5QWgwVpmKqWCpcRajQCg4rmBjTHvV76xPD2KMe5E4MY496KDsxjP1EqtgikC71YGBisHoc+OAOpUWoSBVbxRFRdyhWjzcnBqufMBVTxVLhKkJFqkAFCXFE4A6lxVCBCgxiqoDPgkgVW8URsX4qhgr4YH/WVIEjxS4sV4EKUOhKFagAm7WOCEcFOPE+VFQF9e5wYnz6iapg4CRWIj1RFQyckEqkJ6qCgYuvEqlFJZINHHYl0hOoAIcdUwUqwGGHq0AFOOxIFagAhx1HRKICHHYOFVWB4bArkZ6oCgyHXYn0RHXjRKF4z9Riqzgi8J6pxVCBCnAS91SxVKCC+29CRarYKo6Iut95YqgwFVPFUqEVHK3gwKf2B+PTVq/OE+PTVncbE+PTT7iKUJEq5HhqsPqJ8VMxVJiKqWKpcBWhIlVoBUMrQFbdw0Yi3cM2PR7T47Gt4oiYPxV6PFOPZ+rxTD2eqccz9XimHs/U45l6PEvP6NIKllaARLqHjdy5h730eFyPB7nTwlToFeJ6PK7H43o8rsfjejyuxxN6PKHHE3o8oWc0tILQCpAu97CRIfewU48n9XhSr/jUKz71Ckm9QhI+B+KIkB9ymnd4uYWpmCrKpx4/z4E8qKfH8w4iO5bGHUoLU1GrBRaQH2WaQ36Uad5BZMch4A6lxVZxKO4gcouhwlRMFUuFqwgVUoEhKepr3tOQB/UsehryAEFsyIMWoSJF4N6lHqNOwx3KhA/uUFq4ilCRKraK2p96wDoNedBiqDAVU8VS4SpCBSoIiK3iiEAetEAFA8JUoIIJsVS4ilCRKraKIwIZ0mKoMBVaAZ6hBKrGM5QWoaKukMA24hlKiyMCA8KBrceAcAtTMVUsFa4iVKSKreKISK0gtQKky8KljAxZODhkyMIhIEOu2D8VQwVWOxC1muNywT1FiyMC9xQthgpTUfvjaEDcU7RwFaEiVWwVh6IGdylwPBvCVEwVSwUqmBChAhUkxFaBCrAA0gVpiR8rx8/ETfxY+RNTxVLhKkJFqtgqjgg8kWmhFZhWgKyqvzY4Mbj7hKsIFaliqzgikFUthgpTgQqwWciqFq4iVKSKLQLpgnbGqO0TqWKrOCKQLi1QNTYY6dIC/wa7jXuKFkNF/Zt6PjoxHPvEUlG7nTBFHrRIFbXbiQqQB1cgD1rUbtfU68QPjz8xVSwVriJUpIqt4ojAfUgLrWBrBXjHkth6ZEiis5Ah9Rh1TmRIi6HCVGA1nB3kwT0HyAMIDLo+MVSYiqkC+3MgXEWoSBVbxRGBPGgxVKACh5gqlgpXURXUnOrEcOwTVUE9wJsYjrWNf4M7lBZDhamYKpYKVxEqUsVWoRXcLzehtvvlpitMBb5OsSCWCleBr1MYRKrYKo6I++WmK4YKUzFVLBWuQitYWgEypCa85sJ9SD05nQvvZTa2Hu9lWoSKFIF0qQGguZAhBz7IkBauIlSkiq2i9ufgjOJ5SIuhwlRMFUuFqwgVqADXKO5DWhwRuA9pgQpw7eB5SAuM9OKEYFi+xRGBYfkWWA29jQxpMVUsFa4iVKSKreJQOHKnxVBhKqaKpcJVhIpUsVVoBUMrGFoBcgdPdR25g+ewjtxp4SpCRarYKo4I5E6LocJUaAX4Udr6aHbiR7efCBUYwnWIreKIwFB+/bTCxI9uP2EqpoqlwlWEilSxVRwRSytYWkG9M5o1BjwxNjvxXBljs/N3/2dHRKXLE0MFVsNhO1bDBvtWcUTET8VQYSpmiQ2xVLiKUJEqtoojIn8qUAE2OE3FVLFUoAJcOxkqqgI8pa4RWIojonLniaHCVEwVS4WrCBVawf0DAThSZNUVyKoWdYXg/gA/hv3EVIFhebQzRu9bhIpUsVUcCvwY9hNDhamYKpYKV4FzXZcyxmYnnu5jbHbigT7GZp9YKlwFVsPShtU2hKmYKpYKVxEqan/wdB8ztE8cEfVe5omhwlRMFUsFKgiIUJEqtgpUUNcO5m6fQAU4vciQFq6ifAwnHunSAkeK04t0uQLp0gI+KMdNxVSxVLiKUJEqtoojAonUQisIrSC0gtAKQisIrSC0gtAKQitIrSC1gtQKUitIrQCJhCfBmOJ9IlVsFUcEEqkFvjuGPb1Rc/8voSJVaMtsLI0r/mjLHG2Zoy1zcAgHIlSkivLBo2QM4d4FMIT7xFBhKqaKpcJVhIpUsVVoBUNNkS54zJ1IlxahopauGeeZyJ0WR0Td1TxRPnh6nEikFlPFUoEKHAI+AXFEIHdawCchTMVUsVS4ilCRKlABThVy5wrkTouhwlRMFUuFq6il8cQZo7YTD4wxavvEUuEqQkWqqEPA895EoFyBQGkxVJiKqWKpcBWoANuIQGmxVRwRCJQWQ4XJBiNQWiwVrgI7V3mQSIp7RnHv0sJUTBU4OFx8W08iYqPFEXHggwrOUGEq4IOr6ug2Ht3Go9t4tIKjFRypABO5TwwVpmKqWCpCBW5B6xxgPPeJocJUYOkNgRvNgEgVWwUOodISQ7hPDBXlg0fjGMLtBRAbLVyFVmBagWkFJrf7GMJ9YqgwFVrBVFMkBd5VY7q2BZKiRS2Nh+b46eYnpoqlonzwGSV+uvmJVLFVoALsDwLFUSgCpcVSAZ+ECBWpYqs4IhAoLYYKVIArBIHSYqlwFaEiVWwVRwSSAh+zYtR24nE6Rm2f2CqOCMRGi6GiDgHvTzFq+8RS4SpCRarYKo4IBAreymPU9glTMVUsFa4iZIMRKC22ikOBH1ue+JgIE7n3jGIi94lQkSpwcHXxYe72nkTM3T4xVcAHFeA+pEWogE9CbF1AthE/nPyEVmBagWkFCJQWriJUpAqtYKopPr45VywVriJUYOm6lDFqex9I4nePnzAVOIQDsVS4ijoEfKyC8dy3wFZxRLhW4FqBawU+VSwVriJUaAWupkgKfBCCudsnloo6OHxEgrnbJ1LFVlFXCD4iwdztE0OFqUAFuJQRKPhYBdO1T2wV8ME1ikBpMVSYiqliqXAVqABXCAKlxVZxRCBQWgwVpmKqqKXrw5OFXzeeNSi+MDb7hKmYKpYKV1GHUB9qLAzUPrFVHBG4D2kxVJiKqQIVLAhXESpSxVZxRCBQaoMXhnCfMBVTBXbOILacUdx6XIHYaDFU4OAcQk8i3rG0SBXwQQW4D7kC9yEt4JMQuo1Lt3HpNi6tYGkFSyvAfUiLI8L1QnK9kFwrcDVFUtwzivG1FkcEPgxqgaU3BD4uxJHiw6AWoQKHcCC2iiMCsXGwPzlkgTQVU4VWkFpBagX4MKjFVnFE7J8KrWCrKZLi4CQiKVpsFXVwBy2DpGgxVJiKukIOGgO3Hi1cRahABXUp4+eEZ33GsvBzwk+YCvgkxFLhKkJFqtgqjggESo3rL8zDPmEqpoqlwlWEihRRSbHqc4xVvxP8/aAUhKsIFaliqzgiKjZWfcKxMAL7hKmYKpYKVxEqUgUqWBBHxPqpGCpMxVSxZIMRKC1CRarAzlWOYh62z6hPFUuFq8DB4eJzPYnxUzFUwAcVxFSxVMAHV1XoNoZuY+g2hlaQWkFqBWkqpgq9kFIvpNQKUk3v+NqBMBVTxVKBpXEpy2DbGjLYtoYMtq0ajv1+AQ3CVEwVdQjj/hvXBUJFqtAKjlRgv5+KocJUTBVLhasQU8zDrvqgatXP71KYijq4+g7HwqTsE64iVNQVUp//rPr5XYojwn4qUIFDwCcgXEWogE9CbBVHBAKlxVBhKqYKVLAhXEWoSBVbxRGBQGkxVNTShi2pG4xlOPEVDi3qBuOJocJUTBV1CIYtQWy0CBWpYqs4IhAoLYYKVIBtRKC0WCpcRahIFVs2GIFyBQKlxVCBnTOIkDOaqWKrOCI2Dg4X39aTuJcKVwEfVLBTxVYBH1xVR7fx6DYe3cajFRyt4GgFJ1SkCr2QjlxImJR9wlRgVD0hQkWq2CqwdF3K+IVaDLGvOaaKpQKHcCBCRaqoQ6jPmRZ+obYXuKP3VwwVWoFpBaYVyFD+mjKUv6YM5a8pQ/nrDrpeMdUUSTFxEpEULUJFHVx9gLQwwfrEEYGkaFFXSH2AtPDTs09MFUsFKnAI+ATEEYFAaQEf7CkCpcVUsVS4ilCRKlABThUC5QoESouhwlRMFUuFq6ilFy4X3GAsnHiEQ4ulwlWEilRRh7CwJYiNKxAbLYYKUzFVLBWuAhVgGxEoLbaKIwKB0mKoMNlgBEqLpcJVYOcqRzFDe88oZmifMBVTBQ7OIeQkYlL2iSMC9yH1adLCpOwTpgI+CbF0AVcRKrSCoRUMrQD3IS2GClMxVWgFpqa49ajPjNbCrQfuOhduPVqYiqliqXAVoQJZBdP79Z0rjoj79Z0rhgpTMVUsFfhaGnYBgYI7yIVAuQKB0mKoqCN1rIZAabFUuIpQkSq2CnwxDhfF/aLfFUOFqZgqlgpXESpSBMZm7wlJPVLkToupYqnQI0090tQjTT1S5M4VyJ0WQ4Ue6dYj3XqkW49065FuPdK9Vei5Pnqu75eFcUKOHinSpUWoSBV6pEeOFAO1TwwVpmKqWCrkSO9AbYtUsVXIkd6B2hZDhamYKoInBGOz90gxNvuE9A/GZp/QIzU9UtMjNT1ScxWhIlXokZoe6dQjnXqkU4906pHOpULP9dRzjZ9awaOj+zu0LYYKU4EjNQj+vMS6vzbbYqvAGa3XU7+JdMVQgTO6IKYsgB9haeEqtALXClwrwI+wXIEfYWkxVJgKrSDUFG+G6sPuhRnaFngz1AIHh3N9Q+iKqWKpwOWCc31D6IpUsVWgAtSGW5zABYtbnBZLRfkELj7c4rRIFVvFEYFbnBZDBSrAFYJbnBZLhasIFaliqzgU+LXZVZ87L/ym7KqPgBd+U/aJreKIwC1Oi6ECh5AQU8VS4SpCRarYKo4IpEt9ALswUPuEqZgqlgpXEdxgDNQ+sVUcEbj5qQ/iFyZl+4ziFqdFqEgVWLouPszD9knEO6MWU0X5JCrAO6MWoaJ86gPYhUnZt4Buo+s2ulbgWoFrBbjFaeEq9EJyvZBcKwg1vT/XhBNyf67pClcRKnBwuJTxo0z44O3+KG0LU1GHUJ8uLwy6PuEqcBLhgx9l6gW2iiNiawVbK9haAX7yrcVS4SpChVaw1RRJkVdMFUsFDg4tg6RokSq2irpC6tPlhRHYJ4YKU4EKDkT54INRDLo+sVWUDz47TARKi6HCVEwVS4WrQAUGkSq2iiMCgdJiqDAVUwWWrssFg64L+4NB1ydMxVSxVLgKHEJCpIqt4ojAo5YWQ4WpmCpQAbYRgdIiVKSKreKIQKDcDUagtDAVUwWu0YDYckbxdOUKxEaLoQJL4+ILPYl4KNsiVZQPPhzGoGsL3Ie0KB98AItB114gdRtTtzG1gtQKUivAfUiLI2LrhbT1QtpawVbT++OQqPr+OOQVRwR+HLIFDg6X8v0JSBwpfr66RaioQ8Cnyxh0feJQYNB14QPl+9OzWGDfH5S8YqpYKlxFqEgVW8URcX9Q8gqtYKgpkgIfdmME9omtAgdXLYMR2CeGClNRVwju/TEC+4SrCBWooC5lDLo6PhjFoOsTpmKWwPFUoDzhKkJFqtgqjoiFCgxiqDAVU8VS4SpCRYpwLI3LxbEATry7ilCRKraKIyJwCNiSGCpMxVSxVLiKUJEqUAG2MY6I/KkYKkzFVLFkg9NVhIpUgWu0chQjsH1G91SxVLgKLI2Lb+tJPD8VQ0X54MNhDLo+sVSUDz6AxaDrW0C38eg2Hqng/H4qhgpTMVUsFa4iVIjp/+/t33al6ZnrTPRedOyD5DYYfSuNhqF2qxcECLIh2wtYaPjeVxZHkRyz5l9RUZmcrYNffL75VmRwN5JJBsnn0bMY1D+Pnh2QGDIDMhcBXZHwSarP46sBz+Orn9CzgNVlBLpOSAwoxAwobKAyCAN7ENmDxB7gcMgBkSExZAb2IPFDoRRY7EYI7ITIgMw9f5MZCkNl6C0Eq8sIgZ2gBOVggAcK6M/BwigCXSdUhv4crB3iHNoJSgBBGRAYIkNigAdoIRCUAZVBGBqDEkBQBgQGmEZzERhAwYsStIMhMESGxIAsoEogGwMqgzA0BiWAoAwIDPAA1QhBGZAZCkNlEIZGFQxB6VAQKTshMKCNVkCdJVoQAjuhMShBgGkFrEIsCHSdUBj6cxI86OOQCY2hP6evYxQEug4DMTBEBvYgsgeRPYiVQRgagxIk9iDxQ+kajYIQ2AnC0BiQOQBdo1EOukajHM9rNJ7Qs5CeUBmEAYWI+nleo4G/PK/ReEJgYA8Ke1DYg+c1Gk+oDMLQGNiDyg+FUiQUIpRiQGVA5gTQGJQASjGgt5C+ulwQAjshMWQGeICmDEHJaIkQlCdAUAb052S0UQjKgMSQGQpDZRAGeIAWAkF5AgRlQGCIDIkhMxQGmO7NBYGupS8BFwS6TsgMhaEyCAOyIAAlgGwMCAyRITFkhsIADxpAGBqDEkBQBgSGuCo4QFAGZIbCgDbadRQhsKNE8S0zIDIkBphWABcivlgGKAHGIQUeYBwyIDL05/QFpIJA12mAqzFzNWb2ILMHmT3AOGRAYOCGVLghFfag8EOhFFB/hMBOCAyRAZmLgK5IeGMg0HVCY+hZ6KtJBYGuEwIDChH1g4PunwboCrAS6AqwEoQ9EPZA2AO6AqyE5xVgTwgMkYE9aPxQKEVBIUIpngClGIDMoctAKQYkhszQW0hBx8DQY4AwNAZ40JsyAl1LX0UoCHSdkBn6c/rKUIkQlAHC0BiUAIIyIDDAgwhIDJmhMFQGYWgMSgCl6MsdBYGupc/7FwS6TmgMSgDZGBAYkAUBJIbMUBgqgzA0BiWAoPRlooJA1wmRITFkhsJQqYIhKAMagxJAQ/q3ZkEI7ChRfMsMqAzCANNofJULEV8sAxJDf47AA4xDBlSG/hxBq6pcjZWrUbgahT0Q9kDYA4xDBhQGbkjCDUnYg8YPxdBD0Cwx9OhLPgUhsBMqgzA0BiWAoAzoWoUPAYTATkgMmaEwVAZhaAsSjjfqE9Ml4XijAYkBOS2AwlAZhKExKAEEZUBgiAyJgT0I7EFgDwJ7ENiDwB5E9iCyB5E9iOwBrgALTygMlUEY4EHvcwiOxQ2sBQe/TkgMyKkACkNlQE4boLEBJUBMyQD2ILMHmT3Al9GAwlAZhIE9KPxQjFD6ml5BpOyEwtAz19DeoDsDGoMSYA6lL6IVRMpOiAyJoXvQd4yWBN1p6AvQnQFKAN1pqFPozoDIkBgyQ2GoDPAARQXdGaAEEKEBgSEyJIbMANNoLhiuNBQ8hisDEkNmKAyVoWfhqRQYrgzQBQibnRAYIkNiyAzdg77OVHD07ARhaAxKAN0ZEFYFI6B2QmLIDMj2AdBVooiUnRAYIgMylwBUiDg5dkJjQBbgAQYyAwIDCrEAqBoRNjuhMLAHiT1I7AEGMk/AQGZAYIgM7EHmhz5vQUcZPG9BBzxvQX9CYEDmKqAr0oFsP+86f4IwoB0IQAkgGwNQiKif513nMPC86/wJmYE9qOxBZQ/wZTRACRBtMiAwsAfCD4VSKAoRSjFACbpS1ANdpivFhMiQGHIHdIw+kJlQGYShdUD9KJ4DRzUyJAY8B21UC0NlEIbGoAsQAjsBHlRAZEgMmaEwVAZhaAQBphsABhRQGYShMShBPBh6FvriVkFs64TEkBkKQ2UQhsbQPejrTAWxrRMCQ2RIDJmhrApGbOsEYWgEGdk+AIlKNGeGwlAZkLne+BDOOgqxBIbIgCzAg5IZCgMKEa2qcDUWrsbC1VjZg8oeVPagJobMwA2pckOq7EHlhwrqB81SkDkBZIbCUBmEoTEoQReUQ58QGCJDYsgMhaEyCEH//jkwskM464TIkBiQUzSKLhsHhnkIWp2gCypko6/plQrZGBAZeoliLacf77oMFIbKIAyNgT0IB0NgiAyJgT0I/FAISl8hLAhnnRAYeub6ztSCcNYJmaEw9OaCT0WEs05oDEoAQcHyDU6BrT3evyC2dUJhwHMEIAyNQQmgIQMCQ2SABw2QGQpDZRCGxqAE0J0B3TRmThG0WjGFiKDVCUoA2RgQGCJDzwJWoBDbOqEwVAZhaAxKIAcDPEA1Ql0GJIbMUBgqg1AFQ10GKAGGKwNQc2jXGIc8SxTjkAHC0BiQOTQ+5ULEOGRAZsBz4AHGIQOEAc9Bq1KqRsS2TggMkSExZIbCUBmEoTGwB4Ef2i/PaSiQHs66AKYbQBgagxJAUAYEhsjQM4cVGxzvOqEwdA+wCoeo1wmNAR50IUY87ITA0OerntnGofUDMkNhqAzC0BiUAIfWDwgM/TkQux71ugA5jQBhaAxKAEEZEBgiA8o6AzJDYYAHcAeKNKAxwIMuAQiOnRAYelnHJySGzFAYKoMwNAYl6Nf3TAgMyGkFFIbKgJwKoDEoAXQHy5IIjp2AskYTw2fSgMzQPcA6oECeBghDY1CCPt6ZEBi6B1hVxDGyEzJDYagMwtDLGp8vDfO9+OxrmO/tgYelYb53QGYoDJVBGBrDo04FX9U9hnZBYIgM8CACMkNhqAzC0BiUoF8BNiEwoESfUBgqA0o0ARqDEkCrsK6JUNsJqNMCSAyZAR6gsjAsGiAMjUEJMCwaEBjgAeoHw6IBmaEwVAZheJS1QP173O0JB6DXaX5CYsgMhaEyCENj6K0KL4kekbsgMESG7kF6QmYoDJVBGBqDEnStmhAYuFUJtyrhViXcqoRblXCratyqGreqxq2qcatq3Koat6rGrapxq2rcqhq3KuVWpdyqlFuVcqtSblXKrUq5VSm3KqVW1cNzR6vq4bmjHfTw3AWZoTBUBmFoDNSqNBwMgSEyUKvqUbwLCkNlEIbGQK2qx/cuCAwoUZTOU6ueUBmEAXWqACV4atUTAkPPKcbkPYp3QWYoDJVBGBqDEvRx1YTedrDgj5DeCYWhMghDY+g5rTCNcdWAwBAZ4IEAMkNhgAcoXoyrBjSG7gHWtxHsW7G+jWDfijVkBPtOSAyZoTBUAnyoYdkYZ9dOgIEMKAwwUABnFtKzKzw0aKZ1pR8KNNOB0pHSeALKElKCpcoesos7A0qP2J3pQOluCVl6yMhMZ0oXSldKC6XxYNQBPtM6VETq1r7aWBGpOyEy9Gz0NZ7ag3NxTH5FbC4KrSI2d0JgiAy9PhoM9CmcCYWh8m+EoTGwB5E9gDL0Rc2KcNwJlaGb7jv2KsJxJygBlGFAYIgMPXOKLGAUM6AwVIbuQV+Cq4janaAEGMX0la2Kg2ur4qEYxQxIDJmhMFQGYWgMSgDNUDQdaMYAeIDWAs0YkBkKw8MDOZC5rhkTGoMSdM2YEBgiQ2LIHVDbXTMmoB2gRCs8eEJjUAI5GAIDHorGJ5mhMCDbFSAMjQEPRfG2gwEPRSG2yJAYugcBfbbr0ITKIAyNQQn6YGdC9yCg9fbBzoTEkBkKQ2VAGfQmFp6CVAFh6QFChSckhsxQGCqDMLQp/TU8VQzwVLEnBAaoGByFig3IDIWhMghDY1CCp4o9ASUaAZmhMFQGYUCdFoASpIMhMESGxAAPFFAYKoMwdA/6qkFFRPGALmkTugcR9dMlbUJi6B70+Y+KiGKJqJ8uaRLhaJe0CY1BCcrBEBgeL1k85SFbI1lXUlayraTOJHQjoi1DNwYEhsdbHnl7SMhI5pUsK1lXUmYS8hDRYCACfQa+9nNs8/MflZWsK3laySj/R+cfSZ3JR8cfybCScSXxPFQ1uvyAXjnp+c8qgyzAqbUYzleE7Erfp1IRsjvhUQqKJGwlgDA0BiUIB0MYZdfDdUcyrWReybKSdSV1FXmMcRU54nKlT/hXHE07AeVRAJUBeaiAMw8FRfPors/ko7OOZFjJuJJpJWEbzqHDJTj36HAV/+jR3UYyruTDCkr50dFGsqxkXUlZybaSeB4A3WtAb/VoNjiJdkJi6N6jfeJUWcloAnj7D3iUAnKFd/+z+PDuH5AZCgOegvaAd/+AxqBUTejDAwIDeyDsgbAHwh4IeyDsgbAHwh409qCxB409aOxBYw8ae4CBwACZ/atxL2rci5R7EYYBA+ICHBUrfTK9JnTpAZnh0bWeybqSspJtJXUmH115JMNKxpVMK5lXcj0trKeF9bSwnhbW0yIanQACQ2RALhWQGXqR95n4irDYCcLQGJQA7+kBgaF70CfOKgJmJ2SG7gHEAQGzE4She1BQhZCNJ+A9PeBR5g3JuJJpJfNKlpWsKwnbXRVxgqwUFDaEoCB3JTMUhsqAPMA0Ph0GKAHEY0BgeOQCtiAeUDJExU4oDP35fcNHRbzshMbQn19RbBCPAf35FSUA8RiQGB6vb3j2kI6RrCspK9lWUmcSslBRuuj89fkX5AGtF18BAxqDEqD7VxQCuv+AyJAYMsMjF89kXUlZyUcuUC2PiQoke5jsSIaVjCuZVrI/r88xVYTHTqgMStBH9tKnoipCXSc8akCQLCtZV7KXXJ9dqjg1doISQEUwM4FY2Al4dgUkBuQEz4GKYNoGUbKCyRlEyQomZxAlO0EJ+gACtvoA4pmMK9mfgO8jxLpKj6apiHUVzJcg1lXw0YxYV2nICcbsDc5jZI5ZkYyR+QBhOJ9TkamHKjyTj2HDSPYSaU+AHeT70e/RlntY60h2XxV5Rp/HNAuCWidEhsTQSx1zLghqnVAZhKExKAF6/YDAgOegUPH6x9wOAlRFUajowIrM4b0+IDMUhkaAbooZHIShToA1FC3G55iaQeBo67GIFYGjExJD7hAAhaEyyHoOAkfnX5Sgj9AnBIa4Sgdnp07IDIWBygDxpc9sI750QmDIq60hihQrohVRpA3TRogindAYlCAdDIEhMqBE4XXKDIUBHhQAPEDmEjxAFhI8QBaeXRV1+uyqT4gMeM4TKoMwPDoZnOldFcneVZ/JnhPMESFktGGKp4eMVpRk76rPZPcV0xQIF20BZdK76oTIkBh6aQU8vXfVCZVBGBqDEsjBEBjwHJS9wBrKvuGfoewb/hnKvhWGyiAMpzuCEni8aZ/Jx3t2JMNKxpVMK5lXsqxkXUlZyfU0nU/rwZ8jGVYyrmRaybySZSXrSspKtpVcTwvraWE9LaynhfW0sJ726M94W/fgzmfy0ZdHMqxkXMm0knkly0rWlZSVXE+L62lpPS2tp6X1tLSeltbT0npaWk9L62lpPS2tp+X1tLyeltfT8npaXk/rA2VEXFUcG9owc4YIzIZZJ8RZNkxgIOSxYdoGIY8TIkPvfJgB6SGPGML0gMeRrCspK9lWUmfy8TE7kmEl40qmlVxPa+tp/UXXMEFU+4uu4Qu0xzlijNKjHEcyr2RZybqSspJtJXUke1zjSIaVjCuZVjKvZFnJupKykm0l19MefQWDqx7OOJJxJR9Pq0jmlSwriRKCuYgSwk/7uLPhuwehihMyQ2GoDMLQGJQAr8EBgYE9SOxBYg/wGsRsFo7unCAMjUEJ8sEQGCJDYsgM7EFmDzJ7kNmDzB4U9uAxDYYxRg9hHMm0knkly0rWlYRtAF6PmLnpQYgYx/YQxJEsK3laweC4Bx+OZFtJncmHKoxkWMleMpieQ2Bhw4wcAgsnKEGftmqY0EJg4YTIkBgyQ2GoDMLQGJRA2QNlDxQeoFNoYsgM8ABVqJUBHqA2FB6gNvpSe+shhxXHdk4IDN0DzK7g2M4J3QNMlODYzoaJEoQcYhiOiMORbpTWle4hPCMdKI0nVEDPCT4HcUZnw4QHzugcEA+GnhPMHuOMzgmJITMUhv4czJggPLBhfIjwwIYZE4QHTsgMhaEyCENjUALowwB4gCKHPgxIDPAAlQF9GFAZhAEeoKyhD0+APgzo1YPH9LjBkU6UfsQc4QMCQYMjXSktlG6U1pXu8YL4qEC44EhHSiPfaBUYcg8oDJVBCTCGwPc8juKcAGtoSVIYKkPPyfMnjdK60u2gdKB0pHSidKZ0oXSlND230XMbPVfpuUrPVXqu0nOVnqv0XKXnKj1X6bm6ntsP7ZzpQOlI6V7WGBfixM4JhaGXNcbZuMF+QmPodYq1cMXH+oDeZzBRhYM9JySGzFAY4AG8hgoNgAcK6B5gPgtHfjZMV+HIzwmRoXuAiSwEC04oDI/iD8+fCKUbpXWlH6OamQ6UxhMSoOcEYzmF/mDcptCfJ0B/BgQG5ASFBP0ZkBkKQ2XoWUEWe3RyeP53PB/FCvXBAAGhgBMejTU+0w9TGEj20L2A4UyP3JvpSOnuLia7ELc3oTBUBmFoDEqAzxVMkOGQzgmRIS+PH+Iy05XSPVcV6UZpXWmMXjB/hSM9J0SGR4YV71Uc6TkBGUZpY/QyQBj685/GdKW7xIx0oHSkdKJ0pnShdKW0UJqeq/O50oMDZzpQOlI6UTpTulC6Uloo3ShNzw303EDP7cqifU5QEEU4ITOUDhFQGYShdUgAJejKMiEwwIMMgAcF8Mh7hgMPYZnpSmk8vgIagxKkgyEwRIbEkBkKQ2VgDxJ7kNiDHoPcV+OlBxrOdKR0onSmdKF0pbRQ+lHxGUX6UKKRLgelkXEBRIbEkBmQcbSWUhmEoB4M3VqAY12mNKC6ukxNqAxC0MVIA7wWWEMDkcxQGCqDMDSGXikBldIOhsAQGRJDZigMlQEeoF+0xqAEejDAAxS8RgZ4gOLVzFAYHo2jogy7Go10o7TOdI8MnOlAaTxBAT0nPaBMEOOn8fnPlKCPXiYEhp6THl0miPGbkBkKQ2WABxXQGJQAGjMgMESG7kFCfvroZUJhqAzdg4T8QGYGKAFkJsFryEx/Jwqi/ybAgwLIDPAAjkJmBghDY1CCfDAEhsiQGDIDe5DZg8weZPYgsweFPSjsQWEPCntQ2IPCHhT2oLAHhT0o7EFlDyp7UNmDyh5U9qCyB5U9qOxBZQ8qeyDsgbAHwh4IeyDsgbAHwh5A2fp4UHAg6QQlgLINeHRtxe/7t9tIJ0pnShdKV0oLpRuldaUhWxhdIFpRE3REK0PPBt5dOHp0gi5AHOOEwBAZEkN/DsYHiFd8lh3iFZ+FggNGJ0SGxNCrpc+5CQ4YnVAZhKHxQ9mDeDAEhsiQGDJDId+eEvUEYWgMSr5BogYEBvYgsQeJPWCJiixRkSUqskTFRE0zZq6FzLWQuRYgUU/fMtdC5lpgiYosUZElKrJERZaoyBIVWaIiS1R8ShR8K1wLhWuhcC0UrgVIFEZiiLqcgFrIgMiQGDIDygCmIVEDhKExKAEkakBgiAzwoAEyA3czqFKfohWEWk5QAqjSAG58GG8N4KpvXPWNq75xB2zcARtXfeOqV6565apXrnrlqldu/srNX7nxQbh63N+5QHMwBIb+nD5NLYjj1B5SKIjjnFAYKoMwNAYlgNgNCAx4TgIUhsogDHhOBigBJG1AYMCoC9mGpA3IDIWhMghDY1ACCBe+FhCxOSEzFAbktAAwIofXkKcBgQE1VwGJITOgRAVQ2YAwNAb2oLAHhT2APA1IDJmhMLAHhR8K3cE3Gw4ynZAYkDkFFIZuGt8MCNmc0Bh65ioaH3RnQGDoHlT4Bt0ZkBkKAzxANUKEBjQGJYAIVVQWpKaisiA1AwoDnoMCgdQMaAxKAKkZEBgiAzxAiUJqBhSGyiAMjUEX4CTUCd10D8EUHGSqfRJacJDpBCWAhgwIDJGhZ6FPXAsOMp1QGCqDMDQGJYC6DIAHBRAZEkNmKAyVQVYFI8ZzghJgwDQANZcAhUoUgjJAGBoDMtcbH4I7RyFCUAZkBjwHHkBQBggDntMAXI2Fq7FwNRb2oLAHhT2AoAyoDNyQCjekwh5UfmidM+DSg0FnulL68amBz/8eCTrTutKQkoYfQEoGRIaerYZnQ0oGFIb+dFRMn8Ee6UZpXem+ODbSgdKR0onSmdKF0vTcRs9t9NxGz1V6rtJzlZ6r9Fyl5yo9V+m5Ss9Veq6u5/ZTUGcahZ0AkSExoLALoDD0NtRXcQSxrBMaQ29Dfd1FEMs6AR4oIDJ0D3pghSCWdUJh6Nl//kQo3SitK91PyxjpQGk8IQB6TvqKiiCKVRVFAUl5AiRlQGDoOVEUEoYyAzJDYagM8KABGoMSYJAzIDBEhscGlAOT+/3I1AWFoTJIB+TnoUkLlOChSSfA64cmnYDG9dCkBfAAlV4yAzyAo6UyCENjUIJ6MASGyJAYMgN7UNmDyh5U9qCyB8IeCHsg7IGwB8IeCHsg7IGwB8IeCHvQ2IPGHjT2oLEHjT1o7EFjDxp70NiDxh4oe6DsgbIHCg/Q5zQzFIbK8OjW5fn7Rmmd6R6nO9OB0pHSidKZ0oXSPYNY8ugxuCcEQGTo2cB0f4/EXVAYKoMwNAYliHhOAlC19HDcUSg9IHdBY1CC1KsFHwo9MHdBZEgM1DB6gO6CyiAMjYEaRg/VXRAYIjmaE0NmKAxcBpCoHnsuFRI1ACXatadCogYEhsiAMoBpSNSAwlAZhKExKAEkakD3AN+8FRI1IFPVQ5UwjKpQpQHC0BiUqlG46oWrXrjqhaseqjSgMHDVsypVVqXKqlRZlSqrUmVVqqxKlVWpQnsiOga0Z4ASQHswmqzQngivoT0DEkNmKAyVQRgagy7oQc4nFEBiyAyFAc+pAGFoDEqAsRMGJjjFdUJkSAyZoTBUBmFoBH2YFJ7pSOlE6Yeeoqn0sOiZrpRGHhXQGJQA4UMJ6UDpSOlexFjUE+jVgMJQR1iP4OzWkW6U1pXui/sjHSgdKZ0onSldKE3PzfTcTM/N9NxCzy303ELPLfTcQs8t9NxCzy303ELPLfRc6BIWPQW6NCAyILoK1YNwpQEobbQBiNQAYeiDcdQJvvyQ7gcijnSgdKR0ojSegDYAqcFSrEBqsPoqkJoBkSExoN2gKDAAGlAZhKExwIOuVQIRGhAYekwQnEYs0jOdKd1jglBaiEV6poXSjdI60w2xSM90oHSkdKJ0pnShdKU0Mq2AnmksyzXo0RP6cQMTAkNkSAyZoTBUBmFgDzBcwqJLD7heEBjgQQAkhswADzKgMggBBlIDeoDPM50pXShdKS2UbpTWlUZg0TONfBRAZEgMmaEwVAZhaAwoyd5MG4ZJAwIDPKiAxJAZeltCqXYlGmmhdKO0rjSiJp9pPBttD0I0IDH0Z2MtpEGIBlSGnnss2jSMlgYoAUZLWCVpGC0NiAzdAyyMNMjR8y8PBcKyVY+xHkn8GOUI9RmQGQpDZRCG7n59mlYCqM+AwNA9wFRnwxBoQGboHmA6vmEINEAY4AGaD4ZAgB50vSAwwIMKgAcNgOcoQBgagxJAcjANq5AczEcqJAdzzArJwRSxQnIGFIbK0D3ApK5CcgYoASRnADxAfqAyAkehMj0iWxQqgylKhcpgCk2hMgMagxJAfwYEhsjQPWjwDQOjAdRYFd9uAxqDEuSDITDgocg2RGlAZkC2USAQpQHC0BiUAKI0IDBEhsSQGdiDwh7g2w1jXMW32wAlwBhpQGCIDN0DBM8opGlAYagM8EAAjUEJIE0Kr7s0YYeSKI5HG5A6oGPgiLQBpQMcxTFpA4ShMShBH11NCAyRITFkBvagsQeNPWjsQWMPlD1Q9kDZA2UPlD1Q9kDZA2UPlD3Q5UHrEd8LAkNkSAyZoTBUBmFoDOxBYA8CexDYg8AeBPYgsAeBPQjsQWAPAnsQ2YMIDxIgMiSGzPAYInTlbAj/HmmhdKO0rnT/LhzpQOlI6URpZDADIGuAjGwUQGCIDIkhMxSGyoDiggeFq6VwoRQulFIYKgOqRQCNQQnqwcANo7IHlRtG5YZRuWFUbhiVG0Zt5FtVAjkYuGE8JQq+PSXqCZmBPRD2QNgD4aYp3DQbN83GZdC4aTauhca10LgWnhIF3xrXQuNaaOyBsgfKHijXgnItKNeCchkot4OnRD2Ba0GpFsJB7SA8JeoJkYE8CCxRgSUqsEQFlqjAEhVYogJLVAjUDkKIDIkhMxQGeNAAwgAPFKAET4l6QmDoHgT4BokakBkKQ2UQhsagBH2khomq1oPHF3SlOpAuSygCpKpPk7UeIb6gMShB5srOXNmZKzsnhsxQGCoDV3bmys5c2YUruwSGyMDNrXBzK9zcIG99/r7hpNgBkLcBKFCUG+QtwGvI24DMUBgqgzA0BiWAvA3ARyhqARPmAwpDZRCGxoDnoIlCxAYEhp7TiLYDERuQGXpO+2pACxCxAcLQGJQAIjYgMESGxJAZ2ANlD5Q9UPZAyYN4HAyBITIkhsxQGOBBBMCDDGgMSgARGxAYIkNiyAyFoTKwBz1EocC1HqLwTPcQhZHua5kJ6UjpROm+lon89gHWSFdKC6UbpXWl+wBrpAOlI6UTpem5iZ4LzeqrHC1CmfpZOi1CmfphwC1CmQZkhsLQrfUJ/RahMgnPgcoMSAyZoTBUhl4bCaUI/RmgBNCfAYEhMiSGzID8KKAyCENjgAdoKdCfAX3XYUU6UjpROlO6UBrZR9VARhL+AhkZUBj6ZjTkpAc2jXSjtK50D2wa6UDpSOlE6UzpQml6rtJzlZ6r67npOCgdKB0pnSidKV0oXSktlG6UpucGem6g5wZ6bqDnBnoulKKvEzScvDtBGBqDEmC4M6C3zT6v3RKGOwN6VWc8FMOdAYWhMghDY1ACDHcGBIbIwB4keJABhaEXPrLTZ81HulFaVxqK0qezG07UfTb1HrEd+lRP6wHbM90o3Tc8dWnp0dozHSj9qMaGp/U1uJHOlC6UrpQWSjdK60r3me+RDpSm51Z6LvSjb+toCSqRkRuoRIHb+AgbEBkSQ7eGl03CWARvlYSxyIDAEBkSQ2botVFQNRiLDBCGxqAEGIsMCAyRAR6goWMsMqAwVAZ4gJaCscgAeNDLOmMsMiAwRIbEkBkKQ2UQhsbAHvQF/x501BC4PdKR0o/lWXx8IGp7pAulH0v9PaypIWR7pBuldaV7vPZIB0pHSidKZ0oXStNzIz0XqtH3H5zQy68iN9CGCrehDQMqgxDgW6gvUbSMcUVfe2gZ44oBhaEyCENj6LXRw8ZbxhfPgMAQGRJDZigMlQEeJEBjUAKMRQbAA7QUjEUG9KqpSPff47MzQyMGBIb+e0ElQCMGPOo24pE91HqkK6VlpaEcgqqBPsjzL90SXOz7Mka6UrpbQsPomzJGWle6b8nAmBJn+I50pHSidKZ0oXSltFC6UVpnusdOz3SgdK/jvvLUCno2JiELerY8/5kS4CtjQGCANQV0a30VqRWMAwYoAcYBAwJDZOi10ZehWsE4YEBhqAzC0BiUAD16APLTAJEhMWQGeJAAlQEeFEBjUAKowIDAEBkSQ2YoDJWBPegbNDA47rHQI923Z4z0o3Uk1GffnDHSidKPVomxeI+CnulKaaF0o7SudN+EOtKB0pHSidL03ErPxfdHQwagDRhzIIz5OWhCGPOEzFAYurUeUN8QkhwUjQPjhwGJITMUhsrQa0PR3TB+GKAEGD8MCAyRITFkBniAroPxwwBhaAzwoJdoxfhhADwQAKwpQBgagxJAMQYEhsiQGDJDYWAP+pAAQ/AemjzTutJ9SICRdj9QeKYjpR/NDIP8fqbwTBdKV0oLpRuldaX7LouRDpSOlKbnJnpuV47YF0gbIpEjphsRiRwx0YxI5AmJITPAGrJaYK0CAkNkSAyZoTDUDg0gDI1BCerBEBgiQ2KAB6jRWhgqgzDAA7SUqgR9NPEchiLEeEJkSAzdA8yII8R4QmUQhsagBO1gCAyRITGwB89bSJGulBZKP1omRlYV1xwjjVuOn+lHy6yoTNxx/EwnSmdKF0pXSgulG6V1pgUXAT7TgdKR0ijZDED5Pf+C8utZ6wHFCwJDZIA1BXRrmHGWPgoZ0EchEwJDZEgMvTYwQ9tDhxdUBmFoDEqQDobAgPw0QGLIDIUBHiSAEEBLMMfZQ3/TcyzYY38XCENjUAJoyYDAEBkSQ2ZgD/r4AR/hPQp4phulH80Jy+E9CnimA6UfzQlTAwgBHulM6ULpSmmhdKO0rnTf9znSgdL0XKHnQh/wmYDo34hpYUT/RszqIvp3QmRIDN0aZmgRyRsxwYpI3gmBITIkhszQawMjwR7Nu0AYGoMu6BG9CwJDZIAHEZAZCkNlgAcCaAzwoPdxBPZOCAyRoXuASUYE9k4oDJVBGBqDEkBLBgSGyMAe4JKSgnShdKX0o2Xi6wznK4+0rvTzVjGkA6UjpROlM6ULpSulhdKN0rrSmZ6b6bkYhWTUIDQlP/+C8kPWoClPgKYMCAywhlrHWKMH+raGscYAJcBYY0BgiAy9NjC3iADdCYWhMghDY1ACjDUGwAPUFsYaAxJDZoAHaCnQkgF4TpeCBi0ZEBgiQ2LIDHgO6gcqMwA5RS20xgAP4Cj0ZwA8QGVBfwbAAxQ89GcAPEAXhf4M6B5UFCL0Z0D3AHNwiOWd0D3ATBtieSd0DzAZpdCfAd0DTMghyncCPCiAxgAPerYR5TsBHgggMsCDBsgM8EABlaF7gFkvRPlO6GMspHHR8DMdKB0pnSidKd2fjdkzBPtOEAY8G+WCUcwTMIoZEBgiQ2LIDIWhMggDe5DYA3wRQTIRxfvURkTxRkxVIYp3QmNQAmjRAM5P4fwUzk/h/BTOT+H8FM5P4fwUzk/lEq3sQWUPoFLPbEOLntmunB/h/ECLBkSGxMD5Ec6PcH6E8yOcH+H8NM5P4/w0zk/jEm3sQWMPoEXPbENxntlWzo9yfqA4AwoDtxDl/CjnR1d+FNG1EwJDZEgMmaEwVAZhaATQlZ5tRaQssq2IlEUWFJGyE4ShMShBPBjwnAaIDH0QoUhnShdKV0rjGQBoQZ/ZVRx53JAvHLT+TBdKPyw1ZBfnrz/TjdIPDezzrno8L4dBOlA6UjpROlO6ULpSWijdKE3PLfRcaEI/AkYRHDv/0mvimTX0/AFKgJ4/ANZQyRiFNNQRRiEDGoMSoOcPCAyoDVQNev6AzFAYKoMwNAYlQM9/1hZ6/oDIkBi6B4qWgp4/oHvQ51UVga4TGoMSYHwyIDBEhsSQGQoDe4ADsVDZOA/rmdaZDjgNKyIdKB0p3TdAH0hnShdKV0oLpRuldaWx9/qZDpSOlKbnBnouVKMfDqMIUY19VlgRohr7hhBFiOqExJAZYK1LCMJNY5/HVYSbTogMiSEzFIZHbaQDJd3HChMagxL0uZAJgSEyJAZ4IIDCUBmEAR6ghrMSFHiA0imBAR7AQIEHKDccjJWRLpSulBZKN0rrSj+PAEU6UDpSOlGanlvpuV2NUkB76Wo0oTEoQVejCYEhMiSGzFAY4AEqSIShMShBOxgCA36DVt6UQA+GwBAZEgO8RqVqWYCo0NTnKRVRoRMyA36jgMogDD02NyCtK41dh8903wQWkY6UTpTuccEH0oXSldJC6UZpXWnsNXymA6UjpROl6bmRntu/NVIEdJVIEZ52lUh9WlN7eOeCzFAYYK1XDSI8U0RtoMcPSAyZoTBUhl4bfZJPEfs5QQnQ4wcEhsiQGDIDPMiAyiAMjQEeoKXUg6F7kFCi/YsiJfymjzgmZIbCUBmEoTEoAXr/gMDAHiBeHblGuPozXSiNbYlIC6UbpbEHtqdx3MIzHSgdKZ0onSldKF0pLZRulKbnKj0X+pDQCBXl9/wLyg9Z08agC3rA6IJurZ8woAn60CcVNUEfBjQGJegKMSEw9NroK5LaI0EXZIbCUBmEoTEoQUR+FBAYIkNigAcZUAh6NHif6NEe1jnTkdKJ0rBUAYWhMghDY1ACjCkGBIbIkBjYg8weZPYgsweZPcjsQWEPCntQ2IPCHhT2AArT51w1QWEy2hoUZkBjUAIozIDAEBkSQ2YoDOxBP5YT31H9jN+Z1pXuh7Pgu6lHk850pHQPTEUD6DHnI10oXSktlG6U1pXuB3KOdKB0pDQ9t9FzG0oWbRvjjIJOiHFGwT/DOGNAYsgM3VqfvFXEgqY+X6uIBZ0QGRJDZigMvTb6TK4iFnRCY1ACKMyAwBAZEgM8SIDCUBmEAR40gBJAYfosp2YozIDIkBgyQ2GoDMLQGJQgsQd9aeaA031pZqQTpR/D7QNV2OdCRrpS+jHMx8ANp/yOtK50nwsZ6UDpSOlE6UzpQulKaXpupudCbfr0uyJ+NFXkBppS4TY0ZYAwNAIoR59K1wx9qGgc0IcBlUEYGoMSYATS59UV0aQTIkNiyAyFoTIIAzxA18H3xxPw/TEgMHQPBC2lj0UmdA8ExQvFGNAY+nMEBQ8tGdCfg0nEDC0ZkBjwHLiDb5YBlUEYGoMuKNCfAYEhMiSGzFAYKoMwNAb2ILAHgT0I7EFgDwJ7ENiDwB4E9gD6g5lYRLkOgP4MCAyRITH07U+w/NSV5x+U4KkrTwgMsCwA6jGIUZ0gDMhBAygBxjUDkAMFRDKAcc2AzMAeZPYgswe5MVCfxYG9EwIDe1D4oRAXzDTjJN4JSoABC17FOIl3QmRIDP05GHLgJN4JlUEY4EHvZQhUTZjoRKDqhMSA56BOITsDKoMwNAYlgOwMgAcoKsjOgMSQGQpDZRCGRgClwTQwYlMTphcRmzpBGBqDLkBs6oSeBUyeVujJgMSQGQpDZRCGxgAPejUinnVCYIgMiSEzlFXBiGedIAyNABKC9YQKoUCJVgxUBhSGyoDM9caH43VHIUI2BkQGZAEe4ENpQGFAIVaAsIHGwNWY2YPMHmT2AIIyIDMUhsrAHmR+KJQCA2NEuE7IDIUBpgWAUSWyXQ+GwIAsNEBiyAzIAuoHsjEMCENjYA+EPRD2QCJDYsgMhYE9EH5oV4qMKTkEqE5IDLkDukxXigmVQRhaB3SMPnQZ0IcuEwIDPED9KJ4DR7UyCAOegzaquqBHpS4IDJEhMWQGeCCAyiAMjUEJwsEQGCIDTCugG8AMOOJXJwSGyJAYMkPPQt9zp4hfnSAMjUEJ0sEQGCIDPEiAzFAYKoMwNAZdFYzI1gmBITKg5gJAqERzY1CCcjAgcxnAhVgKQ2VAFuBBaQxKUFGIaFWVq7FyNVauxsoeVPagsgdVGBoDNyThhiTsgfBDoRT5CcLQGJSgwTSaMgYYmGfEebYTCgOy0ADC0BiQBdSP0nwmomAnRAb2QNkDZQ+0MghDY6AZVUTBTogMvX6wmoHw1gnC0DOHdQ6Etw6AUgwIDL2FYJ0D4a0TMkNhgAcZgOf0logg1gmBAc+pgMSQGQpDZRCGxgAPegvBubUTAkNkSAyZoTBUAigFVkBwMG1OKHiIw4DCUBmEoTH0LGA9BZGsEwJDZEgMmaEwVAZ4gGqEoAxQAgjKgMAQGRJVMARlQGGoDKg5tGsoxbNEJTIkhsyAzKHxCReiKAFkYwCyAA8wDhmQGFCIaFWNq7FxNTauxsYeNPZA2QOMQwZEBm5Iyg1J2QOlhyJe9bkeiXjVCZEhMcC0ALDmVwGNQQkgG1gxQlTqhMiALCggs4HCUBnYg8AeBPYAny8DAkNkSAzsQeSHQinwYkHQ6YTA0DPXw88VQacTMkNh6C0EK1MIOp3QGJQAgoL1JxwqmzFxg0NlJxQGPAf5gaAMaAxKAEEZEBgiAzxAC4GgDCgMlUEYGoMSQFAGwDSaCwYYBQUPcRigBBhgDAgMkaFnAcsZiECdUBgqgzA0BiWAoAyAB6hGCMqAxJAZCkNlEKpgCMoAJYCgDEDNBUChEsW3zABhaAzI3Nn44oGg016ID0gMmQFZKIDKIAwoxApQMhAOhsDAHgT2ILAHGIcMqAzC0BjYg8gPfUaZNUBhqAzCANPSYcWfPSAyJAZkAQYgGwMqA7Lw/E1jA0qQDwb2ILMHmT3ImaEwVAZhYA8KPxRKUVGIUIoBhaFn7rFe/gBhaAxKAKV4LP88IDBEhsQAD9CUISgVLRGCMkAJICgVbRSCMiAyJIbMUBgqAzxAC4GgDFACCMqAwBAZEkNmgGlUCQYYgoKHOAxIDJmhMFSGngVBlUA2BugCHMA6ITBEhsSQGeBBAlQGYWgMSgBBGRBWBeMA1gmJITOg5gJAV4kibHVCYIgMyFwGUCEibHVCY0AW4AHGIQMCAwqxAqgaEdA6oTCwB4k9SOwBxiFPwDhkQGCIDOxB5odCKRocxU6YJ0A2BgQGmBYAosSfUBmEAVloACWAbAxAFlA/2O/yNPCMh39CZmAPKntQ2YMVKf8AJViR8g8IDOyB8EOhFA2FCKUYoARQioYuA6UYEBkSQ28hDR0DQ48BlUEY4AGaMgSloSVCUAYkBjwHdQpBGVAZhKEx6AIchjoBHgggMiSGzFAYKoMwNAIoRVNAN6AHoDIIQ2NQAsjGgJ4FjYDIkBgyQ2GoDMLQGOBBr8YIQRkQGCJDYsgMZVVwhKAMEIZGAA1pAZCoRPEtM6AwVAZkrjc+hLuOQsQXy4DIgCzAA4xDBhQGFCJaVeFqLFyNhauxsgeVPajsAcYhAzIDN6TKDamyB5UfiqGHolli6IFRJwJZJxSGyiAMjUEJnntq8NDnnponRIbEkBkKQ2UQAuycwdssQlAwgowQlAGJITM8nlOOp7XKIAyNQRcg5nVCYMC+tApIDJmhMFQGYWgMSoCdvQPSKhBEwz5zmp6684TKIAyUU0TDDoic08g57bozITFkBs5p5JxGzmnknEbOaeKcpsDAZZ24rJ97dVEgiXMKdRmgBJCaAZzTzDnNnNPMOc2FoTIIA+c0c04L57RwTgvntHBOC7eqwmVduKyfu3hRIJVzWgNDZEgMnNPKOa2c08o5rdyqKrcq4VYlnFPhnArnVDinwjkVzqlwqxIua+GyhiJlASSGzFAYkNMAmOc6nABFGhAY0HYiIDFkBpRoAlQ2IAyNgTxAXO2EwBAZEkNmKAyVgR6KgNlyZEBkSAzIXAUUhsogDGguAlCCpwg9ITDAA/gW8RwFVAZh6M8JB0AJutRMCAyRITFkhu5BCIDKIAyNQQnywRAYIgNMJwAMoODLwRAYIkNiyAzIAqqkVAZhaAxKUA+GwBAZ4AGqEeoyoDBUBmFoDEoV/FSXJwSGyIA2WgBCJSqNQQnawYDMofE1LsRWGCoDngMPWmNQgi4oJaJVKVejcjUqV6OyB8oeKHuAIc6AxkANCYGyEwJDYuhKkRJAGBqDEgRkLgC6IiVYw+kBAwpDz0KMAGFoDD0LEc/BDuGnAewQHhAZ2IPIHkT2AGOXAcLQGJQgsQeJHwqliE+oDMKAzFWAEkApBgSG3kKiABJDZigM8KAB8JzeEhHoOiEw9OekA5AYMkNhqAzC0Bi6BwktBIIyIDBEhsSQGQpDJYBSPJulwAAKHuIwoDBUBmFoDMgCqgSyMSAwRIbEkBkKQ2WAB6hGCMoAJYCgDAgMkSFRBUNQBhSGyoA22nUUIbDPEkUI7ITEkBmQuQagQkSg6wDIxgA8RwGRITH05+QDUNhAZRAG9iCwB5E9wDhkQGRIDJmBPYj8UCgF1B8hsBMiQ2JA5gKgKxLeGAh0naAEkI0cAYEhMvQsZNQPVnmGgcJQGdiDzB5k9uB5SuMTAkNkSAzsQeGHQikyChFKMSAwIHMVkBgyQ2HoLQRjf4TATmgMSgBBwVgZga4lo7IgKAMKQ38O1g5xYOuExqAEEJQBgSEydA8KWggEZUBhqAzC0BiUAIIyAKbRXDDAwBIwAl0n6AIEuk4IDJEBWaiAzFAYKoMwNAYlgKAMgAcCiAyJITMUhsogq4Jx0usEJYCgDEAbLYCyShQhsBOEoTEgc73xIdB1FCK+WAZkBjwHHmAcMkAY+nOwAItA12EgczVmrsbMHmT2ILMHGIcMqAzC0BjYg8IPfZ4NjUJ8ng39hMogDMhcb8ryPAEajeJ5AvQTEkPPAlaXEeg6oTL0LGBBWZ4nQD8NKAFWeQawB8IeCHuA+ZABhaEyCAN70PihUAosdiMEdkJhQOaevxGGxqAEUAqsLiMEdkJkSAzwAE0ZgoKFUQS6TtAFCHQtWDvEca8TIkNiyAyFoTJ0DyQAGoMSQFAGBIbIkBgyA0z35oJA14IlYAS6TkgMmaEwVAZkoQIagxJgCmRAYIgMiSEzwAMBVAZhaAxKAEEZEKiCISgDEkNmQBstAKUSxbfMgMAQGZC5BuBCxBfLgMaA58ADjEMGBIb+HKxjINB1GKhcjZWrsbIHlT2o7AHGIU/AOGQANyThhiTsgfBD170TD1AC3EszIDAgc08o//S8auIBlUEYehbaE5QAsjGgZwELyu1578TzL4khM7AHyh4oe/C8d+IJukCf9048ITBEhszQ6weL3QiBnaAEUAqsSCMEdkJkSAy9hWB1GSGwEyqDMMCD3pQR6FqwMIpA1wmJoT8Ha4c4hHVCZRCGxqAEEJQB3QM0F8TDTkgMmaEwVAZhaARQCqw7I9C1YAkYga4ThKExKAFkYwCygCqBbAxIDJmhMFQGYWgM8ADVCEEZEBgiQ2LIDIUqGIIyQBgaATQEC/EIgR0lim+ZAYWhMiBzaHyNCxFfLAMiA54DDzAOGVAYHs+pWEBCoOs0wNXYuBqVPVD2QNkDjEMGZAZuSMoNSdkDXQ8NCIHtt1A9IDFkhsKAzAVAV6T+xggIdJ0QGGL/TQQkhsxQOiRAZQPC0BjYg8geRPZg3ZD1gMSQGQoDexD5oV0p6oFCTJEhMSBzFVAYKoMwtA4CUII+9JgQGOBBA+A5qKxcGYShPycgP11QBnRBmRAYIkNiyAzdg4AW0gVlgjA0BiWoB0NgiAwwjeZSYQAFLwdDYIgMiSEzIAuoEqkMwtAYlKAdDIEhMsADVGPLDIWhMghDY1CqYD0YAkNkQBstAKES1cagCxACOwGZawAqRAS6TqgMeI4CGoMSdEGpfS4tINB1GAiRITGwB4E9COxBEIbGQA0J8bAT2IPID+1KUfuaUUAIbO1LPgEhsBOUIB0MgSEyJAaoMgoed+kNqAzC0BiUAHfpDQgM53MimmgPep3pSmlkEwUANRmgBFCTAYEhMiSGzFAYKgN7UNiDwh5U9qCyB5U9qOxBZQ8qe1DZA1ztXZ/QGJQAF3IOgAcF0Cu0PqEwVAbkFAUP0RmgBBCdvmgWEDM7DOA6vgGJgT1o7EFjD/BZNKAxKAGu4xvAHig/VFGI0AyIzoDG0DPXV90CwmQnBIbI0Kuxr6AFhMlOKAyVoXuQeh/DKbC1L/4EHAM7ITLgORmQGQpDZRCGxqAEEJ1UAIEhMiSGzFAYKoMQQHT62lpAMGzty1wBwbATKoMwNAYlwFglo0owVhkQGRJDZigMlUEYugcZ1QjdeQJ0Z0BgiAyJIVMFQ3cGVAZhQAfsLyyEyY4ShaAMyAyFAZlD46tciBjFDAgMyAI8wChmQGZAIaJVCVejcDUKV6OwB409aOwBRjEDEgM3pMYNqbEHjR/6vPgbZfC8+PsJiSEzIHNoys/rvZHt5/XeHdLzeu8noB1UQGRIDChEARQ2UBmEoTGwB4E9wGfRgMiQGDIDexD4oVCKvqAXEP86ITL0zPVVt4D41wmFoTL0FtJX0ALiXycoAUYxA7oHqB+cFVufjkJQBlQGPCcDGoMSQFAGBIbIkBjgQQEUhsogDI1BCSAoAwIDTKO5YBxSUPAQhydgHDIgMESGxNCzUFElkI0BlUEYGoMSQFAGBIbuQUU1QlAGZIbCUBmEoVEFQ1CeAEEZEBjQARVQqUTxvTOgMSgBvncqGp9yIeITZ0BhQBbgAcYhAxoDCrG3KsSyPg0glnVCZEgMmaEwVAZhaAzUkHBG7AR+KIYeGGQhlrX2Za6AWNYJjUEJICgDAkNk6FqVn5AZCkNlEIbGoAS4YnxAfw5GdohlnVAYKgNy2hsFIlYDhnmIWJ0QGdDiUYiQjQGFASWqAGEDjUEJCntQ2IPCHpTEkBkKQ2VgDwo/FIIiKBAIyoDM0DPXt6UGxLJOEIbG0JsLvhMRyzohMEQGeID+A9kQtFHIxoDGgOegHUA2BgSGyJAYMkNhgAdoIVCXAY1BCaAuAwJDZEgMMN2bCyJWK+YPEbE6ITIkhsxQGHoW+vJTQGDrhMagBJCNAYEhMiQGeJAAhaEyCENjUAKoCyoYIa8TIkNiQM0FQKMSxTjkCRiHDAgMyFwGcCFiHDJAGJAFeIBxyBMwDhmAQqwArsbM1Zi5GjN7kNmDzB5gHDJACQo3pMINqbAHhR+KL5a+6hYQyzpBCTBCGQDTDRAZEkNmeGTuwGcsYlknCENjUIIuKBMCQ2RAIaKCISgDhKEx9JwqCgSCMiAwRIb0uKTs2XYegrKgMFQGYWgMStDvFZ/QS1TRyDFcGVAYKoMwtAWIcq19yTcglrX2Na+AWNaKxR8c5zpBGGCtAJQAGtIXAQOiXCdEBuRHAJmhMFQGYWgMSgAN6ct2AVGuEyJDYsgMhaHXXH2CUrlBUAZwiUJQ+lJfQMjrhMxQGCrDI6fSlwcDgmEnKEGXmgmhAzzoUjMhMeQOqMYuNRMqAzxAnebGoAQFHqBVFXiACi7wAFVS4AEKsWSGwoDnoAyKEtSDITD052BdCfGvoyljuDJAGBoBRigDenfGR0oPeV1QGNAoUKIiDI1BCdrBEBgiQ2LIDL1KsLKFwNYJStDHIRN6UQUY0MiQGDJDzym+mfoRsAuEoTHogh4ZuyAwRIbE0J+DWbYe/7oAOU0AJQgHQ2BATjMgMWSGwlAZhKHnFPNvPf51Qr8eeEJgiAyJITMUhsogBAk5LYDAEBkSA3JaAYWhMghDz2nfexDkeQco4HkJ6BMCQ2RIDJmhMKBOUfUQlCdAUAYEhsiQGM7nYLzVI2ZHsq6krGRbSZ3Jh7xgkNbjZ0cyrmRaybySZSWRo65jiIAVLFEiAnZCYkD5wAXoy4DKIAyNQQmgLwMCQ2RIDOxBYw8ae9DYg8YeNPZA2QNlD6AvWKbFibATKoMw9BLFiikCZZ+AQNkJgSEyJIbMUBjgQQQIQ2NQAihP36YXECg7ITIkhryqvj2V5wmVQRgagxLEgyEwRAbkNAMqgzAgpwWAnPZ2jXjaCYEhMiCnAsgMhaEywAM4ikEOJicQTzsAg5wBgSEyJIbMUBgqgzCwBw9Nakg+FGkkw0o+tAGN4aFFI5lX8qENB5J1JWUl20rqTHYleibDSsaVTCuZV3I9ra6nVZQjHIIO4fMIgbOC3omDZCcUhsoAa6i8BmsNkBgyQ2GoDMLQyx4rdoiiHYDRzIDAEBkSQ2YoDPAAbRZqM6Ax6AJE0QoGI4iinQAPEgAeFEBmKAyVQRgagxJAbQYEhsjAHjzUBt9DPdR2JOtKns/GJ04Psh1JncmHwuBjrQfejmRcybSSeSXLStaVlJVsK6kzmdbT0noalCQ/AaUF76AXWAzA8bEDoBcDAkO3hpUoxM4KVqIQOztBCTAeGRAYIkMve6wqIXZ2QmGoDMLQGJQAnz4D4MEBiAyJITPAA7SLWhngAUoUI5gBSiAHQ2CIDIkhM3QP8O2EENsJwtAYlKBPxkwIDJHh9CAcz3SmdKF0pbRQuq00dAafXQihFazzIIR2AsZITxCGxqATHge/MgSGyJAYMgNKLANQYgWgBNCMAYEhMiSGzICcVkBlEIbGAA+kA0YoAwJDZEgMmaEwwIMGgAcKaAxKgLHLgMAQGdKs04iA3AmFoTIIQ2NQAmjRgMCwtCgiIHdCZRCG/py+MhMP0qJ4kBbF46lFT+jPERiAFg2oDP058vxNYwNKUA8G9qCyB5U9eGrREwpDZRAG9kD4oRAZQSFCZAYUBmQOTRkiM6AxKAFERtCUITIDIkNigAdooxjSCNoohjQDlABDGkHjg9QMiAyJITMUhsrQPWhoIRjSDNAFiM6dEBgiQ2LIDDDdqwRht9IXcCLCbickhsxQGCoDslAAjUEJoC4DAkNkSAyZAR5UQGUQhsagBFCXAWFVMKJzJySGzICaywClEoVsDAgMkQGZEwAXImRjQGPAc+ABBjcDAgOeowCuxsLVWLgaC3tQ2IPCHkBQngBBGcANqXJDquxB5YdCKRLKoCoBZGNAYOimFU1Z1hdKDFIZhKE/py+fRITUDoBsDOjPUdQPfSPFQN9IMdA3UgyNPWjsQWMPICgDlACCMiAwsAfKD4VSKAoRSjFAFyCkVvrSTkRI7YTIkBj6c/oIPiKkdkJlEAZ40OsHIbXSP0MiQmonJAY8RwGFoTIIQ2NQAgjKgIcHrS+sRITUTkgMmaEwVAZhaAQJpiMABlDwqTIIQ2NQgi4bE5AFVEmODIkhMxSGyiAMjQEeoBrLwRAYIkNiyAyFKhiCMkAYGgE0pC9MRoTUjhKtmaEwVAZkDo1PuBAlMEQGPAceSGYoDHgOWpVwNQpXo3A1NvagsQeNPWiJITNwQ2rckBp70PihXSlaQLPsQ4/Wl5AiQmonFIbKoAsQONv6elJE4OwEWEuA7k5fZYkIdW198SIi1HVCZoAHFVAZhKHRc4LSX3pHnxAYIkP/AhuQGQpDZeAySAdlOwUGLp0EawcA+REA8tMAjUEJ0OsHBIbIkBhQogooDJWhexDhG3p9RObQ6yOygF4fUdalf9M+y6BEhsTwKDdpT8Bz0A4KnoPaLkpQD4bAEBkSQ2boOY2oLEjAAGGAB6iFCg9QbhCHiNKBOCSUzkMc4nNg1sNjF2SGxyzB8xOuB8EuUAJIQMJvIAEDek4TigoSMCAz9JwmZBsSMEAYek4xLEKs7AA9GAJDZOgeZHgNpRhQGCqDMDQGXYAo2gl4TgD0tiNPwG966SDudUJg6F73udqIo14nwOsMKAyVAV4XQGNQAqjLgMAQGRIDPKiAwlAZhKExKMFDd2bpJDxHAJmhMFQGPKcBGoMSQHcGPHr9cxqoB84uSAyZoTBUBmFoBBhT9PnciPDYCYkhM/ScFjSkPqaYIAyNoffGgvqpB0NgiAyJITMUhsrQSxTzO4iVnRAYek4xBYJY2QmZATlFu8bQYwByiqaMoccAJYDuPH2D7gyIDIkhMxSGygAPUI3QnQFKAN0ZEBgiQy/rZ9/u87DPj7seUhvl2bf7POwEXdCDbRcEhsiQGHqdQjp7sO2CyiAM3QN8dPVg2wnhYAgMkSExZIbCUBn6c/ACQ0gtwmwiQmonRIbEkBkKQ2VAneKhUKQBSoCR0ICe0/iEyJAYMkNhqAzC0BiUACOhfhZcROTthMzQc9o3vERE3k4Qhp7TvuYQEXk7ACOhvnAQEXk7ITJ0DzATjDDcCYWhMghDY1ACjJGwPIAA3QmRITFkhsKAVgWvK7cq4VYl3KqEW5VwqxJuVcKtSrhVCbcq4VYl3Koat6rGrapxq2rcqhq3qsatqnGratyqGreq9mxV/+t//ad/+rf/+l/++X/863/99//8P/7jX/7ln/63/2f+h//+T//b//7//NN/++f/+Jd//x//9L/9+//8t3/7T//0//3nf/uf/R/99//2z//e////+Of/OP96tqh/+ff/6/z/p8H/+1//7V8eqf/1n9avj/c/fextHT9/7ExN00Q46g8j4b2R9pir6ibOxdZlQPIPA9Hw4niM6OHEOaP/1oSVkcd+iWHjEb7+NiP5vZF+A2Q3kckLCT9+X97/Pj2afP/9OcJdDhRx5wJnYyMX5yfa++qQ90Ziv5yn23i8SMhE85rAXmXkpDbKSvhZFmqYaNMCZeOlQo3f92Ne+u9rKvP35+f+z1ZpNMvQL0tEWZbQ3tuIVkE8vueeBSHprQ2rLPvoBSZa07dlGYyG+XgbjipNiVrFWTQ/bFiNM003dBVoqF9kRJeFo73PiGGj9AMUuo0zuWzUn4r1mGJ4X62PCdZntZb41oTRtvrKW7fQWLBKcVvo35SwUMNbC9FonY+VulGlj849bOT404TROPuOAjih8t6JZFRp3wKJKn38bjbvmq/Vh7yvD6tV9Oh/tAo59J2JR1d8L3qPxZyn6OXw1oTcrtN2v071bp0m4x1yds1RH3quE686TYc/I+HxJfTMSAnvMpKMxhmX/h9vDdhSoXU2ipDe1WjK99XbsnHOuYyMnFMp71+FqZpvoji7CJXGuTD104ZVHG3USD0KWQj+hpHCbBhJytuGkYzmqbmN9qnlYMH46Uc2/Ih9GxEal0QSjC/qREZnP4ds8rZOsjXm7PMVqBMNNOYML8NFQz4fW0WX9p2zP2Tl51gr5/utI5e7rcPOSz8b8OlGLfo+L9bYM8hSQBrsnAutP2202+1D70ugXR6a1/BRecj0Uh4lWC9YOeYLVrg8XmxYStqDPZ7l0VZrP+fxf9pIVo+ZL/pzdri9t2GpaZwN5HH1xHsbxRrIpqGmj7ng9zaq+c06e+4PRW7+BuKUwtLuS2HRu03drlgdhZETydhrgVarkfYDkp6vyfy+cdR4v2Jrul2xZnHo/FA6h6Xv22gtG4qjbigOuV8c5iBsdvtz3d5ww2ij5/Tz+Ow755vD+y5r+aE1zdHg8d4PMVpprdOPKuG9DJqifg4Ih5HHPmh5K+piWKlx9tp6Lt6/t2ENYcIx+22I8ZoNWcOgRqP0Xzaq9Sk833Jy/t8q1fAyL2A0VMnzBSXnTP97G4aaptVvScVi1J8WLC0NurocfUS+2mjG0LRf54Wmno5rFnQOxEJ5nw+rdaU0avWchXvfQluyvp3yzEitF2309d/n95fEazba+rBvx3sbdp/tW/ufffacunnvye3PJ9MPCXMi77Ed+/2AsKk1T92XU5/z1E2ON+98vf0BZSrHmrI/FzuPtznReF85NN1XDs13lUPLfeXQelc5TAsu5bBbaFuLOaLlfX9TvdtTrNZ1Lj6nOWKI+VqvP0cuc/TTzkX4t1bCYQ080vp24mnvc1brxUi6299sP/JcznhEvbz1w5yxkNnSH7sN385YhMMamPZbIZ/zpD9U/dWIWPIx59Vy+2FE/EbOxcbZZTKvdP0yovfnTkI47rb4D8XaZhOpMVysm3449NOIVTfB+gI62qyb8GMWp3zjSVvj9VgMT4q1mKnzvZ1/tNcXT0K1Vq2mlqTU5JoRd5nY6xzepqZ/2tTSsdZmj3ZRBtIxF23ONSB5b8Raf3rsw55ThhpV3yqj5Uko82s7WT0nWuujh6z1ih8js/RixGivUmduRH7M5X5hpNW5XNDqj2+yVyOyoalZazjOpmb24Ewj3mB0PmvZ4RF7v1bmqmEkmO++qSUiXMEvJWIuSTnf46YczYWxMyUXO1+aM4fpnL97bySVm/EVtht5DuAf58wbbpiTVGtCJSVu7/kLI5pn9z3aYRix5nRlznWp0DfN67dEsNamVMq0QZOpKX3jhyw/aAnktx+mtMrsNAdPuv3yxAoxCFPQIk/Y/+o05upUlUSf37W86zbW8tQj1HVqQMmGJ9VsJbpaiRgFK/e/WoO1QuX9bA1Z7363hnLc/3AN1hKV78vVNuH6dLXf4GXOFJ3DYOO9aa1QnS1kCvxB76vXUBRrhSqtmZHjfQBGKObkf5ixKFEydd6Xd2+xNPFxPeXod4/bKd8uMJnS+tiVNz88g6HPZcdXVr3/lWXKSJsBmudnSXovI9ZK1bm6k9f86mrxKl/YkFnDVYphw5q3OsJcTj1ouJnjS4lYa1W6JP5c08yGEWsNoM7+e0701vdyZq1WlTJX/ktp9Mb6YqRY55jmHKoZI0VruepxzHFe6/ZUsC/vKzFnWBM1tPjeE2vB6qyDFTnE8cCvQZsS70uataLglDTJGyRNyhZJs1QghTVuPQdH71XAWrOKdQ2wRI3RorVo5R5MWOtW7sGEtezkHEy0sGEw0eLtwYRpwjeYqBsWNUMrO+ql3q8X2VEv7X69tNv1Yg5Gcpiz8UWN7zy1Bps5ynzRUHn8klXdIKt6X1Z1h6zq/wuyGue6c/rxunqVVTWHmyvuJXGgx2un0R2yqhtkNR63ZTUeG2Q1Hrdl1TbhlFU7AHBOfsVc3w4241HM8Rkt5x9JDDMbJD4esqONtPttZEPoSgy3Y1dsE842YkUF5DQn0Tkq8uXLKFpLWGkug6VMU70vmyis/VJF5uLx+S1CU/n51Q1LEA9ZHwFa3xqxyyPMcaZUek38Kg9rKkCWvksjR8rLjg5r+aocc02e1p9/m9D7X6wxHve/WKO1ecr7xRqt5SvfF6vth1eFrKkvtwpZ605OFTK3UHlVyFq6cqqQacKlQnZL9b6prOmIL95UaUcbSXFDG0npdhuxdt6424i1dOVsI6YJZxsxBLHNJQmOjP4liKndn0SISTe0D2vdyt0+crjdPqx1K3f7sGK/nO3DNOFsH9Zbt6a1+K1GC8lmnEVa+3/Ik99GNsxVxdx2NLMdH1Xl/kdV2fFRVe5/VJUNH1WWsvebhcdQJr0dIFprVvmYUyL5KMaYytxWlWecxuPO1uXIy3jIWrSKOncjnYNFKlR9GbxbG6sep8jNJSueQ8gvfcbcWVVnjMWZ1LczK/YrYkbBPU4oed95rc1V3hmRWDfEWse6Idg61tvR1rFuCLeO9Xa8tW3C944w5b2/QZ7jTLFaiG5oIdaKlbuFWCtW7hZirVg5W4i1YOVuIWYUuq+FmCZ8LcQWs7UDL1NM7y8xMzdYeT93rcUq5+eubAieiW3HULXdH6q2HUPVdn+o2u4PVa3XLocER9pm9eu123bMqLYdM6rt/oxq2zGjqvdnVPX428r9sS5T31eutVZVjjyn/w5aaHoJ9fwwytS53TRQmf4aZVqLVW2uuzU6uOOXGpobpWYwUlFeMnstjh3NVO83U93QTNNxu5naJpzN1GodYW1GTkbrSNZOK68GpWPDfGo6bs+npqPuqFy5X7m351Pto5jKPIqp1reHa1k7xta5b5ljiH+domQd6JeOubcihcTB9+kLIzw1nKJhxNqd6DuDLllrVL5D6EwTvhPLkrU1ynlkWbKah/PMMutL23sQnb9WxKgVb/Pg41C/amNhntyRorEJKJm7q5zHVybzgD/vCWhmdkqdm8WqmR0rnErmZMqZpAb/ErZjG+kXPMBIy2oYkfudN7bbndcy4ey8ZsCss/Nay1POzmstTrk7r7tWjM5rNg+dkQOifC7ca/OwlpacJ0km68A/b93Khrpt9+t2w1FqacdxW8lanfKet5Xy7S2AHzRonmUkTS8KWQu6BETex4anbIZS5bUpkiYOX8/0tcV9nZiVVIxBVd4gqfm+pOb7klo2SGq5L6llh6TmDZJqN4+5JyMfP/ZkvDSPUu43j1JvN49yX5VL29A87h/xa+2lcjcPd61cbh7rO/k42rXhcl5xZfnIRhuzFqacJ4unuqGd1vvttN5vp3VDO63326nsaKd1Qzu1W8fdGYxyzNNPy1Hen36frAWlGmd0bM3JeO2LuedvxqXwiOz1rW/e+hHmdHB43OD2LuogWatB3hOUk7Uq5T3UyDZSesjps4nE9P7IqWRuooq6jiKh0NT6hYm0PpX5uJpXE9GaSJ1enHOnb018KA/nudR9L+z7wfI6VeX8Zn+bmQ1nWydrZcp59Lllos5ThGrUiyamKld6R/02YZXGCsJ+NFmjNMwijUpt/b0RaxOV9+ieD83Me2R4UnO133dmeDJ3UjkPDbf8iDPc98dxGb/9sIyU2Uwi30L0y4hdsCJrD3M7ilGw7baemSZcepattaUtevajPEJ6Xx62Ge+R7vmwL01ZZ2dRtF28bqRtMFLTVSO+I+qztcbkPaM+WzupvIfU58MO/XedUp+DfbDKOjnnqBeNOM8Az9YFVM5DwD84MndDPS4qv5qbGdr5uEX5auWkFaiS6lUja00jJtlgJEfDiBnu6jvWPFt7Veox+189NFzsOs5z73PccA9AjnFD14kbbhPI1r4qb9exHXF2HduIs+vYlVNpJS/sMFKuGml0OaBcNLJOazs/duNFI03nq0vj1TJZr67EC5M3jLSr2Zl3AqQWrraTNo/VfVwOftXIXFlIvM76rSeznbR6uYpnWNGZ1KsdcI1OolnF5lHS6wsjhXTZyLGM5A1GYrosSrqMXBX7tVU7pqIbPDFHFubY0XcPTs6y4QVoXl/lfQGaRrwvwHLcfwHajjhfgLYR5wvQrhznC9BvpFw14nwBmka8L8AsG16A5ijWeUlQLs5bgviwhK+GwiXNiMnCl/N8N5723hPkzY516ZH/y7oZn+c1317JyeaNVmkerpn4wqLfjlgLW2XeByMceP3LhtVe19a+9OP2JXmxYYmJ0s2ifKfMqw3zFpZjxqGfaQ5Ibd8U61xU+nEYdPzOiK660feNxJ7ZqmG2klCjMWGYrX1XsiJb5P2a4QdHpo2HI8aNmOYSl8wp7iPQtLJ85Yr3rq9srXJ5L/vKli/e275sI87rvnLbsE8wtw37BHO7vU8wtw37BHO7vU/QNuG7usesXOeNTLnJjsptOyr39uHWWTccbp319uHWton7leu+EMlsIXnuNT6T7ZqRkqYmlp/3F3wjic4b6rKae0p8V9TZRpx31NlGvJfU2dlZA8ba6kUj61TKoqVcXOWqed5RcabzdTMrhuCsK7lqxnt7Xzlu329tmvCFANgmfCEAdryL9xbBcmy4RrCE2/cIfvJjXTkXlL6UXv0wRgIa1o0Z4e0is21ijdI0xnZpkVnS3PpzpkUvNnihcDUp4b2ZYt575Vq7t0241u5LaH+7dv+zPOKNYl3B7iVdVTVZ8Rlnur4faBVrytJZO6YJX+3E/Me186M8jIHnx9oRMhOumvFeYFnu33xlmnC+LEwTG14WLcxp4DNtvIOLfe+VJ47PNHEq9BpUSC3HNSNC7z6p4aIRaiO81vZNs29xzTC0dFlN3JeUlvT3Zs5PEjpHiKejykUjIV404rx1tdzfqmX74bx11TZS8rq7qoZrRs76mLusjh9Twa+B3+Y5wL5Y6WIeJui8ALZYCzrebcWmEe8tsqaR0i/IwidTbOGikTQ3oJzaI++NlPtjgnJ/TFBujwk+lMZctiiZz6z8VRpWtPQxb+E5X8JqGDE/7+dbmMIhXjXRdmOuPNbwY/vaN3kJc2vROb0drhqZU1H1/Hi7bKRNI8adyXb9Oi9eLtZhgluMeHcHlHp/aqDenxqot6cG7NJw7g74UKS+3QHF2rbl3R3w4UXjuxLbNuK8iLpYy1rei6iLtXXLexG1aSQfMyIjH8ZF1EXuTw3I/akBafdfNM5j66ybrG0jzht5bSPOq3BtI7JW2eVqg09ro2KSaHjyYdeV6+iYYt1/5R/j2Qv+s61aVx2XZka5OK46Ni3U+R1Q6Vvvd3HohjK11rTcZWotnIagK6wr87j5pUSsC7CcZWruTPDd/GwbqTqNtHpcNOK8Prpo3fDOs4xonRMc+iNG7XVUZBuZ9XuuBOtlI2kaiemiEeeV2tW6AMt3pbZpIqzTK89B/PvbsD9kxncvdz3MG4Z993KbRs61innC0MHBnV9lp82PEm28geWrCm6rqSkF6/wuk/bHRs6R8pwyCslqJ96o2XK8N2KdRhHCfGWdShsvGllRXeEc9F00kucJDOcrpxhGrCFnrvMAlx9Ti/pFuaY6BTa19+VqqrT3JuoazMsw52jvnDpbRl5i1Ewb3q/Oaoaqur46TRO+r07bhOur0y4N51fnhyL1fXVWc7+W9w1stjLnFaPVugnLe8VoNQ+0k/l181geW5k5XmxYKwO+A2lqNO8X8hxIY5rwHUhTrWMGnWHM1Vr68R1IU5O9Y9p1II2/VsSoFat1rCjmoDQCf7WRzAss5hzr+ZbXi364LsKt5uKG6yLcmjZc12IbWeGPZzJcMxKOeS9YzMaVvLYnJa0zJOtVI87LgWu2RNV9OfAnM0qnDvEGj6/MhLyOLDy7olw2s+4qChzi9suMWcBJV1XznrGvaimvxXWOkvttxJxMG47kmgyNts8LPZbAtkti8GMQTvskX22U27di12IOBMpsJMpf0a8ibfnhLFK7audehrOW08UOGI60IvV+fO591+TDKpRzkeVyBwzrpKzw8w34zbhzBh/WH8eOfDV0ncthNRsmzI+sFQPJh6h++ZG14lNzDBs+9+LVCYo2v7K0GdH7td5eHLBNuBYHam1/asK5vmAX6GwfZ9m+vzapWndi5br8kBDe9xfLSOjT9Wgf9TBaqmmkziiFx36mi0ZaWRFl5aon3lkwCfdnwWxP1pa1IM3KTtsw42Ma8c74mEa8Mz7W7izvjI9drmvJtIVwtUic+mwXiVOf3ZVj6bO9XKnrtK38fqWxNrk/yVHvL2fVHctZdctyllmsa2BzrrG/Xzat1nJWPNYoPPwI53xpJdbZfVLm94DUUC8aqbN+RUq7ZqSFuaLV0o8NY98YKbPntBKTYURujydsPyrd+SWGH3rfD707KBFrIco3KLFLo85LjJp1mYocf23EOw8u9zdmyf2NWXJ/Y5ZdGs558A9F6psHl7Ah+soWxDKDUWJNRgsxDx/0TWHLhquy5P5VWXL/qizZcFWW3L8qS3ZclSUbrsqyW4dvCltiuD2F/cEP1xS2xNuzVmItX3mnsG0jzils04h3Ctv2xDmFbRtxTmFL1B1T2J/MOKewbTPuKexPZpxT2HYBO6ewbSPOKWyzB/nmW82O7JzCtm34prDl/nqWmKtIzilsub8q8KFqfVPYH9qqdwr7gxnvFPYnM84pbHvI6JrC/jDq9Exhf4hvXwcoVmM3lpgbqY45XjybzPuoctOIb05BzPMGnXMKUsKGOQUzWD/OYk3ni+xtidhGZN3iqT+O1Poq4t9ZN9ZNTc6oJ7Fve3J+7Zkbsnxfe0Vuf+2ZJnxfe2ZpeL/27CJ1fu3VeP9rz97hkmljdXi/OUVq/mMjMc1hTSw/7vJ6NWLFYst6UYhwz3stWPNKAs/+YdsPXSeC6I/MxG+MZBoKpItGpK2tvz/OAXgxImGDPku8r89mds6h2TojNx5Gdqz2WuVYJxRJeNdzPhlJdD4RnQT5aqSaky1ri3jJRnbsSKy5Mfto75d/xVro8J4AJ2JFDDpPgBPzJizXCXBiLWR5T4ATKyDUdwKcbcJ1ApzdQto8RCAd0RABa0dWTXMVuWbaEK3yhQ2ZX+RVimHDXAibC9GJr8J7rKz9NGLtGlgSoDyh/9uI1VLrrJpTtN6v8Iu1ilXKPJuhFDpCIPmr98zA3D94roi/r15zyrauVXXRw8hM2iAA1mVabgHQclsAtG4QAPNQPZ8A2OfyuQTAbKnOemnWVVreemnWGpavXtoR79dLs9ZKfPVim7gvzOeX4tzWHTW+7bntsNop7TtKRzLqRXa0kLajhdw+vLWFDYe3tnD78FbbhLPnmivg8yPgXIqvb19ULZg3Pyodg3nQrVW/zZQNbcRax3K3EWshy9tG2o42ovfbiN5vI1a95Hmv7zmoKu9GVc0+EHBOWfGZrS8yZE3BF5nHiJ3jGAo9ya9uWLNeh6yRKi2SvBqxyyPMoYxUmkP/VR7mJ+9a9RE+UbccL0bMW5vnwct0/tdvE+3+aLdZk9be0W7f1Ht3tNusjVi+0a7th1eFrJ1YbhVK+bYKpbJBhcydWD4VsjdzeVTIbqneN5W5cuV/U+UdbSRvuGeg5dv3DLS84Z6Blm/fM2CbcLYRKwBlzlTxVT+/BNFes/J9p7bcdrSPDRNVrdyeqGplw0RVK7cnqmwTzvZhvXVrWosAarQQa2Hk/AZaFx/xCYK/jNQNzazs+KgqOz6qyv2Pqrrjo6re/6iqGz6qrAFiLTSUSW8HiNVcWp279PNRjDFVNdfwVhhOptl/fRkPmasZOg9AOQeLVKj6Mng3l6vW1Vgx8xxCfukz5t1Yzhg0+xXR1mE7fE7Ha+cV593X5oyItV7l7rzWepW781rrq87Oay00uTuvdS+Ws/OaJnzvCFPeY1jjTLFaSNvRQnbMqrYds6rt/qxq2zGr2u7Pqrbbs6ofxGxdKZl559ermLW64XPXmr1zfu6afrgb2Y6hqt4fquqOoareH6rq/aGquU+Zjg+NtKn212tXd8yo6o4ZVb0/o6o7ZlT1/oyq6t9W7o91mfq2ctVapyrr3MByUPj5S3Dlh1HmPEjxXHPXt6NMPczdJ7QD7q0aqrnRqq6rwTiQ/rU4NjRTPW43Uz02NFM9bjdT24SzmZrH7a87OZPVOqyYda8Gadgwn6rh9nyqhg3zqRpuz6faJnwfqZYG5XV1XZakb9eGbSMrXi5Lfh+5p3FDZLXGDZHVdnznmh+KtVrxnebeohl8/5jleWtEY95RJuXPy2RuhItyVCM7Ys+7z5m3ouFdIOInI3M/3Zku7a0R8xi1RLFq8X12rDWiUwDnIRQ/4irSqxHznBHXzj61Dg30beZRa6nKu4tN05aD2Gwz7u1nHxtKpYbybkO9ph2tzTLi21JvNxPfNmXNpsK6timruVzl2qZsmvBtU1Zzscq3TVmthSbfNmXNlrI6tyn7a+X9NuUPIuLapqzmlTm+bcq2ijjnZm0jzv3BphHv/mDbE+f+4E+i6NyT+0kUnZtp7Sw5N9PaRpybac2Xlm/np344cNezmda24dtMq9ailfP9W80e7NtMa/rhLVKzan2baT+0Ve9m2g9mvJtpP5nxbqb9sItm3dBQ39/sqdbilXcrjt4/NtAMCfZ+sZm7ec7x6hq6pqu7eZwz4GqtXZW6bmqrfOLfy2pt8K3V8I0z3+3mkRlHd35hGF/15j6aHUZCXV+Ole7D/c6IyDp5UKNhxFwVGI1Ecr1mQufGIh6Af2UiHPRlUt9Plqi1euU8ddAuU10b+jRa7cw8kWqWSGnt2i6pIIGCTwN/rKXDb6bWtdmq1vbOFTXP+nMdMvDBjaMuN/S9G1YbqUsDzrSWtyWi1gpW6OsozxoO/O57lSNr61ic04PnDNH7AEU1F6B8smhvHJvlen4y1ksm1nb4M5mvmfBkxN7P49R324hXms0VrB1G3PpuGnHq+/kxFe4KvG3Dp/C2Da/En1bu3yVkl6tT4+19MM6B0Zkdud1zQtvQc8KGRh8Oc8vVFivevvPBirvz2Etavs5j2fB2HvOwPHfnsRaknJ3nQ8F6e4+5GcX5/jxd0du9x96L4nmB2iZcL9APJnwZKRtkwDTi7sDxz634ZcC04paB2O7LgGXDKwPmtU9uGUhhgwyYBeuVgbxhO9mZn3y795grFt7eYxpxt/skf23F33tMK+7eY9ays/dYNry9x1zKcfceq5bdvccsWPdL1Bw8rhUh8uMlBPrMjTUkWGGy+cfd5fmbnVTubmyucPm6cdkwS2gbcXfAv7fi78amFXc3Lvl+N7ZseLuxeTeXuxtb27Lc3dgs2B3dWOdB+lqK0Y2tpaUSVox5pKMVf3Vjc7OLuxvX27Na9kYVbzc2jbg7YC1/bcXfjeuWsWzdMJatG8aydctYVnaMZeuOsax5QqquaASle6B+d2T7sFZdh7VS0//Vkc0tp+6ObC2FODtyPTZ05LplVkn0r634O7Jpxd2RW7zfkS0b3o5s2fB3ZGuFyN2RzYLd0ZFTmAWbzhUioyNbK0S5zc20+VQG442sOzryhuWZtmN5psUdXVDTX1vxd2TTirsj23u3fB3ZvGjS2ZEtG/6ObO28cndks2C9Hdl8racZRROS0DL8z4YfwmEGFczccAx5LV/YKDNoiyNIv7QxY/oKn0T1lY06L2SqdEbAdRvlqo26DoC9Wh51lke9XB4y8yKXy4NtXC2PdYOoXC4PmeUhl8ujzby0y+XBNq6WR5sK0uSyH/MMudau+qHHeEfo5fJgG5f9mCevq6FB9rEczqht24hzF0oI1imDoep6aRbTijUNO2+qzj/uy41fZMcZbN3sz1hfJLvtiTOS/cM5A66lTNOEbymz3Y9o0B2zuLpj/jWk+NdW3INN24p3sBlSuT3YNG04B5umDfdgM5j3UzkHm3bBegebuiMeKOT7gQC6Ix5oRxDcY6vLX1vx9x7Tirv3WAcPenuPZcPbeywb/t5jnTvo7j1mwbo/1cyzNso6SIUie1/P2jjzY52RFdbpo4FPMK6vRsyGQls5qWh/9eNi3ss2r8ngu7++MjH3DNbWrpqYhzocb734cHxJnJHsx4/vilc3rBmBMg+ny3xd1g0j+s6I+0SXdBxGKzOvy8rrSqac2vvs1GR9Rs+dujXwTVe/jNibDtd9WWdPb1vM8IF79ZvZFl3F8v4YQ/uEmTXJoeHtoP7MTbv7YWCfDuN8hdpG3C8/CX9txf8KlR1hBEHuhxGYNryvUNkRRhBkQxiBXbDuV6h5DtDcIH5+zC65/xVSG8w7s/I60DS+nzE1zyGsc5sr36v2ulPWPI7IPZhut7cd2kcJeZUg7IghCK3+tRW/ErS6Qwma3leCpveVoOkOJdC4QQnaju2H7pve8vub3s78WO/ztk5WaZkvnfjpiXkVmLsf6+0pJfsaL+/2Yd3RA+Nx/LUVdz+2rXj7cTzub5IxbTj7sWnD3Y/jsWGTjF2w3jf6sSOMJx73N8mEHWE8WzaHxRD/2oq/94QdE7Ix3J+QNW14e0/YMSEbw4YJWbtgd7wFzy/8efpTohvLf5+hYYnBOuA3H/X93Xznglf8ayu1lTmp1OTd+SYfbKwT/qpGuWhjTW5peW/DbLBzCkXj5UY/j6NVKfc7jmHD1rU0L/g6ZTJcNBLX1QvpsKRkx8Yu08i5VrKO48ntoiuYQntaaeWqFZpTSnrZl7IOGCq02fRbK3UdBNf0co6WtKVo5uh+DLdpw/vOSDtiuGP+82abpiqd645ytVCcumTacOqSs3JMG+aQ2pkX04YzL86hvWHD/vJyauyHb0CvxpYdjbVs0diyRWPLFo0tWzS2bNHYskVjywaNLRs0tmzR2PrnzdatsWWDxpYNGlvua6w9/ejLi23DlxfvNKhhw56ldmrsh/lyr8bu2NRlGvFrrGzRWNmisbJFY2WLxsoWjZUNGisbNFa2aGz782br1ljZoLGyQWNlg8aai71OjTVtODXWuehsaawZE+DVWDs6wauxuqOx6haN1S0aq1s0VrdorG7RWN2isbpBY3WDxuoOjU3Hnzdbt8bqBo3VDRqrGzTWjEl1aqxpw6mxzthYaz5WN2jshyBqp8amsKGxmkbcGvvBilNjbStejbWteDX2gxWnxn7IkVNjU7ivsaYNp8aaNvwaG/+82Xo11i4Uny7ZNny65K0cU9vS/TUv24ZTY9P9NS9zc5VbY8MOjd2x5pW2rHmlLWteacuaV9qy5pW2rHmlLWteacOaV9qw5pW2rHml/OfN1q2xG9a80oY1r3R/zevD5tN5mmGp5f1V26aJuRei8HUHr6ceWYNH5yU9H4z4LnH6cCyIr25tG7669R5PYtZt3PDOsc+x8b5zyoazikwj/neObcX7zillxzvHtOJ+59hWvO8cO0fed069f8SWacP7zqk7jthK9c+brfudYxaK851j2nC+c5yVY2pbu58X24ZTY9vtvNhH7Xk1tu6IZUuyo7HKFo2VLRorWzRWtmisbNFY2aKxG44xTBuOMUxbjjFM7c+brVtjN+hS2qBLqW3Q2Hr/G8W24dTYev8bxTyX2Kux9gnJXo3VHY1Vt2isbtFY3aKxukVjdYvG6g6Nzcd9jTVtODXWtOHW2Hz8ebP1aqxdKD5dsm34dMlbOaa2lftxFrYNp8aW23EW9hUOXo0tO+anc9jQWE0jbo39YMWpsbYVr8baVrwa+8GKU2M/5MirsXGDxsYNGhu3aGz882br1ti4QWPjBo2NGzTWvMbIqbGmDafGOq9TsjTWvO3Kq7H2vVtejU07GmvaorFpi8amLRqbtmhs2qKxaYvG5g0amzdobN6isfnPm61bY/MGjc0bNDZv0Ni4Ya4gbpgriPfnCtKGPRkfbgb1auyONa+8Zc0rb1nzylvWvPKWNa+8Zc0rb1nzyhvWvPKGNa+8Zc0r1z9vtm6N3bDmlTeseeX7a14f7it2xVnYJlxxFtGYKEj9PK5uIiU+/PLlip2TrdOLZnOna6hfzruz7/d2vm/C/X3W3nvGzbMsdsROhx2x01k2XCNjGvG/b2wr3veNacX9vjGtuN83thXv+8bOkfd90+7ffmTa8L5v2o7bj3L782brft+0+7Fftg3n+6bdjv0Kh7Xtx6uxpg2nxpo2fBp77IhjO3bEseUdV3WZRvwaq1s0VrdorG7RWN2isbpDY8txX2NNG06NNW24NbYcf95svRprF4pPl2wbPl3yVo55xs5xd0z/wYRnTK9y+0AN24SrPG0TvuJsG5YgbSNemS879nOZRtwy/8GKU+ZtK16Zt614Zf6DFafMf8iRV+bj/S0yJd7fImPa8Mt8+vNm65b5DVPKZcOUcrk/pSzW3eC1zLs36ZKAGMIXJrJOE/mtiWJNy/m8sE34vEjmtXuPG5whrz/6bihfGKk6D0eumi4aWbdFRz3KNSPnG2Jef3REIzvZOjb3mBNi55xaumbEd1StbcJ1Uu0HE56Dau16kXkI/uMGzYuV+8NIvmokLiPpfb2EYsU0pX6SxHPKNOQ3RfLBRppvvJSavLeR/tZGDjMvOYaL1TsvC4rC54B/VzPzpq4oelVF2JPLRtocf5/Jy0bmKMI2Yr2onPpumvDpu3WOuPazn5/v7fcaYpuYR9+fSX1n4rj/rjtuv+uyeYmGhHkNgGQ+g7x9YaTFaeRc3blqZL4wz2S9aqQsT2jl5ksj65O3laue6Gxk5Wxwl8tElxGjdqzD1nJZNy8VSTuMtItG6hwwn6uz+aqRee31uYBnFKx1n5XU+ZIQCcYdGsUulNlkz6zRxEYNX7niu86jNHOOxXOdR25m0J3vOg/biPcijvL3VtzXedhWvNd5lA3LWWXDclbZspxVdixn2QXrvM4jN9nRkc1Lutwdece9PP3K0psdWTfcy2MbcXdB6wW2x4q/I5tWvB25Wlc4OTuyacPZkU0b7o5crUP43R3ZLFhvR7bepeWYRsoR3w+6zvwY8nZ+OoyWUiIPIn8ZsSayZBZtFZrT/maUci7LzDEkz5f8g+zohuxYl8hsyU6YF3GfyYtjyHNad8xVlBTlopF1JfiZ3GGkhqtG2qxivjb6SyMyPxNiu1ywc8niTNarRtIykrPVYu/vZLFt+KbEvRJr2LDfgM6lug/vYudSXbVCGr0ybRpxL9V9sOJcqrOteJfqbCvepboPVpxLdR9y5Fyqq9bilnd0kcL90YV5hJx7dJH+vNl6l+rsQnHqUrofKeatHHO5b0MEX9kQwVfuR/DZ0wVejW07dgvWvKOx5i0am7dobN6isXmLxuYtGpu3aGzZoLFlg8aWLRpb/rzZujW2bNDYskFjy22NzdaB80lkLohKowmhFq8aaReNtGNUTWrhuGpkTiqllstVI7ktI3rZkzCN0J23XxqZMzln0vLE3I8ya+d8geSLRtIR1/srXTZyLCN5g5F41ZOo600a21VP0iqTohs8qUazt6/PdVbxh4t8fVX8wYivit1G4lVPvFVse+KsYrcnRhUnNcd+eQ4gY+F19Pzyxmj3419sG77YldrS39rwxb/YhZrmGzQmOaxCteZip0hXem+9zCbZfuQVQsNjm3/gR9swiWqteDknUe3slDjb6jkD+TY7H4zMqctYajOMWMsyJU8lKeW4ZsQXzWebcEXzfTDhieZLVkP1ReLYJlyROKmaC3+yNlq0NTI6ldFvQ445ry2HvrMRxJo6jfmYa3aZxfCXEevjJuv64CvRMGKdOTBLpCWakC7lCxtttvTGE/2/bVjHah5zR3k8P9WmlRxfjRjBWv1YfzhC5/b/A0esKNwwI5PS45drnTpfrRuJF1tJmq+Zs5XUi0Z6kP5Thyh69ZcRaxxRdG0v0qpXjcxgXNuI3XPaEvgcDE/S/UZv2fA2evPO3pBm6GmgjV+/Gn2wLlefL/B0WCbKhs5nHT7g7XzBGgKEHOaAhl6avzuf30q5aiWHUTk1UxDcbyvW0XXe2jGzo/P1G/RyduLUtRp5VuBLK22OJnhB9ksrqbRppVWraK0bC5uOHGn7cU/L8Y2VY85s66HHVSthhs8oTyd/aSXOUB49vxyvWkkz3liTWL4k86yauUNHy8GtLrxaMaMM15e9UNxK/cYTmaHPKj9abrhsRS9b0TV5quWilXAcM9T3TDfLjl3Tc/lBc2qXW11erY5isb+1klbEf7F6o//13t6/3s2zCuclUOeL/p3mfvhQmNJSJBiDJnO165i9OR+ZQ0bSN1bWjFTmyaR/YMUaJMisnSjZypBs+OCwZh29Yy/LhnfsVY4NYx5rGcQ75ilxxweHu26sDw67ldSl1i1fM5KCzAm2QKXyrZHjvpG0Bl+JXu1fGqlr3rIZRopu+H6yjTi/n8zs5NXacm0bjFxtbOeE8Nwzm5tRxZZQh7pepBKtLmi6InPCL0k11LHWDXVsG9lRxxLCP1pZ/e2JdUrLMRd2QgjlcsnqWlq1mptY0/5TqfNhVbFYQy6dnxynnlhfc5YneW44y9RM/kGRmC/0uQCRk2bjhW5dVOSeQZS64YUucv+FbtnwvtCtk2PcL3Rrj5f3hW6uUrlf6O66sTTWbCXeGUTTiHcG0bqdyy1sdqN3Tv61De21bWivbUd71Q3t1boN3D9foFvmC3TDfIFZsN5ZVeuSIue8nVmu7vkp04r7u9quY+9MgWnFPVdmWnHPldnl4p0r0y1zS7plbkm3zC3pprklu3y9s0J+xX4//mtHuzmf82HQlfMauYV0dS4mhxUIas3FNGsd7BwerHDfQH3xkFcr1rTBOYs/FKryVeevVuwcaRqqXcIRrRzlLTkqf52jEqaVErKZI/nTJlfyHOeXotVyxNoGHua3D58rdbwE1rR43H6p2n6k+g++fP6BH6Y0aVuh+weNeepXVlqam4xPfTsuWtH5zX+ma7hWKvPErqxm7dS/tXF+rOsS/RaMkq1bSrbuKNkPVnxtxe6Dlb46aE/E7z5oLtfImjsQGiCHEF+t3B/a2p6s+P9zUbhanphWMs2FpKtWZB4SE5Q/Pn5bkR2vDvP8Pe+rw8xRDHO3cYzxMHJkXfAWqqwtNPVcB39b0x+szDfzmaa9K7+sWDkqM/gvlh+nAf3KkXmKyAy9O2WJPkFeT91oVl8UmR/N51yQacUYJEie05LCAZ7/wIo1LVmm5gZjG02zVlxiWKdPxkMtK2bk7BwkWGd32Dbmt10NxbJhxqnMAXI6oqUJ1npYTW2GqmSKSFb5xkiPu4IRKZYRK8x7Lb6mg/aP5RherVgX4i5FUA5a/wdWrDbrPbWmFWtpoMyBQint3Snhdi2feZjLavGwFK6Y567KOhCTpwF+50d36EE9duhBDff1oMYdelDTfT0wbTj1wGyz/tqpW2pHNtRO21I7uqF29G/VOsU5UD+XUaPRj8W8ymQdYpWOZNSOeYuXu6VI3tFSrOkmb0uxFl78LcVa0fK2FNOGtx9b78E4vxhSzNV4g1nLYqHosUajRxLLTtjRVlrc0VbMjWDOttLyjrZiro0524q9vuZsK+au/TnJI7yE82vgZW0FW9sWE+2C/qVL1gJO6SEfKJAWjNsFm7U0dn77rREtz7/lbwajEuZYRypFH/wqE3NOfu1sO7+ayZXyOg1urY2VeY5HofPQ/4GNvGNYbC2O+YfFWncMi83ze53DYtMTtyxZ9xq5ZUmtCFinLKm1+8gtS2pt63LKkm3DKUtmm/W+wvQoW15heuxoK2qdf/hFW2kb2oruaCvm3i5nW7H3hznbirUra853NZ7YfNVItXZ2uT9vNeyY7tKwY7pLw/3pLg2ypZ20De1kw3SX+UauacWNqtVSrCuOzo+mFaX8I0byl5W4o73FHZ9hGnd8hmm8/xmmccdnmMb7n2G2jR1D61porJPeDiM1GQKZ1y1D+SjGsEvNcwfzPCL2cYH7ciW9GrHarK643oMmeh+TES9WzEMw1qlymScg8mv/sY5AjHXdJVVpkS+l8M2bo62lzxCMrpzqhhkVTbKjK6e2oysnvd+VrbUsf1fO4X5XNm34urIt+jGs4ahYLcVaDfO3lLxjllbzjllazbKhpbQtLUU3tJT7s7Qf5C2vGH0K4f4tbyVu+ExWax7Q+Zlse+JubWXLkLZsGNKWLUPasmFIW9qG1matCRzz1IPzizkar+S6Y4ZW644ZWq33Z2i17pih1Xp/hta2saOOf6z7VKuOzYsT5oFu5RCKCqlfDUY1zdqhgv09GBVr/8I8KLZxbPsvgbQ2ZZW5abXQdqpzHvrVxpYGKxsarGxpsLKhwcqOBmu1kjBPqMvJbiVthyjJlvnZtmF+tm2Zn20b5mfbhvlZS5SyzInVLEmNxWjTygrhy5KNcEI1797yhhOqtb1rTyR6XRe61CDmyQ2mlVVFP+8M+crKavu1HHrVSlrnTRb+9Hm1oubcm7uOrO/1TXVU5kpWrcHM0Ye1hTmd+LiVctqp31mZ0cpnmlbnflmxDmusM7hXjhqtHFnXLsa10+VHgEkqr1asPeS6LrQ9wtst/vEwF8Rcu79PG5bgxrCOsJX8dorotGLvGaDj5JWPB65f2Ql5BWCfvUHe2rEbr6SZK0n5feM9vbG2aPmOhjmN3N9Jfhq5vTPXtuHbmRuP4/7O3LNJ396Ze9rYsJP8i7oRq27MVuI6GsY24jwa5qOR474R34kfD9WyBk+0u6RcLFjnITWfjLgOqTmnBe4f8vnJiGuf/4fs5LmDIuUYDE/Sn3viOi7nCyNXO6DzuJx4RPuWT9dxOZ/avbOhuDvP5erxnXQTD/siLt9JN59ccZ10c7qS7o91rOUw70k3tifOk24+DmgrDWjfHfp/eiL3h8W2Fd+R/R+GszJnWM+k0WTNjV3ekVIO90dKlg3vSMnaGeYeKVnDWO9IKZcdIyV33Rhn7nz46Jkv9McXrFHBbYc6hvsL4x+srMm3MxkuWgnH2omY7S8wy5eS1nES9cZ3HO2WVq3Xv+NWKMX5TVcsO1aukq6y4QvWvyubLPPYm/zjuJnwxde2W/ft76djqUK71o3OCYjZeIP1aq8b5g6sFTH/+7TeLtdPNTxPpTgrO11t/eFYu/zDka/PYoRC4ya53ovCuv4w/BTv10UCK95/rm/TAkH+tTnS3nI918UeW67D24GGeW6ic+O2bcU5XDE3ibln1Jv9ig9rDi9d3vztDGKIh9jHOcwlj0pjp1+1bC36U+BNzMZNprYVmfsozvmz96svZ37+3Mr5UXesBteuWpE5t/84YMqw0sztuJ6LP20bvos/bRveiz9PK9ZHkO/izw8Fq+s4CI1Wg7MCSMvan19au7izPkigjUiBJ7BfT/Wyd+jXtUO/0reuvnZma6OY7z6nT44ca/mGhsm/HFFT95cknGl9fyLdaccq3XXe32ODAb3GXvXJPHIgrrPkYn6/SyUe5l4xp1LaBw7Mwj0/VOs1G3Xex3Ym80UbvryY27/dqm9aceu1ObLdYsWv+vaUhlP1g3mJmE/1TRtO1Q/2h51T9YM1k+dWfXsWwKv65n5p77ApWNvEvB2o5R0dyLTibfohhL+24u5AthV3BzI3izk7kGXD24HMgxzdHcia2vd2ILtg3R3I3KnsfZsGc1HL2YHsfcq+t6lpw/k2tW248mLvL/aKgW3F3Y3NfWJbrPjFwLTiFoOo98XAsuEVg6g7xMCM6/OKgVmwXjGwt26736apbOhAuqUD7RhIhtT+2oq/A5lW3B3IXB1zdiDLhrcD5bCjA9mHTjs7kFmw/rep+VVJp6nSJPbxmh1rcLA2ReVEU7W/jmWxd9e7u7K5ycvZlcOO+UTbirsTWhu09ljxd2XTirsr25vFfF3ZsuHtypYNf1e2tnm5u3KJf92Vdd7poqUYXdlaGSth7SmMdEvG765s7nZ2d+V6f8LL3qfs7sqmFXcnrPWvrfi7ct0yrK0bhrV1w7C2bhnWyo5hbd0yrLU2pEddQRHaotGZrd1e+Ziz1/nHvQn5q1NI3J1ZNnyjxrqjM+/5umzHX1vxd2bTirszWytj3s5s2fB2ZsuGvzNbu8bcndks2C2dOYVZsukcMhqd2TpBMbd5sEpWurLtd2fOZUdn1rDhzdy2vJm3fOlq/msr/s5sWnF3ZpX7ndmy4e3Mlg13Z45mBJu3M5sF6+7MZmR5mhE4IQkt2qfX/JhBCDM7vBGvli9slBk4xmGtX9qY4YWFjzD9ykY91o7YY4ONctVGXTcMXC2POsujXi4PmXmRy+XBNq6WB193dbU8ZJaHXC6PNvPSLpcH27haHm1KSJPLfszjh1u76kc/KRaqerk82MZlP+ZVP2po0Idj2pxx5B+seHfyRusz5fxAXO/NYlqxZmar/ANl/n3wiJkfZ+y3bcUbXf/BF2d0/aeTplwLnbYN30LnBxu+cWfZMrlbdkzuRvv+sB1W3ONO24p33BmTee6ca9xp2nCOO00b/nGndVKid9xpF6x73Fl3hA1FK37c24HqjrAh24q76efy11b8Hci04u5Aud3vQJYNbweybPg7kBXM6+5AZsH6P9zMc9bW8QAcEPx6ztqZIevg+rAOrg98GUZ9NWK2FNp0SmX7qytbIbQ1z2vZSrpoYu5qrK1dNTFP8TreevHp6Lo4w+CPH58ZL36Ye7HK3Kqda95iRN8Z8Z/nl47DaGfW2lfI61ZQvtz9d36sk5COuae4Btpx9NuI1VjPZj53Vp5Tlm2LGT6XqX41/aKrXKyTrs3TBde0h4a3g/wzP3r/Q0G2vElly5tU4l9b8b9JZUecQZT7cQamDe+bVHbEGUTZEGdgF6z/TWrue50b2c/P26X6vwJwoxUHn/I6+D6+n0a1TjpM8+STzFf7vmzi/XAOpXtc3e7vYrRPkHSrQdsRgRub/LUVvxq0HbsYo97fxWja8KqB7tjFGHXDLka7YN1RR+5bhvP7W4ZPq9b3elsHwrTMl5i9uGJeP+vuy7pha02NG/qybcXbC9OWmHzTirsv21a8fflsSrf7smnD2ZdNG+6+nI4NW2vsgnX3ZdkR6pPChq01siPUx7bibvoh/bUVfwcKO2ZpU7g/S2va8HagsGOWNoUNs7R2wW55GZ5f/PPMqlTC25fhh1M+1rUP+ed5vy+v1GQtiO2xUvvO9uckkbw9P8W2sY5Srhrloo0136XlvQ2zyc45FY2Xm/08M1Wl3O86Uq5KW5pXx54PC1etxHVbVzosOdmxH8w0EkJaRwbldtGVEGb9hNDKVSs0y5T0si9lHYJUaKPqt1bqOsCu6eUcLXlL0czR/Xhv04b3vZF2xHun/OfNNk1dCqnI1UJxKpNpw6lMzsoxbZgja2deTBvOvDhH+KbKml9gbpW1vwa9Klt2NNeyRWXLFpUtW1S2bFHZskVlyxaVLRtUtmxQ2bJFZeufN1u3ypYNKls2qGy5r7L2XKQvL7YNX168c6KWytpz1l6V/TB/7lXZHZvATCN+lZUtKitbVFa2qKxsUVnZorKyQWVlg8rKFpVtf95s3SorG1RWNqisbFBZc/3XqbKmDafKOtehTZU14wTcKmvHLHhVVnc0V92isrpFZXWLyuoWldUtKqtbVFY3qKxuUFndobL5+PNm61ZZ3aCyukFldYPKmvGqTpU1bThV1hk3a6ps3aKydYfK5rChuZpG3Cr7wYpTZW0rXpW1rXhV9oMVp8p+yJFTZXO4r7KmDafKmjb8Khv/vNl6VdYuFJ8y2TZ8yuStHFPd0v3VL9uGU2XT/dUve/uVW2XtrWBeld2x+pW3rH7lLatfecvqV96y+pW3rH7lLatfecPqV96w+pW3rH7l/OfN1q2yG1a/8obVr3x/9evTFtV5FmKpFAHy3TbXdRkjX6TwasPc+Ou8WOiTFecFVPZBIr76tW346td7oIlZv+aBM+43j334jffNUzaccWQa8b95bCveN49pxf3mMa243zy2Fe+bx86R981T7x/NZdrwvnnqjqO5cv3zZut+85iF4nzzmDacbx5n5Zjq1u7nxbbhVNmW7qts3BHd9uG8QK/Kyo7mKltUVraorGxRWdmisrJFZWWLym44ADFvOAAxbzkAMbc/b7Zuld2gTHmDMuW2QWXr/W8V24ZTZeuGbxXzWGP/WPbYobK6o7nqFpXVLSqrW1RWt6isblFZ3aGy5bivsqYNp8qaNtwqW44/b7ZelbULxadMtg2fMnkrx1S3cj/uwrbhVNmyIe4ibJmrDjvmqkvY0FxNI26V/WDFqbK2Fa/K2la8KvvBilNlP+TIq7Jxg8rGDSobt6hs/PNm61bZuEFl4waVjRtU1rwQyamypg2nyjovZjJV1rw4y62y9iVeXpVNO5pr2qKyaYvKpi0qm7aobNqismmLyuYNKps3qGzeorL5z5utW2XzBpXNG1Q2b1DZuGHGIG6YMYgbZgyOLTs1jh07NcqO1a+yZfWrbFn9KltWv8qW1a+yZfWrbFn9KhtWv8qG1a+yZfWr1D9vtm6V3bD6VTasfpX7q1+f7kB2xV18sOGKu2jWfrgUdBRISnxY5ss1PbFYuyzmJXx0m2Z+ORrPvjnc+dIJ9zdhe28wN6u27Qip/nDbvfel0zbcRGMa8b90bCvel45pxf3SMa24Xzq2Fe9Lx86R96XT7l+gZNrwvnTajguUiv55s3W/dNr9YDDbhvOl024Hg8Vg7Qfyqqxpw6mypg3vURc7AttsK16VrTvu+zKNuFX2gxWnytpWvCprW/Gq7AcrTpX9kCOnytbjvsqaNpwqa9pwq2wNf95svSprF4pPmWwbPmXyVo6pTNbHjndob9vwDO3j0e4fuWHb8JWpbcNZpnnHoqRtxa32O/Z7mUb8ah93bKCxrbjVPu7YQPPBilft444NNDXe30BTnbOY5aoffrVPf95s3Wq/YYq5bphirhummFs0z4TVdZHf4xK8aad+Y+X8pS4rVCr1tYqN/KQ0O09KTS7ZyOFx2DiaSQzyPjdxS5nEHWVirzVpO8iXa1acpSLWQQqqZTZZbTQuqOErK6vRaovvrbTDbLXHvIziTNOr4zs7vuN2P9hwHbf7yYbnuN0gaUv9pB31I6ltqR/TjrN+bBu++vlgw1c/1qby2k9xh40UuETyV1bmSPK0Ut9aScm6xy/Pc7NjDmt4Xo8XTbGu7wpZ11CHzp3/bcS6Z3FemdXS8uO094WNNm/FbTVYNqxD54+5jnDO/axifbkQ4zRizHn3qRo4Qps3/4EjxVrQmF9f6fHLd/X7Rd3I27qxG0ma74wf9+p+ZaPEea9AScloI0aTL7o+JrXqVSPzxhPLSDJvW3U1VvvE36bDhrYfO3yPL4zENDU6lqtG1leT8pV33xkJdV2NzSr/XXbmhQ9nzuJ7I2ZQm0Sdg+H6/r31hRG9akTX0F7fv/k+lEleZVKqUbCmzLd1GzV9pP/qONZRh3yx/VtdTNG6GU5l3lqpLIzpVRitBcUft3hmQwVa2fDOavX+O8uy4X1ntbbhndX0/jvLXoT3vrPcdSNW3VitROclq+H8iHtvxLruy/mu+OTJnH6JB39y/fLEGg3MGs6HWTv2t5LrZnvbkxzm5X90B+E/aLDZbLDHarDtWrnGc6ZwGmnvx65izfo7y1XsO6BKm01NwvtWb3riK1dTX1uYp4a00NJbfbXfWs6vxw9GfB+PphH/t+NZsvL3dpxX8tg2fFfyfLDh+wa1VmVkrew0Q2HvfzmKefmT8y0sVqiT8y1s2nC+hcXa5+J9C4tVM863sIS24S3srxu51kZ8H46mCed3o1gTsN7vxg9GfGMBuf3ZeGz4ajw2fKodG77UdMOHmtuGXrTh/EzTHa8Ys1S9X+I75hV2TCvoH+fF21I3zCmUdr+l+m3oRRu+llq2TMjvmJWwRxC+SQnJ+e6khGEgH7OtnyMavjnydWhobeFKcb7pzq+p/HZYZ9rwLXqKdb6db3nPKo+ka3X9oCL9XR7FnHZel66WQL3/kFcr1lX1Nc6BTOWzFF+smPvinBPg1ng7zoWWSIEcLwViWpjDy8oBGK8WzH1Bc7UnFL4m9eVSUbso4iqKmN7aOCvFvL08tjo/d6Pqm0ZmrmXL/MZ8nNdIjewLG2cxHJQdGlCdDe5nfqwVEm/XNW04u655X5er61paGGUdGip00/GLhXK3pZsWXC3dyoW3pZs23C3diql2t3QzUu+Yn0BnmjzJfhtlFmosxbBh9haRGfBUGkWy/O4t1lVF3t5i2nD2FmujlrO3+EskpLclYr6izvfL+tbOVDdXbbT7Nmp6b8NaJQrz0+FsqjSoa9FvI9Y8bVS5aEOnjVSP9zasYcy6x/5M1os21vAjJrlvI8e3NsSo23rMZbN6aHhrw9r96q1b04azbm0bvro1IyNqpWFh2GCjXLQxl5jOpFyzIWuuTkq8ZqPN1ZRzOeNieZwDhukHLaZct9Eu5uUY7SO1cLF9tDS1sOWLddtyWzb0qh+zfbR6tW4lTRuiF/ucrDGIVbf2wcBzcjvRu/JLG8eyke/biOmqBq3dE7Fd9COt8ih63w9LC+MGXY8bdD1u0PWwQdfDBl0PG3Q9bND1sEHXrWi3o82lj0PrpfFHSTrK40wa4yBzfDrHMImXpl/Hp7FZMa/eJbYWzY/1Y1Zv4m0bv1yJVrxqkWFFitLkwy8j5pdQW19CvN4nr0asiNUV6XKKYzSMWF/M4chrBxZvzvmdIbNsy2z2ic7QiF9a0VVD+r6xmJ93dR0IEmq0PnhbbDcnmD84Mk08HGmGI+bikMwpjSMo1fJLR7Y+mnMYE0Rn8r0jlo2S5vJB4Rp+tdHMe3aWKNVWr9lYUVWP5d23NuyqyWluGKw5X7Yye/GZVqNMbk8yt9uTzFYI4OkvbTHS422IS8vm+vJc5j5X7eSajTiHmxpjuzTFnObmvDNNQ+ev6lZo+eBcq1Cj8+Z8e9rMtuGbNmvmUYP3p81+lki8Xq5tWUkXe56smdEzTcPO37VT7i8B2DactVPi39bOjxKR43LtCFkJb61YNxT7FM204FtMsHJyzuvOMOBzaClWC2l3l1ZsG6csrreNVJrI/86KzGCmM13DVStL6YUna75oay2uIUlLRh82z9AJp2DNefj2Y0P3N2bOD9AZKJYOHnmWi0ZCvGikzNjXWKh+vjJyZmEeZ3f8+F56NSL3189NIyWU0VJKbCwF3xhJMwqnpChvjcRmfYh6ddq04dRpub+J2i6Q+T1ccihWgVirrceMSaxHUcuKdUbLnGKsNOP6Sx9tR+b0T+UP8y+zs84SOT+awmUrc/G3ctTY11batKLJaPbW7EueM9ElW0as041871HbhOtFambFuyxvG/Guyzdry5R3XT6YN3IcM4g+/+w65dWVdl+RTBtORTLPGXQqkhV+JmtaTCJ3vm+M1DX/IzG9NXLmxgw9d0aPNc0b3n7JlIG1Vb9YjtQt2dnxMrcC0c6v+jnW4uXo8BJKcrpiHc+yJhxJ1CR/4UffYvYc8/34bns1oht0wL6/eg6n9ceiw6tE20ZmsaocetlImkZ4aevViDVxck7jTpnmcNaUXk5ts64oPydfZmTuae+9ETsQfb7MtXHkw1dl0lbBKk2dvhqJ5u0ie6z82G/IISUvpfLBygpMiZG+AX9bCdGeqVsTdfGqlTXPfjaqfNVKnnuWTnkrlhVrW6nzVK8Pl9HU+Zme2vvCDcWs5/mZfn5thXdz/qHeH7PV+2O2smPMVnaM2dQ8A8ur1daRUd6d/2qudDn3HKp5koFvz6Fpw7nnUK0dZd4FUbWWuJx7DtU6gc6959BfN++D9e1G4tz4r+n+Zr9gjT9xZgPqptIJkK/b7W0jsmJ/z9Z/zYh347/tSUlru061jFhHOxy6Bn5nmo+t+sZMyHm9/zLHrHxpJuRlJhuHk5klk3QVL5/E9VXx5jXDnH/s23s1Yk5Mec4QMLuP82gG24bzZAbN90+80GzOFDhPZjA98ZaqWbszBuCs6HSx84Qj0WmUPDD/rtWHVSrnTNTlPhjW/pvwU/O/GeaUOVL6Ebb+1UhpzvfV/NbEp6Hw9OMc/l0eUOe52+McNoUdw3LDyocvpzkU1kZxGr+/ecr9+S3bhm9+SzdssDJtOOfI7EKdreQs32oUqnXEYK7LEQnvT1ixrZydeL676mG12PohOmlaSXrVSitrlbVc9kXnhpx4HOGiFe/kxQdfVtxXkGblSI4dn+ly7PhMl2PHZ7q59OX9TLcLdwV/tBAuF4tXsu1i8Uq2u4osyba+kZ1zzT0Q8PZcs1o3Hbjnms1v5DKHxVIDrwkmv5EW8jzSKsV80UiZddzKj1WJ1zput2O4PjgyD3tv5Ufw5C9H7h82YNtwvlDb7cMGQjSPO5rH+zS+YuR39bbbk22mCd9km5UV92SbacQ92WZ+73sn28qGYzZVvacvWJNtevvYJNuGd7JN7+8+SId1zJ9vsu20EXZMtrnrxphsK/dP2Tyzk+9Ptln3DLkn20wj3sm2suGUTdsT72SbeVKHf7LNNOOfbPtgxjvZVuqGyTbTiHeyrdyfFir3z0G1bfgm29JhHTvom2w7bbT7k222J95SrRsm2+zm6p5ss824J9s+mPFOtpnDHN9kmz1S8ky2BetkSd93TjrsgZLvO+e00jZ85wRzOD63AqdTt2kMW74wIjMcLemPzWqvRtr9letwO2rfNuEbTJta4h1Mm0acg+l0pB3RhsmcZaCg/SDvqzeZ50yvHU2a+YM6fmMkk0qni0akrfO7fmyqeC1Z83xndx+2gpXcfdg8MKrKuqKrSnhfyUZ+shxrXjfptaLNKzvn6NEs2rqlaLeEHB7WyHwesBhrrUbTt4yU+eaKVfJbI+nYcSrhaWXDqYShmqE56yDwMx3e3iwnW5bBzRMwc127goW337yeXGse2iSrmiUbX4Ll/nTBaWTDKcvl9nTBaWPHdEHdMF1QN0wXfFE3YtWN2UrmBGgU62OlmDdjyTrrTOWykeO+ESkrZr4ajb6Kc/qjXCzYRDHZ5wDyqpG6JpabYcRaCnEetv7JiO+SLjs7eb7TEy/K/PYk/bknqweey3AbjFztgOfagUwjzWj2YkbvryOkJZqyJBsairvzXK6ecxV+dmNLlZp5W4nQh36xXhqmK7rOP7NainU2hnc2x761yDub0+4HpH0YKaW6Rkrl3XrX6YjYVjJZaZeseG/PvR/DnA69f+PmaeT2jZu2De84Se/fuJkOvX3j5mljw42bX9SNsawi92OYT0fa/WUV2RHDLDtimGVHDLPsiGGWPTHMsif4WHYEH8uO4GO5r/WyIfhY7gcfJ3PDtPMNGsKGa+FsT7yluiP4WPYEH8ue4GPZE3z8YdpvbZes7w9TSfY8c+1Xhk8r5ZIV59jCDFR3zh2GbF5jFtZ1lel94HCwZg6lzs8Mkfg+UDaFaJ4Tt45PqBxW+rJwZk0c8nZL2oUao35hRGaQ7DnNdbw1cuam/rWVUNccZqXZui+tiKzwVo2WFWNoLvMIPuGFnq9s0EWRpV20EY44lyP46MrfVqw9X87Q1g8Fq2sdQaPR3qzDdEubhVIazcOo+G2cy0yrUM40y/7hN1NrWEvG9D2qr/3Yvv7GtWZs+zGvmzz9UMMPq53UpQZnWo0bxexN9uuOtaB8GHZ9USbrZO+zdcwLwSKJ9WOm6sWVeFsizSmUMov2/Jasl0ysVeMzma+ZcGWkyQatN424VTq3v7bi1/rcdmi9terl1XrLhlfrS9ih9SVv0HqzYJ1aH60Tc/wjpXK790T3wRTZyo3uaPf1+Gsr/t5jWnH3HmvHi7f3WDa8vcfceePuPdbFBe7eYxast/fEY8dL1Dwk39d7zNuBXS9R24TrJfrBhC8jdYMM7PnUkfLXVvwyYFpxy4C0+zJg2fDKgLQdMmCteLllwCxYrwxYQVP+l6i15OXsPVYsjbv3mEbc7X7PQLbJjt5jWnH3Hmtlxdt7LBve3mOu8Lh7j6YNvccsWG/vsWYeS13rRORHef0ktjYT5TTXzvKPayHyy75T6/vc343NdS9fNzYPwPN2Y9OItwNGa6/XHivubmxb8XbjaG33cnZj04azG5s23N04Wgc5e7uxXbA7urHOrbQ/7kN57cbRWm0qYR47XiIdwfCrG1tzde5uHMP9sWwtG7px3TEKjeHPrfi7cdgxljWbm7cbh/tjWdOGvxvHDWNZu2C93dhcf9MVo6B08sjvjmydpJePOUWdAx/0+9qRc9vRka2PQWdHtib93B25bHmTRv1rK/6ObFpxd2Rr3cvbkS0b3o5s2fB35FQ2dGSzYHd0ZCzcdCPngDUYHTlZYQFtXi6WT2V435GtcGp/R7aWvZwd2YoRcndk04i7C+Y/t+LvyPaFS96ObDU4b0e2bHg7srn5zN2Rs27oyGbBejuyufMlzbCac5mbluPTiyfm3V4z7DdTBZ8rxF/YKDOOiwNLv7QxI/0K37z4lY06b4r4cWHMZRvlqo1ZHvVyedRZHvVyeaybM+RyebCNq+XBd5VeLY910ZlcLo8289IulwfbuFoebSpIk8t+yBDE1q76ofPOcr1cHmzjsh9z17YaGhTNTY3OWG7bSJxBRTEasdwpmkHy676Mx7WHlhXzME75B7qcUvwiO84QbNOIN77d9sQZ3x6txSHnUqZpwreUKfdncduOWdy2ZRb37634B5umFfdgs5X7g03Lhnew2cqOwaZ5lKF3sGkWrHew2XbEA0VrX5a39+yIB2pbZks0/7UVf+8xrbh7j3mkobP3WDa8vUdlQ+9J1pmG7t5jH1rp/VSzTiyJa0M+x/dGja/5sfbPhnnQzjmJw6OtVyPe8zOpaF/7cTqs6+fmqVCVT5b6ysTcSljpmt8vTYyOI8dbL6K12F2OOCPajx/fFa9uWDMCZe6Nznyy1A0j+s7Ih1Y2h1mPjmG0sg+XBczjnHJq77NjnqV2zF28NfDBUr+MWE2Vj6c6pyfbFjN0sPevwjVnW9bd45n6jf46vt01yaHh7aD+zE27/WGgO16huuMVmmL4ayvuV6htxfsKTfF+GIFpw/kKNW34X6FxQxiBXbDuV6h5rOncNn5+zC65/xVSm6wDu9I8tj3T3RSvM6YpmedszZ2vkWdNXjfjpw2D6ZRub0NMx4aoWtuIuw+nP7fiV4K0YxtiSve3IZo2vEqQdmxDTHnDNkS7YL3bEK3txHFtQ0y84fvXUYTJshLaOnil5UZ68tMT2RGIkPKGLWYbAhFsI+4euGVTsmnF34/Ljk0y/cqWu/243N8kY9rw9+OyYZOMXbDefqxbek+5v0nm2BHGsyUgNtX411b8vafumJBN9f6ErGnD23vqjgnZftjg7d5T4x+/BVOayyFnBwlv34L2yRzHWv4/ajRepdaK1x4rtZU5qdTk7ZEnto11em3VKBdtrMktLe9tmA12TqFovNzo55GkKuV+xzFs2LqW5pHnp0yGi0bijBY77VlSsmNjl2kk9AOdn5NBuV10JYRZOyG0ctUKzSklvexLWWcOFdps+q2Vus6HoyPVvs3RkrZzVcqycj+G27ThfWe0HTHcSf+82aapSiEVuVooTl0ybTh1yVk5pg1zSO3Mi2nDmRfn0N6wYX95OTX2wzegU2PzsaGxmkbcGvvBilNjbStejbWteDX2gxWnxn7IkVNj+xWiNzXWtOHUWNOGW2Nz+PNm69VYu1B8umTb8OmSt3JMbTOnH50aa9pwaqxzGtSyYc5SOzX2w3y5V2N3bOoyjfg1Nm7R2LhFY+MWjY1bNDZu0di4QWPjBo2NWzQ2/XmzdWts3KCxcYPGxg0aay72OjXWtOHUWOeiszVXYMYEeOcK7OgEr8bmHY01b9HYvEVj8xaNzVs0Nm/R2LxFY/MGjc0bNDZv0djy583WrbF5g8bmDRqb72usHZPqy4ttw5cXb2yspbFth8a2LRpbdzTWukVj6xaNrVs0tm7R2LpFY+sWja0bNLZu0Ni6RWPlz5utW2PrBo2tGzS2btDYdn/Ny7bh1Nh2f83L3Bbl1ti4Q2N3rHnlLWteecuaV96y5pW3rHnlLWteecuaV96w5pU3rHnlLWteWf+82bo1dsOaV96w5pXvr3l92Hw6TzMslWI+vtq/um435FsPXk89sgaPznt7PhjxXe304VgQ5zvHtOF85ziPJzHrNm1459jn2DjfOeXYcFaRacT9zvlgxfnOsa143zm2Fe8754MV5zvnQ46c75wS7h+xZdpwvnNMG+53Tgl/3my97xy7UHy6ZNvw6ZK3ckxtS/fzYttwamy6nRf7qD2vxpYdcRYl7miscYvGxi0aG7dobNyisXGLxsYtGrvhGMOy4RjDsuUYw5L+vNm6NXaDLpUNulTSBo0N979RbBtOjQ33v1HMc4m9GmufkOzV2LyjseYtGpu3aGzeorF5i8bmLRqbt2hs2aCxZYPGli0aW/682bo1tmzQ2LJBY8sGjT3ux1nYNpwae9yPs8g75qfzjvnpUnc01rpFY+sWja1bNLZu0di6RWPrFo2VDRorGzRWtmis/HmzdWusbNBY2aCxcl9j7WuMfHmxbfjy4r1OydJY87Yrr8ba9255NbbtaKxti8a2LRrbtmhs26KxbYvGti0aqxs0VjdorG7RWP3zZuvWWN2gsbpBY3WDxsr9uQLbhlNj5f5cQdywJ+PDzaBOja071rzqljWvumXNq25Z86pb1rzqljWvumXNq25Y86ob1rzqljWvGv682Xo1tm5Y86ob1rzq/TWvD/cVu+IsbBOuOAurbs8h7iiNlPjwy5crdlI/1fxte5/Nna6hfjkizr7f2/m+qff3WXvvGTfPstgRO33siJ2uccM1MqYR//vGtuJ935hW3O8b04r7fWNb8b5v7Bx53zfp/u1Hpg3v+ybtuP2opj9vtu73Tbof+2XbcL5v0u3YrxSsmAKvxpo2nBpr2nCeZSH3NdY24tbYHVd1mUb8Gpu3aGzeorF5i8bmLRqbt2hs2aCxZYPGli0aW/682bo1tmzQ2LJBY8ttjQ1V7o7pP5jwjOlTiPdP1LBtOJU+3j5RI5gnvXqV3jTiVvodW7pMI36llx27ZGwrbqWXHbtkPljxKr3s2CVT5f4umSr3d8mYNvxK3/682bqVfsOsct0wq1zvzyqHYEhbLfP6TbonIIbwhYms00Q2TBz3vThue3FYQR7lsSUJ8vqj74byhZGq83zkqumikXVhdNSjXDNyviHmDUhHfJ+d2KzdrumYk2LnvFq6aMV3Xu0HG67zaj/Z8JxXa9eNzLPwHxdpXqzgH0byVSNxGUnvqyaJdZBbitrmzGnIb4rkg40033opNXlvI/2tjRxmXnIMF6t33hkUhY8D/65m5oVdUfSqkrAnl420OQw/k5eNzJGEaURvv2j09nvm9NWKdemLCM9Xt6Ehto15Av6Z1Dc2rBkbX1mYFlxl0awLcSTMqwAk8znkzW+jxWmjpXDRxnxfnsl60UZZftDSzXc21idvKxf90Nm6ytnSrpaHLhvv60WMSKpc1rVLRdIGG+2ajToHyrnS7c7f2ZgXXmcx2pjY97G2ubAXjMszxDq/LpfZUs+M0YxGDd944rvGQ6yLuXzXeMiGW+1kx6V2Yl3MtceK+xIP24r3Eg/ZsIglGxaxZMsiluxYxLIL1nmJhxnv5+7E5s1czk78wRNnJ875bifWcr8Tmzbc3c+6lWuPFX8nNq24O7E11ertxOW434nNy6Pcndg6dt/dic2CdXZi621ejmmjHPH9KOvMjnU1bJyXGZfIY8ZfRqwhtMySrUIz2F+MTcpR55iR50b+QW50Q27q8be5CfPe7TN5bdRY+uXCsJGiXLOx7v8+kxts1HDRRpu1yzdEf2dD5hdBbFfLdC5MnMl60UZaNnK2Wur9HSu2Dd+8t1dYDRu6YeO17th3Leb3jVeaJW9YjftgxbkaZ1vxrsbZVryrcR+sOFfjPuTIuRon1vqVd0TRwv0RhXlQnHtE0f682XpX4+xCcapSux8P5q0c08aGOD3ZEKcn9+P0ZEP4sOyIHhbd0VR1i8LqFoXVLQqrWxRWtyis7lDYdtxXWNOGU2FNG26FbcefN1uvwtqF4lMl24ZPlbyVY9iwTqI+30dzsfN8v61JlxYv2mjXbPSqh40Wjos25gRSarlctJHbsqFX/QjTBt1o+52NOWlzJg0/zDM6Zr2cL458zUY64nprpas2jmUj37cRL/oRdb09Y7voR1rlUfS+H/V9Wy/lft2Wcr9uP9hw1a3bRrzoh7NubT98dev2w6hbc/I45jlSjIXXw/PLuyHdD2OxbfhCUFpKf2vDF8Zilmmar8qY5LDK1JpnnaJc6R31MmVkupFXHAyPYf6BG+3+BGmz1rGcE6RmbkqcDfWcYHybG9vGnJiMpb4vkShWGGsseUpIKcdFK86gPNuGLyjvgw1PUJ51gJsvoMa04AqoSbeDetLtoJ5iBQRrmaNsbeHt6qZtY42ytcW3NqK5zhqOY8aPnGn61v3OjreNmjacbdS24WmjyQwbmwFGGinA6JyZ/8JGWuFrRd7b0PttxLbhbSNpUxtJG9pI2tBG0rU28n+c8M//5V//4z//23/9L//8P/71v/77fz9/978epv7jX//5//y3f3ni//0///2/0F//x//vv42//J//8a//9m//+v/5z//tP/7rf/mX/+t//se/PCw9/vZPx/N//vd4LnTpfzr/N+n/8Z/+KZ3/5WzQJZ7pgD8/Ttt5/K88/lPAL86h1+N/y//xvx5O/v8B",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "12213818982551431636": {
            "error_kind": "string",
            "string": "Only signers can propose"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17808964010404909636": {
            "error_kind": "string",
            "string": "Address is already a signer"
          },
          "2616280824898961740": {
            "error_kind": "string",
            "string": "Maximum signers reached"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9932853091537900381": {
            "error_kind": "string",
            "string": "Invalid signer address"
          }
        },
        "parameters": [
          {
            "name": "new_signer",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgIEAScCAwQAHwoAAgADAEUtCEUBJQAAAEUlAAAAcC0CAUYnAgIERicCAwQBOw4AAwACLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQDJiUAADnOHgIAAgAeAgADADMqAAIAAwAEJwICAQEkAgAEAAAAmSUAADn0HgIAAwEKIgNDBBYKBAUcCgUGAAQqBgMFJwIDAQAKKgQDBiQCAAYAAADMJwIHBAA8BgcBJwIEAAAtCAEGJwIHBAQACAEHAScDBgQBACIGAgctCgcILQ4ECAAiCAIILQ4ECAAiCAIILQ4ECCsCAAcAAAAAAAAAAAIAAAAAAAAAAC0IAQgnAgkEBQAIAQkBJwMIBAEAIggCCS0KCQotDgQKACIKAgotDgQKACIKAgotDgQKACIKAgotDgcKLQgBCQAAAQIBLQ4GCS0IAQYAAAECAS0OCAYtCAEKAAABAgEnAgsEAC0OCwotCAEMAAABAgEtDgMMJwINAAEnAg4EASQCAAMAAAHqIwAAAaMtCAEPJwIQBAQACAEQAScDDwQBACIPAhAtChARLQ4NEQAiEQIRLQ4EEQAiEQIRLQ4EES0ODwktDggGLQ4OCi0OAwwjAAACdi0KCwgjAAAB8wwiCEQPJAIADwAAOUgjAAACBS0LCQgtCwYPLQsMEC0LDxEAIhECES0OEQ8tCAERJwISBAUACAESAScDEQQBACIPAhInAhMEBAAiEQIUPw8AEgAULQIIAycABAQEJQAAOgYtCAUPACoPDhItDg0SLQ4PCS0OEQYtDg4KLQ4QDCMAAAJ2LQsJCC0LBg8tCwwQCioQAxEkAgARAAACmCcCEgQAPAYSAScCEAQCJAIAAwAAAtojAAACqi0CCAMnAAQEBCUAADoGLQgFEQAqERASLQ4FEi0OEQktDg8GLQ4QCi0OAwwjAAADZi0KCwgjAAAC4wwiCEQPJAIADwAAOMIjAAAC9S0LCQgtCwYPLQsMES0LDxIAIhICEi0OEg8tCAESJwITBAUACAETAScDEgQBACIPAhMnAhQEBAAiEgIVPw8AEwAVLQIIAycABAQEJQAAOgYtCAUPACoPDhMtDgUTLQ4PCS0OEgYtDg4KLQ4RDCMAAANmLQsMDwoqDwMRJAIAEQAAA4AnAhIEADwGEgEtCgsIIwAAA4kMIghEDyQCAA8AADg8IwAAA5stCwkILQsGDy0LChEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0OCAktDhIGLQ4RCi0OAgwAKhIOCC0LCAYKKgYECAoqCAMJJAIACQAABAwlAAA6ai8KAAYACBwKCAkBHAoJBgAcCgYIASQCAAgAAAQuJQAAOnwKKgEEBgoqBgMIJAIACAAABEUlAAA6ji0IAQYnAggEBAAIAQgBJwMGBAEAIgYCCC0KCAktDgQJACIJAgktDgQJACIJAgktDgQJLQgBCCcCCQQFAAgBCQEnAwgEAQAiCAIJLQoJCi0OBAoAIgoCCi0OBAoAIgoCCi0OBAoAIgoCCi0OBwotCAEJAAABAgEtDgYJLQgBBgAAAQIBLQ4IBi0IAQoAAAECAS0OCwotCAEMAAABAgEtDgMMJAIAAwAABTojAAAE8y0IAQ8nAhEEBAAIAREBJwMPBAEAIg8CES0KERItDg0SACISAhItDgQSACISAhItDgQSLQ4PCS0OCAYtDg4KLQ4DDCMAAAXGLQoLCCMAAAVDDCIIRA8kAgAPAAA3tiMAAAVVLQsJCC0LBg8tCwwRLQsPEgAiEgISLQ4SDy0IARInAhMEBQAIARMBJwMSBAEAIg8CEycCFAQEACISAhU/DwATABUtAggDJwAEBAQlAAA6Bi0IBQ8AKg8OEy0ODRMtDg8JLQ4SBi0ODgotDhEMIwAABcYtCwkILQsGDy0LDBEKKhEDEiQCABIAAAXoJwITBAA8BhMBJAIAAwAABiUjAAAF9S0CCAMnAAQEBCUAADoGLQgFEQAqERASLQ4BEi0OEQktDg8GLQ4QCi0OAwwjAAAGsS0KCwgjAAAGLgwiCEQPJAIADwAANzAjAAAGQC0LCQgtCwYPLQsMES0LDxIAIhICEi0OEg8tCAESJwITBAUACAETAScDEgQBACIPAhMnAhQEBAAiEgIVPw8AEwAVLQIIAycABAQEJQAAOgYtCAUPACoPDhMtDgETLQ4PCS0OEgYtDg4KLQ4RDCMAAAaxLQsMDwoqDwMRJAIAEQAABssnAhIEADwGEgEtCgsIIwAABtQMIghEDyQCAA8AADaqIwAABuYtCwkILQsGDy0LChEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0OCAktDhIGLQ4RCi0OAgwAKhIOCC0LCAYKKgYECAoqCAMJJAIACQAAB1clAAA6ai8KAAYACBwKCAkBHAoJBgAcCgYIAQoqCAMGJAIABgAAB34lAAA6oCcCBgADLwoABgAIHAoICQIcCgkGABwKBggCJwIGAhQMKggGCSQCAAkAAAevJQAAOrInAgYADy8KAAYACC0IAQknAgoEBAAIAQoBJwMJBAEAIgkCCi0KCgwtDgQMACIMAgwtDgQMACIMAgwtDgQMLQgBCicCDAQFAAgBDAEnAwoEAQAiCgIMLQoMDy0OBA8AIg8CDy0OBA8AIg8CDy0OBA8AIg8CDy0OBw8tCAEMAAABAgEtDgkMLQgBCQAAAQIBLQ4KCS0IAQ8AAAECAS0OCw8tCAERAAABAgEtDgMRJwISAAUkAgADAAAItCMAAAhtLQgBEycCFAQEAAgBFAEnAxMEAQAiEwIULQoUFS0OEhUAIhUCFS0OBBUAIhUCFS0OBBUtDhMMLQ4KCS0ODg8tDgMRIwAACUAtCgsKIwAACL0MIgpEEyQCABMAADYkIwAACM8tCwwKLQsJEy0LERQtCxMVACIVAhUtDhUTLQgBFScCFgQFAAgBFgEnAxUEAQAiEwIWJwIXBAQAIhUCGD8PABYAGC0CCgMnAAQEBCUAADoGLQgFEwAqEw4WLQ4SFi0OEwwtDhUJLQ4ODy0OFBEjAAAJQC0LDAotCwkSLQsREwoqEwMUJAIAFAAACWInAhUEADwGFQEkAgADAAAJnyMAAAlvLQIKAycABAQEJQAAOgYtCAUTACoTEBQtDggULQ4TDC0OEgktDhAPLQ4DESMAAAorLQoLCiMAAAmoDCIKRBIkAgASAAA1niMAAAm6LQsMCi0LCRItCxETLQsSFAAiFAIULQ4UEi0IARQnAhUEBQAIARUBJwMUBAEAIhICFScCFgQEACIUAhc/DwAVABctAgoDJwAEBAQlAAA6Bi0IBRIAKhIOFS0OCBUtDhIMLQ4UCS0ODg8tDhMRIwAACistCxESCioSAxMkAgATAAAKRScCFAQAPAYUAS0KCwojAAAKTgwiCkQSJAIAEgAANRgjAAAKYC0LDAotCwkSLQsPEy0LEhQAIhQCFC0OFBItCAEUJwIVBAUACAEVAScDFAQBACISAhUnAhYEBAAiFAIXPw8AFQAXLQ4KDC0OFAktDhMPLQ4CEQAqFA4KLQsKCQoqCQQKCioKAwwkAgAMAAAK0SUAADpqMAoADQAJLQgBCScCCgQEAAgBCgEnAwkEAQAiCQIKLQoKDC0OBAwAIgwCDC0OBAwAIgwCDC0OBAwtCAEKJwIMBAUACAEMAScDCgQBACIKAgwtCgwPLQ4EDwAiDwIPLQ4EDwAiDwIPLQ4EDwAiDwIPLQ4HDy0IAQwAAAECAS0OCQwtCAEJAAABAgEtDgoJLQgBDwAAAQIBLQ4LDy0IAREAAAECAS0OAxEnAhIABiQCAAMAAAvRIwAAC4otCAETJwIUBAQACAEUAScDEwQBACITAhQtChQVLQ4SFQAiFQIVLQ4EFQAiFQIVLQ4EFS0OEwwtDgoJLQ4ODy0OAxEjAAAMXS0KCwojAAAL2gwiCkQTJAIAEwAANJIjAAAL7C0LDAotCwkTLQsRFC0LExUAIhUCFS0OFRMtCAEVJwIWBAUACAEWAScDFQQBACITAhYnAhcEBAAiFQIYPw8AFgAYLQIKAycABAQEJQAAOgYtCAUTACoTDhYtDhIWLQ4TDC0OFQktDg4PLQ4UESMAAAxdLQsMCi0LCRItCxETCioTAxQkAgAUAAAMfycCFQQAPAYVASQCAAMAAAy8IwAADIwtAgoDJwAEBAQlAAA6Bi0IBRMAKhMQFC0OCBQtDhMMLQ4SCS0OEA8tDgMRIwAADUgtCgsKIwAADMUMIgpEEiQCABIAADQMIwAADNctCwwKLQsJEi0LERMtCxIUACIUAhQtDhQSLQgBFCcCFQQFAAgBFQEnAxQEAQAiEgIVJwIWBAQAIhQCFz8PABUAFy0CCgMnAAQEBCUAADoGLQgFEgAqEg4VLQ4IFS0OEgwtDhQJLQ4ODy0OExEjAAANSC0LERIKKhIDEyQCABMAAA1iJwIUBAA8BhQBLQoLCiMAAA1rDCIKRBIkAgASAAAzhiMAAA19LQsMCi0LCRItCw8TLQsSFAAiFAIULQ4UEi0IARQnAhUEBQAIARUBJwMUBAEAIhICFScCFgQEACIUAhc/DwAVABctDgoMLQ4UCS0OEw8tDgIRACoUDgotCwoJCioJBAoKKgoDDCQCAAwAAA3uJQAAOmowCgAFAAktCAEFJwIJBAQACAEJAScDBQQBACIFAgktCgkKLQ4ECgAiCgIKLQ4ECgAiCgIKLQ4ECi0IAQknAgoEBQAIAQoBJwMJBAEAIgkCCi0KCgwtDgQMACIMAgwtDgQMACIMAgwtDgQMACIMAgwtDgcMLQgBCgAAAQIBLQ4FCi0IAQUAAAECAS0OCQUtCAEMAAABAgEtDgsMLQgBDwAAAQIBLQ4DDycCEQAHJAIAAwAADu4jAAAOpy0IARInAhMEBAAIARMBJwMSBAEAIhICEy0KExQtDhEUACIUAhQtDgQUACIUAhQtDgQULQ4SCi0OCQUtDg4MLQ4DDyMAAA96LQoLCSMAAA73DCIJRBIkAgASAAAzACMAAA8JLQsKCS0LBRItCw8TLQsSFAAiFAIULQ4UEi0IARQnAhUEBQAIARUBJwMUBAEAIhICFScCFgQEACIUAhc/DwAVABctAgkDJwAEBAQlAAA6Bi0IBRIAKhIOFS0OERUtDhIKLQ4UBS0ODgwtDhMPIwAAD3otCwoJLQsFES0LDxIKKhIDEyQCABMAAA+cJwIUBAA8BhQBJAIAAwAAD9kjAAAPqS0CCQMnAAQEBCUAADoGLQgFEgAqEhATLQ4IEy0OEgotDhEFLQ4QDC0OAw8jAAAQZS0KCwkjAAAP4gwiCUQRJAIAEQAAMnojAAAP9C0LCgktCwURLQsPEi0LERMAIhMCEy0OExEtCAETJwIUBAUACAEUAScDEwQBACIRAhQnAhUEBAAiEwIWPw8AFAAWLQIJAycABAQEJQAAOgYtCAURACoRDhQtDggULQ4RCi0OEwUtDg4MLQ4SDyMAABBlLQsPEQoqEQMSJAIAEgAAEH8nAhMEADwGEwEtCgsJIwAAEIgMIglEESQCABEAADH0IwAAEJotCwoJLQsFES0LDBItCxETACITAhMtDhMRLQgBEycCFAQFAAgBFAEnAxMEAQAiEQIUJwIVBAQAIhMCFj8PABQAFi0OCQotDhMFLQ4SDC0OAg8AKhMOCS0LCQUKKgUECQoqCQMKJAIACgAAEQslAAA6ajAKAAEABS0IAQEnAgUEBAAIAQUBJwMBBAEAIgECBS0KBQktDgQJACIJAgktDgQJACIJAgktDgQJLQgBBScCCQQFAAgBCQEnAwUEAQAiBQIJLQoJCi0OBAoAIgoCCi0OBAoAIgoCCi0OBAoAIgoCCi0OBwotCAEJAAABAgEtDgEJLQgBAQAAAQIBLQ4FAS0IAQoAAAECAS0OCwotCAEMAAABAgEtDgMMJwIPAAgkAgADAAASCyMAABHELQgBEScCEgQEAAgBEgEnAxEEAQAiEQISLQoSEy0ODxMAIhMCEy0OBBMAIhMCEy0OBBMtDhEJLQ4FAS0ODgotDgMMIwAAEpctCgsFIwAAEhQMIgVEESQCABEAADFuIwAAEiYtCwkFLQsBES0LDBItCxETACITAhMtDhMRLQgBEycCFAQFAAgBFAEnAxMEAQAiEQIUJwIVBAQAIhMCFj8PABQAFi0CBQMnAAQEBCUAADoGLQgFEQAqEQ4ULQ4PFC0OEQktDhMBLQ4OCi0OEgwjAAASly0LCQUtCwEPLQsMEQoqEQMSJAIAEgAAErknAhMEADwGEwEkAgADAAAS9iMAABLGLQIFAycABAQEJQAAOgYtCAURACoREBItDggSLQ4RCS0ODwEtDhAKLQ4DDCMAABOCLQoLBSMAABL/DCIFRA8kAgAPAAAw6CMAABMRLQsJBS0LAQ8tCwwRLQsPEgAiEgISLQ4SDy0IARInAhMEBQAIARMBJwMSBAEAIg8CEycCFAQEACISAhU/DwATABUtAgUDJwAEBAQlAAA6Bi0IBQ8AKg8OEy0OCBMtDg8JLQ4SAS0ODgotDhEMIwAAE4ItCwwPCioPAxEkAgARAAATnCcCEgQAPAYSAS0KCwUjAAATpQwiBUQPJAIADwAAMGIjAAATty0LCQUtCwEPLQsKES0LDxIAIhICEi0OEg8tCAESJwITBAUACAETAScDEgQBACIPAhMnAhQEBAAiEgIVPw8AEwAVLQ4FCS0OEgEtDhEKLQ4CDAAqEg4FLQsFAQoqAQQFCioFAwkkAgAJAAAUKCUAADpqMAoABAABLQgBAScCBQQEAAgBBQEnAwEEAQAiAQIFLQoFCS0OBAkAIgkCCS0OBAkAIgkCCS0OBAktCAEFJwIJBAUACAEJAScDBQQBACIFAgktCgkKLQ4ECgAiCgIKLQ4ECgAiCgIKLQ4ECgAiCgIKLQ4HCi0IAQkAAAECAS0OAQktCAEBAAABAgEtDgUBLQgBCgAAAQIBLQ4LCi0IAQwAAAECAS0OAwwnAg8ACSQCAAMAABUoIwAAFOEtCAERJwISBAQACAESAScDEQQBACIRAhItChITLQ4PEwAiEwITLQ4EEwAiEwITLQ4EEy0OEQktDgUBLQ4OCi0OAwwjAAAVtC0KCwUjAAAVMQwiBUQRJAIAEQAAL9wjAAAVQy0LCQUtCwERLQsMEi0LERMAIhMCEy0OExEtCAETJwIUBAUACAEUAScDEwQBACIRAhQnAhUEBAAiEwIWPw8AFAAWLQIFAycABAQEJQAAOgYtCAURACoRDhQtDg8ULQ4RCS0OEwEtDg4KLQ4SDCMAABW0LQsJBS0LAQ8tCwwRCioRAxIkAgASAAAV1icCEwQAPAYTASQCAAMAABYTIwAAFeMtAgUDJwAEBAQlAAA6Bi0IBREAKhEQEi0OCBItDhEJLQ4PAS0OEAotDgMMIwAAFp8tCgsFIwAAFhwMIgVEDyQCAA8AAC9WIwAAFi4tCwkFLQsBDy0LDBEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0CBQMnAAQEBCUAADoGLQgFDwAqDw4TLQ4IEy0ODwktDhIBLQ4OCi0OEQwjAAAWny0LDA8KKg8DESQCABEAABa5JwISBAA8BhIBLQoLBSMAABbCDCIFRA8kAgAPAAAu0CMAABbULQsJBS0LAQ8tCwoRLQsPEgAiEgISLQ4SDy0IARInAhMEBQAIARMBJwMSBAEAIg8CEycCFAQEACISAhU/DwATABUtDgUJLQ4SAS0OEQotDgIMACoSDgUtCwUBCioBBAUKKgUDCSQCAAkAABdFJQAAOmowCgAEAAEtCAEBJwIFBAQACAEFAScDAQQBACIBAgUtCgUJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4ECS0IAQUnAgkEBQAIAQkBJwMFBAEAIgUCCS0KCQotDgQKACIKAgotDgQKACIKAgotDgQKACIKAgotDgcKLQgBCQAAAQIBLQ4BCS0IAQEAAAECAS0OBQEtCAEKAAABAgEtDgsKLQgBDAAAAQIBLQ4DDCcCDwAKJAIAAwAAGEUjAAAX/i0IAREnAhIEBAAIARIBJwMRBAEAIhECEi0KEhMtDg8TACITAhMtDgQTACITAhMtDgQTLQ4RCS0OBQEtDg4KLQ4DDCMAABjRLQoLBSMAABhODCIFRBEkAgARAAAuSiMAABhgLQsJBS0LAREtCwwSLQsREwAiEwITLQ4TES0IARMnAhQEBQAIARQBJwMTBAEAIhECFCcCFQQEACITAhY/DwAUABYtAgUDJwAEBAQlAAA6Bi0IBREAKhEOFC0ODxQtDhEJLQ4TAS0ODgotDhIMIwAAGNEtCwkFLQsBDy0LDBEKKhEDEiQCABIAABjzJwITBAA8BhMBJAIAAwAAGTAjAAAZAC0CBQMnAAQEBCUAADoGLQgFEQAqERASLQ4IEi0OEQktDg8BLQ4QCi0OAwwjAAAZvC0KCwUjAAAZOQwiBUQPJAIADwAALcQjAAAZSy0LCQUtCwEPLQsMES0LDxIAIhICEi0OEg8tCAESJwITBAUACAETAScDEgQBACIPAhMnAhQEBAAiEgIVPw8AEwAVLQIFAycABAQEJQAAOgYtCAUPACoPDhMtDggTLQ4PCS0OEgEtDg4KLQ4RDCMAABm8LQsMDwoqDwMRJAIAEQAAGdYnAhIEADwGEgEtCgsFIwAAGd8MIgVEDyQCAA8AAC0+IwAAGfEtCwkFLQsBDy0LChEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0OBQktDhIBLQ4RCi0OAgwAKhIOBS0LBQEKKgEEBQoqBQMJJAIACQAAGmIlAAA6ajAKAAQAAS0IAQEnAgUEBAAIAQUBJwMBBAEAIgECBS0KBQktDgQJACIJAgktDgQJACIJAgktDgQJLQgBBScCCQQFAAgBCQEnAwUEAQAiBQIJLQoJCi0OBAoAIgoCCi0OBAoAIgoCCi0OBAoAIgoCCi0OBwotCAEJAAABAgEtDgEJLQgBAQAAAQIBLQ4FAS0IAQoAAAECAS0OCwotCAEMAAABAgEtDgMMJwIPAAskAgADAAAbYiMAABsbLQgBEScCEgQEAAgBEgEnAxEEAQAiEQISLQoSEy0ODxMAIhMCEy0OBBMAIhMCEy0OBBMtDhEJLQ4FAS0ODgotDgMMIwAAG+4tCgsFIwAAG2sMIgVEESQCABEAACy4IwAAG30tCwkFLQsBES0LDBItCxETACITAhMtDhMRLQgBEycCFAQFAAgBFAEnAxMEAQAiEQIUJwIVBAQAIhMCFj8PABQAFi0CBQMnAAQEBCUAADoGLQgFEQAqEQ4ULQ4PFC0OEQktDhMBLQ4OCi0OEgwjAAAb7i0LCQUtCwEPLQsMEQoqEQMSJAIAEgAAHBAnAhMEADwGEwEkAgADAAAcTSMAABwdLQIFAycABAQEJQAAOgYtCAURACoREBItDggSLQ4RCS0ODwEtDhAKLQ4DDCMAABzZLQoLBSMAABxWDCIFRA8kAgAPAAAsMiMAABxoLQsJBS0LAQ8tCwwRLQsPEgAiEgISLQ4SDy0IARInAhMEBQAIARMBJwMSBAEAIg8CEycCFAQEACISAhU/DwATABUtAgUDJwAEBAQlAAA6Bi0IBQ8AKg8OEy0OCBMtDg8JLQ4SAS0ODgotDhEMIwAAHNktCwwPCioPAxEkAgARAAAc8ycCEgQAPAYSAS0KCwUjAAAc/AwiBUQPJAIADwAAK6wjAAAdDi0LCQUtCwEPLQsKES0LDxIAIhICEi0OEg8tCAESJwITBAUACAETAScDEgQBACIPAhMnAhQEBAAiEgIVPw8AEwAVLQ4FCS0OEgEtDhEKLQ4CDAAqEg4FLQsFAQoqAQQFCioFAwkkAgAJAAAdfyUAADpqMAoABAABLQgBAScCBQQEAAgBBQEnAwEEAQAiAQIFLQoFCS0OBAkAIgkCCS0OBAkAIgkCCS0OBAktCAEFJwIJBAUACAEJAScDBQQBACIFAgktCgkKLQ4ECgAiCgIKLQ4ECgAiCgIKLQ4ECgAiCgIKLQ4HCi0IAQkAAAECAS0OAQktCAEBAAABAgEtDgUBLQgBCgAAAQIBLQ4LCi0IAQwAAAECAS0OAwwnAg8ADCQCAAMAAB5/IwAAHjgtCAERJwISBAQACAESAScDEQQBACIRAhItChITLQ4PEwAiEwITLQ4EEwAiEwITLQ4EEy0OEQktDgUBLQ4OCi0OAwwjAAAfCy0KCwUjAAAeiAwiBUQRJAIAEQAAKyYjAAAemi0LCQUtCwERLQsMEi0LERMAIhMCEy0OExEtCAETJwIUBAUACAEUAScDEwQBACIRAhQnAhUEBAAiEwIWPw8AFAAWLQIFAycABAQEJQAAOgYtCAURACoRDhQtDg8ULQ4RCS0OEwEtDg4KLQ4SDCMAAB8LLQsJBS0LAQ8tCwwRCioRAxIkAgASAAAfLScCEwQAPAYTASQCAAMAAB9qIwAAHzotAgUDJwAEBAQlAAA6Bi0IBREAKhEQEi0OCBItDhEJLQ4PAS0OEAotDgMMIwAAH/YtCgsFIwAAH3MMIgVEDyQCAA8AACqgIwAAH4UtCwkFLQsBDy0LDBEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0CBQMnAAQEBCUAADoGLQgFDwAqDw4TLQ4IEy0ODwktDhIBLQ4OCi0OEQwjAAAf9i0LDA8KKg8DESQCABEAACAQJwISBAA8BhIBLQoLBSMAACAZDCIFRA8kAgAPAAAqGiMAACArLQsJBS0LAQ8tCwoRLQsPEgAiEgISLQ4SDy0IARInAhMEBQAIARMBJwMSBAEAIg8CEycCFAQEACISAhU/DwATABUtDgUJLQ4SAS0OEQotDgIMACoSDgUtCwUBCioBBAUKKgUDCSQCAAkAACCcJQAAOmowCgAEAAEtCAEBJwIFBAQACAEFAScDAQQBACIBAgUtCgUJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4ECS0IAQUnAgkEBQAIAQkBJwMFBAEAIgUCCS0KCQotDgQKACIKAgotDgQKACIKAgotDgQKACIKAgotDgcKLQgBCQAAAQIBLQ4BCS0IAQEAAAECAS0OBQEtCAEKAAABAgEtDgsKLQgBDAAAAQIBLQ4DDCcCDwANJAIAAwAAIZwjAAAhVS0IAREnAhIEBAAIARIBJwMRBAEAIhECEi0KEhMtDg8TACITAhMtDgQTACITAhMtDgQTLQ4RCS0OBQEtDg4KLQ4DDCMAACIoLQoLBSMAACGlDCIFRBEkAgARAAAplCMAACG3LQsJBS0LAREtCwwSLQsREwAiEwITLQ4TES0IARMnAhQEBQAIARQBJwMTBAEAIhECFCcCFQQEACITAhY/DwAUABYtAgUDJwAEBAQlAAA6Bi0IBREAKhEOFC0ODxQtDhEJLQ4TAS0ODgotDhIMIwAAIigtCwkFLQsBDy0LDBEKKhEDEiQCABIAACJKJwITBAA8BhMBJAIAAwAAIocjAAAiVy0CBQMnAAQEBCUAADoGLQgFEQAqERASLQ4IEi0OEQktDg8BLQ4QCi0OAwwjAAAjEy0KCwUjAAAikAwiBUQPJAIADwAAKQ4jAAAioi0LCQUtCwEPLQsMES0LDxIAIhICEi0OEg8tCAESJwITBAUACAETAScDEgQBACIPAhMnAhQEBAAiEgIVPw8AEwAVLQIFAycABAQEJQAAOgYtCAUPACoPDhMtDggTLQ4PCS0OEgEtDg4KLQ4RDCMAACMTLQsMDwoqDwMRJAIAEQAAIy0nAhIEADwGEgEtCgsFIwAAIzYMIgVEDyQCAA8AACiIIwAAI0gtCwkFLQsBDy0LChEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0OBQktDhIBLQ4RCi0OAgwAKhIOBS0LBQEKKgEEBQoqBQMJJAIACQAAI7klAAA6ajAKAAQAAS0IAQEnAgUEBAAIAQUBJwMBBAEAIgECBS0KBQktDgQJACIJAgktDgQJACIJAgktDgQJLQgBBScCCQQFAAgBCQEnAwUEAQAiBQIJLQoJCi0OBAoAIgoCCi0OBAoAIgoCCi0OBAoAIgoCCi0OBwotCAEHAAABAgEtDgEHLQgBAQAAAQIBLQ4FAS0IAQkAAAECAS0OCwktCAEKAAABAgEtDgMKJwIMAA4kAgADAAAkuSMAACRyLQgBDycCEQQEAAgBEQEnAw8EAQAiDwIRLQoREi0ODBIAIhICEi0OBBIAIhICEi0OBBItDg8HLQ4FAS0ODgktDgMKIwAAJUUtCgsFIwAAJMIMIgVEDyQCAA8AACgCIwAAJNQtCwcFLQsBDy0LChEtCw8SACISAhItDhIPLQgBEicCEwQFAAgBEwEnAxIEAQAiDwITJwIUBAQAIhICFT8PABMAFS0CBQMnAAQEBCUAADoGLQgFDwAqDw4TLQ4MEy0ODwctDhIBLQ4OCS0OEQojAAAlRS0LBwUtCwEMLQsKDwoqDwMRJAIAEQAAJWcnAhIEADwGEgEkAgADAAAlpCMAACV0LQIFAycABAQEJQAAOgYtCAUPACoPEBEtDggRLQ4PBy0ODAEtDhAJLQ4DCiMAACYwLQoLBSMAACWtDCIFRAwkAgAMAAAnfCMAACW/LQsHBS0LAQwtCwoPLQsMEAAiEAIQLQ4QDC0IARAnAhEEBQAIAREBJwMQBAEAIgwCEScCEgQEACIQAhM/DwARABMtAgUDJwAEBAQlAAA6Bi0IBQwAKgwOES0OCBEtDgwHLQ4QAS0ODgktDg8KIwAAJjAtCwoMCioMAw8kAgAPAAAmSicCEAQAPAYQAS0KCwUjAAAmUwwiBUQLJAIACwAAJvYjAAAmZS0LBwUtCwELLQsJDC0LCw8AIg8CDy0ODwstCAEPJwIQBAUACAEQAScDDwQBACILAhAnAhEEBAAiDwISPw8AEAASLQ4FBy0ODwEtDgwJLQ4CCgAqDw4CLQsCAQoqAQQCCioCAwQkAgAEAAAm1iUAADpqHgIAAgUcCgIDADAKAAMAAQAqCA0BMAoAAQAGLQoIASYtCwcLLQsBDC0LCQ8tCwoQDCoFDxEkAgARAAAnGCMAACduACIMAhIAKhIFEy0LExEAIgsCEwAqEwUULQsUEgAqERITLQIMAycABAQFJQAAOgYtCAURACIRAhIAKhIFFC0OExQtDgsHLQ4RAS0ODwktDhAKIwAAJ24AKgUOCy0KCwUjAAAmUy0LBwwtCwEPLQsJEC0LChEMKgUQEiQCABIAACeeIwAAJ/QAIg8CEwAqEwUULQsUEgAiDAIUACoUBRUtCxUTACoSExQtAg8DJwAEBAUlAAA6Bi0IBRIAIhICEwAqEwUVLQ4UFS0ODActDhIBLQ4QCS0OEQojAAAn9AAqBQ4MLQoMBSMAACWtLQsHDy0LAREtCwkSLQsKEwwqBRIUJAIAFAAAKCQjAAAoegAiEQIVACoVBRYtCxYUACIPAhYAKhYFFy0LFxUAKhQVFi0CEQMnAAQEBSUAADoGLQgFFAAiFAIVACoVBRctDhYXLQ4PBy0OFAEtDhIJLQ4TCiMAACh6ACoFDg8tCg8FIwAAJMItCwkPLQsBES0LChItCwwTDCoFEhQkAgAUAAAoqiMAACkAACIRAhUAKhUFFi0LFhQAIg8CFgAqFgUXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUFFy0OFhctDg8JLQ4UAS0OEgotDhMMIwAAKQAAKgUODy0KDwUjAAAjNi0LCQ8tCwERLQsKEi0LDBMMKgUSFCQCABQAACkwIwAAKYYAIhECFQAqFQUWLQsWFAAiDwIWACoWBRctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQUXLQ4WFy0ODwktDhQBLQ4SCi0OEwwjAAAphgAqBQ4PLQoPBSMAACKQLQsJES0LARItCwoTLQsMFAwqBRMVJAIAFQAAKbYjAAAqDAAiEgIWACoWBRctCxcVACIRAhcAKhcFGC0LGBYAKhUWFy0CEgMnAAQEBSUAADoGLQgFFQAiFQIWACoWBRgtDhcYLQ4RCS0OFQEtDhMKLQ4UDCMAACoMACoFDhEtChEFIwAAIaUtCwkPLQsBES0LChItCwwTDCoFEhQkAgAUAAAqPCMAACqSACIRAhUAKhUFFi0LFhQAIg8CFgAqFgUXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUFFy0OFhctDg8JLQ4UAS0OEgotDhMMIwAAKpIAKgUODy0KDwUjAAAgGS0LCQ8tCwERLQsKEi0LDBMMKgUSFCQCABQAACrCIwAAKxgAIhECFQAqFQUWLQsWFAAiDwIWACoWBRctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQUXLQ4WFy0ODwktDhQBLQ4SCi0OEwwjAAArGAAqBQ4PLQoPBSMAAB9zLQsJES0LARItCwoTLQsMFAwqBRMVJAIAFQAAK0gjAAArngAiEgIWACoWBRctCxcVACIRAhcAKhcFGC0LGBYAKhUWFy0CEgMnAAQEBSUAADoGLQgFFQAiFQIWACoWBRgtDhcYLQ4RCS0OFQEtDhMKLQ4UDCMAACueACoFDhEtChEFIwAAHogtCwkPLQsBES0LChItCwwTDCoFEhQkAgAUAAArziMAACwkACIRAhUAKhUFFi0LFhQAIg8CFgAqFgUXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUFFy0OFhctDg8JLQ4UAS0OEgotDhMMIwAALCQAKgUODy0KDwUjAAAc/C0LCQ8tCwERLQsKEi0LDBMMKgUSFCQCABQAACxUIwAALKoAIhECFQAqFQUWLQsWFAAiDwIWACoWBRctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQUXLQ4WFy0ODwktDhQBLQ4SCi0OEwwjAAAsqgAqBQ4PLQoPBSMAABxWLQsJES0LARItCwoTLQsMFAwqBRMVJAIAFQAALNojAAAtMAAiEgIWACoWBRctCxcVACIRAhcAKhcFGC0LGBYAKhUWFy0CEgMnAAQEBSUAADoGLQgFFQAiFQIWACoWBRgtDhcYLQ4RCS0OFQEtDhMKLQ4UDCMAAC0wACoFDhEtChEFIwAAG2stCwkPLQsBES0LChItCwwTDCoFEhQkAgAUAAAtYCMAAC22ACIRAhUAKhUFFi0LFhQAIg8CFgAqFgUXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUFFy0OFhctDg8JLQ4UAS0OEgotDhMMIwAALbYAKgUODy0KDwUjAAAZ3y0LCQ8tCwERLQsKEi0LDBMMKgUSFCQCABQAAC3mIwAALjwAIhECFQAqFQUWLQsWFAAiDwIWACoWBRctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQUXLQ4WFy0ODwktDhQBLQ4SCi0OEwwjAAAuPAAqBQ4PLQoPBSMAABk5LQsJES0LARItCwoTLQsMFAwqBRMVJAIAFQAALmwjAAAuwgAiEgIWACoWBRctCxcVACIRAhcAKhcFGC0LGBYAKhUWFy0CEgMnAAQEBSUAADoGLQgFFQAiFQIWACoWBRgtDhcYLQ4RCS0OFQEtDhMKLQ4UDCMAAC7CACoFDhEtChEFIwAAGE4tCwkPLQsBES0LChItCwwTDCoFEhQkAgAUAAAu8iMAAC9IACIRAhUAKhUFFi0LFhQAIg8CFgAqFgUXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUFFy0OFhctDg8JLQ4UAS0OEgotDhMMIwAAL0gAKgUODy0KDwUjAAAWwi0LCQ8tCwERLQsKEi0LDBMMKgUSFCQCABQAAC94IwAAL84AIhECFQAqFQUWLQsWFAAiDwIWACoWBRctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQUXLQ4WFy0ODwktDhQBLQ4SCi0OEwwjAAAvzgAqBQ4PLQoPBSMAABYcLQsJES0LARItCwoTLQsMFAwqBRMVJAIAFQAAL/4jAAAwVAAiEgIWACoWBRctCxcVACIRAhcAKhcFGC0LGBYAKhUWFy0CEgMnAAQEBSUAADoGLQgFFQAiFQIWACoWBRgtDhcYLQ4RCS0OFQEtDhMKLQ4UDCMAADBUACoFDhEtChEFIwAAFTEtCwkPLQsBES0LChItCwwTDCoFEhQkAgAUAAAwhCMAADDaACIRAhUAKhUFFi0LFhQAIg8CFgAqFgUXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUFFy0OFhctDg8JLQ4UAS0OEgotDhMMIwAAMNoAKgUODy0KDwUjAAATpS0LCQ8tCwERLQsKEi0LDBMMKgUSFCQCABQAADEKIwAAMWAAIhECFQAqFQUWLQsWFAAiDwIWACoWBRctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQUXLQ4WFy0ODwktDhQBLQ4SCi0OEwwjAAAxYAAqBQ4PLQoPBSMAABL/LQsJES0LARItCwoTLQsMFAwqBRMVJAIAFQAAMZAjAAAx5gAiEgIWACoWBRctCxcVACIRAhcAKhcFGC0LGBYAKhUWFy0CEgMnAAQEBSUAADoGLQgFFQAiFQIWACoWBRgtDhcYLQ4RCS0OFQEtDhMKLQ4UDCMAADHmACoFDhEtChEFIwAAEhQtCwoRLQsFEi0LDBMtCw8UDCoJExUkAgAVAAAyFiMAADJsACISAhYAKhYJFy0LFxUAIhECFwAqFwkYLQsYFgAqFRYXLQISAycABAQFJQAAOgYtCAUVACIVAhYAKhYJGC0OFxgtDhEKLQ4VBS0OEwwtDhQPIwAAMmwAKgkOES0KEQkjAAAQiC0LChEtCwUSLQsMEy0LDxQMKgkTFSQCABUAADKcIwAAMvIAIhICFgAqFgkXLQsXFQAiEQIXACoXCRgtCxgWACoVFhctAhIDJwAEBAUlAAA6Bi0IBRUAIhUCFgAqFgkYLQ4XGC0OEQotDhUFLQ4TDC0OFA8jAAAy8gAqCQ4RLQoRCSMAAA/iLQsKEi0LBRMtCwwULQsPFQwqCRQWJAIAFgAAMyIjAAAzeAAiEwIXACoXCRgtCxgWACISAhgAKhgJGS0LGRcAKhYXGC0CEwMnAAQEBSUAADoGLQgFFgAiFgIXACoXCRktDhgZLQ4SCi0OFgUtDhQMLQ4VDyMAADN4ACoJDhItChIJIwAADvctCwwSLQsJEy0LDxQtCxEVDCoKFBYkAgAWAAAzqCMAADP+ACITAhcAKhcKGC0LGBYAIhICGAAqGAoZLQsZFwAqFhcYLQITAycABAQFJQAAOgYtCAUWACIWAhcAKhcKGS0OGBktDhIMLQ4WCS0OFA8tDhURIwAAM/4AKgoOEi0KEgojAAANay0LDBItCwkTLQsPFC0LERUMKgoUFiQCABYAADQuIwAANIQAIhMCFwAqFwoYLQsYFgAiEgIYACoYChktCxkXACoWFxgtAhMDJwAEBAUlAAA6Bi0IBRYAIhYCFwAqFwoZLQ4YGS0OEgwtDhYJLQ4UDy0OFREjAAA0hAAqCg4SLQoSCiMAAAzFLQsMEy0LCRQtCw8VLQsRFgwqChUXJAIAFwAANLQjAAA1CgAiFAIYACoYChktCxkXACITAhkAKhkKGi0LGhgAKhcYGS0CFAMnAAQEBSUAADoGLQgFFwAiFwIYACoYChotDhkaLQ4TDC0OFwktDhUPLQ4WESMAADUKACoKDhMtChMKIwAAC9otCwwSLQsJEy0LDxQtCxEVDCoKFBYkAgAWAAA1OiMAADWQACITAhcAKhcKGC0LGBYAIhICGAAqGAoZLQsZFwAqFhcYLQITAycABAQFJQAAOgYtCAUWACIWAhcAKhcKGS0OGBktDhIMLQ4WCS0OFA8tDhURIwAANZAAKgoOEi0KEgojAAAKTi0LDBItCwkTLQsPFC0LERUMKgoUFiQCABYAADXAIwAANhYAIhMCFwAqFwoYLQsYFgAiEgIYACoYChktCxkXACoWFxgtAhMDJwAEBAUlAAA6Bi0IBRYAIhYCFwAqFwoZLQ4YGS0OEgwtDhYJLQ4UDy0OFREjAAA2FgAqCg4SLQoSCiMAAAmoLQsMEy0LCRQtCw8VLQsRFgwqChUXJAIAFwAANkYjAAA2nAAiFAIYACoYChktCxkXACITAhkAKhkKGi0LGhgAKhcYGS0CFAMnAAQEBSUAADoGLQgFFwAiFwIYACoYChotDhkaLQ4TDC0OFwktDhUPLQ4WESMAADacACoKDhMtChMKIwAACL0tCwkPLQsGES0LChItCwwTDCoIEhQkAgAUAAA2zCMAADciACIRAhUAKhUIFi0LFhQAIg8CFgAqFggXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUIFy0OFhctDg8JLQ4UBi0OEgotDhMMIwAANyIAKggODy0KDwgjAAAG1C0LCQ8tCwYRLQsKEi0LDBMMKggSFCQCABQAADdSIwAAN6gAIhECFQAqFQgWLQsWFAAiDwIWACoWCBctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQgXLQ4WFy0ODwktDhQGLQ4SCi0OEwwjAAA3qAAqCA4PLQoPCCMAAAYuLQsJDy0LBhEtCwoSLQsMEwwqCBIUJAIAFAAAN9gjAAA4LgAiEQIVACoVCBYtCxYUACIPAhYAKhYIFy0LFxUAKhQVFi0CEQMnAAQEBSUAADoGLQgFFAAiFAIVACoVCBctDhYXLQ4PCS0OFAYtDhIKLQ4TDCMAADguACoIDg8tCg8IIwAABUMtCwkPLQsGES0LChItCwwTDCoIEhQkAgAUAAA4XiMAADi0ACIRAhUAKhUIFi0LFhQAIg8CFgAqFggXLQsXFQAqFBUWLQIRAycABAQFJQAAOgYtCAUUACIUAhUAKhUIFy0OFhctDg8JLQ4UBi0OEgotDhMMIwAAOLQAKggODy0KDwgjAAADiS0LCQ8tCwYRLQsKEi0LDBMMKggSFCQCABQAADjkIwAAOToAIhECFQAqFQgWLQsWFAAiDwIWACoWCBctCxcVACoUFRYtAhEDJwAEBAUlAAA6Bi0IBRQAIhQCFQAqFQgXLQ4WFy0ODwktDhQGLQ4SCi0OEwwjAAA5OgAqCA4PLQoPCCMAAALjLQsJDy0LBhAtCwoRLQsMEgwqCBETJAIAEwAAOWojAAA5wAAiEAIUACoUCBUtCxUTACIPAhUAKhUIFi0LFhQAKhMUFS0CEAMnAAQEBSUAADoGLQgFEwAiEwIUACoUCBYtDhUWLQ4PCS0OEwYtDhEKLQ4SDCMAADnAACoIDg8tCg8IIwAAAfMoAAAEBHhHDAAABAMkAAADAAA58yoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJi0BAwYKAAYCByQAAAcAADocIwAAOiUtAAMFIwAAOmktAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAA6Xy0BCggtBAgLAAAKAgoAAAsCCyMAADo7JwEFBAECAAYCBiYqAQABBbq7IdeCMxhkPAQCASYqAQABBamAM6ct5qnUPAQCASYqAQABBYnYlUKfQdNdPAQCASYqAQABBfcmJmlZ5pJEPAQCASYqAQABBSRO5YxwxMFMPAQCASY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "propose_add_signer"
    },
    {
      "abi": {
        "error_types": {
          "12213818982551431636": {
            "error_kind": "string",
            "string": "Only signers can propose"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17182889816689385946": {
            "error_kind": "string",
            "string": "Threshold must be positive"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "775178390595568676": {
            "error_kind": "string",
            "string": "Threshold cannot exceed signer count"
          },
          "9564027627625670134": {
            "error_kind": "string",
            "string": "Threshold is already set to this value"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "propose_change_threshold"
    },
    {
      "abi": {
        "error_types": {
          "12213818982551431636": {
            "error_kind": "string",
            "string": "Only signers can propose"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "propose_execute_transaction"
    },
    {
      "abi": {
        "error_types": {
          "12213818982551431636": {
            "error_kind": "string",
            "string": "Only signers can propose"
          },
          "1294605584030261072": {
            "error_kind": "string",
            "string": "Removing signer would break threshold"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15748506114730526073": {
            "error_kind": "string",
            "string": "Cannot remove last signer"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15973614272156687301": {
            "error_kind": "string",
            "string": "Address is not a signer"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "signer_to_remove",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "propose_remove_signer"
    },
    {
      "abi": {
        "error_types": {
          "109802946059602463": {
            "error_kind": "string",
            "string": "Too many signers"
          },
          "12195054196221641452": {
            "error_kind": "string",
            "string": "Function increment_signature_count can only be called internally"
          },
          "12213818982551431636": {
            "error_kind": "string",
            "string": "Only signers can propose"
          },
          "12597309932721628587": {
            "error_kind": "string",
            "string": "Must have at least one signer"
          },
          "1294605584030261072": {
            "error_kind": "string",
            "string": "Removing signer would break threshold"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15620477697740044721": {
            "error_kind": "string",
            "string": "Function _assert_is_signer can only be called internally"
          },
          "15748506114730526073": {
            "error_kind": "string",
            "string": "Cannot remove last signer"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15932786771847369930": {
            "error_kind": "string",
            "string": "Insufficient signatures"
          },
          "15973614272156687301": {
            "error_kind": "string",
            "string": "Address is not a signer"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17182889816689385946": {
            "error_kind": "string",
            "string": "Threshold must be positive"
          },
          "17808964010404909636": {
            "error_kind": "string",
            "string": "Address is already a signer"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2586041097980296483": {
            "error_kind": "string",
            "string": "Proposal already executed"
          },
          "2616280824898961740": {
            "error_kind": "string",
            "string": "Maximum signers reached"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "508691203383958144": {
            "error_kind": "string",
            "string": "Proposal does not exist"
          },
          "775178390595568676": {
            "error_kind": "string",
            "string": "Threshold cannot exceed signer count"
          },
          "9506626199212044257": {
            "error_kind": "string",
            "string": "Only authorized signers can sign proposals"
          },
          "9564027627625670134": {
            "error_kind": "string",
            "string": "Threshold is already set to this value"
          },
          "9822098815390167648": {
            "error_kind": "string",
            "string": "Proposal has expired"
          },
          "9932853091537900381": {
            "error_kind": "string",
            "string": "Invalid signer address"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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LQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIVLQxNFQAiFQIV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AgoiAk0DCiIDSwQkAgAEAABJ7CUAAFRjLwoAAgADHAoDBAEcCgQCACcCBAQBJwIHBAMAKgQHBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIFACIDAgUtCwUEJwIHBAIAKgUHAjsOAAQAAiMAAEpbKQIAAgDVz85DCioBAgMkAgADAABKdiMAAEr6HgIAAgAeAgADADMqAAIAAwAEJAIABAAASpUlAABSqi8KAAYAAicCBAQBJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIFACIDAgUtCwUEJwIGBAIAKgUGAjsOAAQAAiMAAEr6KQIAAgD2xse+CioBAgMkAgADAABLFSMAAEuZHgIAAgAeAgADADMqAAIAAwAEJAIABAAASzQlAABSqi8KAAoAAicCBAQBJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIFACIDAgUtCwUEJwIGBAIAKgUGAjsOAAQAAiMAAEuZJwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCiBLTgIkAgACAABNWicCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQXpSUPomzfdLAAiBQIFACIQAgYnAgcEGy0CBgMtAgUELQIHBSUAAFZ8JwIGBBsAKgUGBS0MUAUAIgUCBS0OAQUAIgUCBTwO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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "wormhole_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "payload_1",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_2",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_3",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_4",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_5",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_6",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_7",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "payload_8",
            "type": {
              "kind": "array",
              "length": 31,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "message_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "consistency",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "token_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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j67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XWeLUieLb1fnT+Kpj8Pz8bhr84fjabZtJp2kzV502mKpvbw9vD28Pbw9vD28Pbw9vD28Pbw9jjtcdrjtMdpj9Mepz1Oe5z2OO1x2iPaI9oj2iPaI9oj2iPaI9oj2iPa47bHbY/bHrc9bnvc9rjtcdvjtsctj2xcejSaZtNq2k3W5E2nKZraY7THaI/RHqM9RnuM9hjtMdpjtMdoj9kesz1me8z2mO0x22O2x2yP2R6zPVZ7rPZY7bHaY7XHao/VHqs9Vnus9tjtsdtjt8duj90euz12e+z22O3Rdb67znfX+e46313n2e7klmRN3nSaoukWZZ2DRtNsWk3t4e3h7eHt4e3h7XHa47THaY/THqc9Tnuc9jjtcdrjtEe0R7RHtEe0R7RHtEe0R7RHtEe0x22P2x63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023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3S7dLt0u3S7dLt0u3S7dLt0u3227Z61o4iJO4iJtoRCceYhDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26LbotujGLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucwS9L3Ok7iJRnTiIQbxNiJLgIM4iXSbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDN2TJTTSiEz+3/Hov9L0+vI2ZJQ8HcRIXcRON6ES6Bd2Cbpdul26Xbpdul26Xbpdul26XbrfcFvpeHw7iJC7iJhrRiYcYRLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26HboVvQLegWdAu6Bd2CbkG3oFvQLeh26Xbpdul26Xbpdul26XbpdunGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLB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hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVEtItYRUS0i1hFRLSLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1hFVLWLWEVUtYtYRVS1i1pKqWVNWSOrTk4aarQ0vGT9KfR2ly/LdVfx6lPd61qUNLxs+jtEe4bh1aMn4epT0yMNWhJQ8bcR1aMn6S/jxKe7j/69CS8fMorR8/m/7s8+fQkvEz6c+sP4v+JP3J+rPqTy0ta2lZSytaWtHSipZWtLSipRUtrWhpRUsrWlrR0khLIy2NtDTS0khLIy2NtDTS0khLIy2NtTTW0lhLYy2NtTTW0lhLYy2NtTTW0qqWVrW0qqVVLa1qaVVLq1pa1dKqlla1NNHSREsTLU20NNHSREsTLU20NNHSREtrWlrT0pqW1rS0pqU1La1paU1La1pa09K6lta1tK6ldS2ta2ldS+taWtfSupbWZ2mybfoz6c+sP4v+JP3J+rPqT9GfTX9qaUlLS1pa0tKSlpa0tKSlJS1NtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLVEVEtEtURUS0S1RFRLRLWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS7pqSVct6aolXbWkq5Z01ZKuWtJVS7pqSVct6aolXbWkq5Z01ZKuWtJVS7pqSVct6aolXbWkq5Z01ZKuWtJVS7pqSVct6aolXbWkq5Z01ZKuWtJVS7pqSVct6aolXbWkq5Z01ZKuWtJVS7pqSVct6aolXbWkq5Z01ZKuWtJVS7pqSVct6YeW7KfZx8+kP7P+fJRWH9dJ+6El9ZHKux9a8vOzHj/L46foz3b85MfPfvx8+K//95/+/pc//c+//vk/dv/uwwX8n3/719Pdu8N//H//fv6b//n3v/z1r3/5f//l3//+b//65//1n3//88M1fHiFt8f/PEbbf0/1jzk9XMfp55/v/yRv2x/3/83b/9gdEeOf5PT4JyXt/+Tnz9J+bN//tx3/KI3/qvDxX8mDLz/4Hn9d8h8pn3/H6Y9cH/+6zBrsnnWixz+i8y9y+2Np51/8/OuHf/v/Bw==",
      "is_unconstrained": false,
      "name": "send_message_to_wormhole",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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ptt0kE0zbDrYppk2zbLpEJtm23SoTYfZdLhNc2yaa9MRNs2zab5NR9p0lE0LbDrapoU2HWPTIpuOteklNr3UpuNseplNx9t0gk0n2rTYpiU2nWTTUtd+m5bZ9HKbTrHpVJtOs+l0m86wablNZ9p0lk0rbDrbpnNsOtem82xaadP5Nl1g04U2XWTTxTZdYtOlNl1m0+U2XWHTlTb12nSVTVfbtMqm1TZdY9O1Nl1n0/U23WDTjTbdZNPNNt1i06023WbT7TbdYdMrbLrTprtseqVNd9t0j0332nSfTa+y6X6bXm3Ta2x6wKYHbVpj00M2PWzTIzY9atNjNr3WptfZ9LhNr7fpCZveYNMbbXqTTW+26S02vdWmt9n0dpveYdM7bXqXTe+26T02vdem99n0fps+YNMHbfqQTR+26SM2fdSmj9n0cZs+YdMnbfqUTZ+26TM2fdamz9n0eZu+YNMXbfqSTV+26Ss2fdWmr9n0dZu+YdM3bfqWTd+26Ts2fdem79n0fZt+YNMPbfqRTT+26Sc2/dSmn9n0c5t+YdMvbfqVTb+26UmbfmPTb236nU2/t+kPNv3Rpj/Z9Geb3Jh82qa/2PRXm56x6W82/d2mf9j0T5v+ZdO/bfqPTc/a9H82/dem52xyg65i0xCb2mxqt2moTR02rWdTp01Vm4bZNNymLptG2DTSpm6b1rdplE0b2DTapg1t2simjW3axKYxNm1q02Y2jbVpnE2b27SFTVva1GPTVjZtbdN4m7axaVubtrNpgk3b27SDTRNtmmTTjjbtZNPONu1i06427WbTZJt2t2mKTXvYtKdNe9m0t0372LSvTVNt2s+m/W06wKZpNh1o03SbDrJphk0H2zTTplk2HWLTbJsOtekwmw63aY5Nc206wqZ5Ns236UibjrJpgU1H27TQpmNsWmTTsTa9xKaX2nScTS+z6XibTrDpRJsW27TEppNsWmrTyTYts+nlNp1i06k2nWbT6TadYdNym8606SybVth0tk3n2HSuTefZtNKm8226wKYLbbrIpottusSmS226zKbLbbrCpitt6rXpKpuutmmVTattusama226zqbrbbrBphttusmmm226xaZbbbrNptttusOmV9h0p0132fRKm+626R6b7rXpPpteZdP9Nr3aptfY9IBND9q0xqaHbHrYpkdsetSmx2x6rU2vs+lxm15v0xM2vcGmN9r0JpvebNNbbHqrTW+z6e02vcOmd9r0LpvebdN7bHqvTe+z6f02fcCmD9r0IZs+bNNHbPqoTR+z6eM2fcKmT9r0KZs+bdNnbPqsTZ+z6fM2fcGmL9r0JZu+bNNXbPqqTV+z6es2fcOmb9r0LZu+bdN3bPquTd+z6fs2/cCmH9r0I5t+bNNPbPqpTT+z6ec2/cKmX9r0K5t+bdOTNv3Gpt/a9Dubfm/TH2z6o01/sunPNj1l09M2/cWmv9r0jE1/s+nvNv3Dpn/a9C+b/m3Tf2x61qb/s+m/Nj1nk3MAKjYNsanNpnabhtrUYdN6NnXaVLVpmE3DbeqyaYRNI23qtml9m0bZtIFNo23a0KaNbNrYpk1sGmPTpjZtZtNYm8bZtLlNW9i0pTsHxqatbNrapvE2bWPTtjZtZ9MEm7a3aQebJto0yaYdbdrJpp1t2sWmXW3azabJNu1u0xSb9rBpT5v2smlvm/axaV+bptq0n03723SATdNsOtCm6TYdZNMMmw62aaZNs2w6xKbZNh1q02E2HW7THJvm2nSETfNsmm/TkTYdZdMCm462aaFNx9i0yKZjbXqJTS+16TibXmbT8TadYNOJNi22aYlNJ9m01KaTbVpm08ttOsWmU206zabTbTrDpuU2nWnTWTatsOlsm86x6VybzrNppU3n23SBTe479e4b8u777u7b6+676O6b5e574u5b3+473O4b2e771e7b0u67z+6bzO57ye5bxu47w+4bwO77vO7bue67tu6bs+57sO5bre47qu4bp+77o+7boO67ne6bmu57l+5blO47ke4bju77iu7bh+67hO6bge57fu5be+47eO4bde77ce7bbu67a+6baO57Ze5bYu47X+4bXO77WO7bVe67Uu6bT+57TO5bSe47Ru4bQ+77P+7bPO67Oe6bNu57M+5bMO47Le4bKu77Ju7bI+67IO6bHe57Gu5bF+47FO4bEe77De7bCu67B+6bBO57Ae4sf3fOvjsD351P786Od+e6uzPX3Xno7qxyd464O+Pbnb/tzsZ251a7M6Xdec/uLGZ3TrI7w9idL+zO/nXn8rozc915tu6sWXcOrDuj1Z2f6s42deeOujNB3Xmd7ixNd86lO4PSnQ/pzm505yq6Mw/deYTurEB3jp87Y8+df+fOpnPnxrkz3dx5a+4sNHdOmTtDzJ3v5c7ecudiuTOr3HlS7qwndw6Tc7zd+UXubCF37o87k8edl+POsnHnzLgzYNz5LO7sFHeuiTtzxJ0H4s7qcOdouDMu3PkT7mwId26DO1PBnXfgziJw5wS4d/jd+/Xu3Xf3Xrp7Z9y9z+3etf7fe9A2ufeH3bu97r1b906se1/VvUvq3vN072C69yPdu4vuvUL3zp97H8+9K+feY3PvmLn3v9y7We69KfdOk3vfyL0L5N7Tce/QuPdb3Lsn7r0Q986Ge5/Cvevg3kNw7wi4/ftub73b9+72pLv94m4vt9tn7fZAu/3Jbu+w29fr9ty6/bBur6rbR+r2eLr9l25vpNu36PYUuv1+bi+e2yfn9rC5/WVu75fbl+X2TLn9TG6vkdsH5PbouP0zbm+L23fi1j9uv4bbS+H2Obh9Be6Zv3tu7p5Tu+fC7jmse+7pnjO653ruOZp7buWeE7nnMu45iHvu4OL8Lq7u4tgubuzitC4u6uKQLu7n4mwuruXiSC5u4+IkLi7h4gBu3e3WuW5d6dZxTlXcmkyubOr437rNPf93z9vd8233PNk9v3XPS93zSfc80D1/c8+73PMl9zzHPT9xzyvc8wEXj3fxbxdvdvFdF0918UsXL3TxORcPc/EnF+9x8RWJZ2xlnl8fjzfP79PY1gy+uuD3Rtnf20/59Bee+f16X8Vym3jyNvXkTfDkHZT9PaHzwQ8d9PXhb8K8GZ682Z68wzx5J2V/f/2GUf993blfvAzzTs/+7v2ncV9/5JKvvh7zVnjasDInb1j2d/vs75Lzzlt27soTl6448+wlK087afmyE1ecu2Sp/XPBsnPPO23FWSdeeO6Ss89edu7GWfnO7O+Q7K/TJadHPSboqnRCveL1ew/uZIKF6pv/1a+YsvjPt1/GT5n6HcII1EdehK4bi8Ph9wjCL8n/wfXyv4GHZ+mbGVC+xwRdbU4vXTvXz264tm+T/T5/5WnLT1t58fT/qeqMPk2d9z9FPeZ5PWWCFfr/jJz7w4DvdigTLpOLDhaabdnfofAbr3b6K2XEvlUBX/6G7M/6/qf+9u13Hjb5zFFU313SN8MA5+TTzlu6wo7vE89aduGJZy4777wlpyw77/Fpz2eu5QG+pM4BvqROBa90Qp0S9fsG+GKoz7y4q8sMHEhYZz3TPwG63xOz33UO/iVNOvj76h5cvG6b1J2p1X3mvO+89gu3vOOTj6983WN3j/r+iPuG7zjsymuu+fPYP4171VPXPCJ1Z2V/pW09JujqkPqHaNgHvKftpae+7d8rhh+y6i0Xfv97R5w/YtySj295/WMv/dQdW/72xGul7myt7m9uvv/K7re8Yk3PpC/9reOQ2/5w4l8PHbr397902aafuPrZ3z51p9Q9VKv79Zc++6N3dt95yUW3vO/SvbcfveSNd37n6d995gtv7v7rz950znf2kLqHQZsLbALt66vDy9Xvsw9zytUfIvXnQv0y9umIcvXXl/rz4GaP/Ljq0cd/NP2WL+36i2eH3Th3yeqLdr/pG4v+eMmY1237q9PfNO6No6TufK3uz1fOuGPlJmfu+cfOr9yy20NjN//JM69755N/v3jZ3n948jfv3uqvUvdIpe6YyRP2Ofver274w+23/sGBH33jzndt+sw2+/3wvbMfeurfn3NBZKl7VLk298l8Qbn67VL/6HL1+8b4QqhfYJz29fkx5er34S8qV79PfsfCzR5/nb5pQeq+JLyuXEOl7kuVuhP3qz712I1XXGN++rrf3/r3iR88cKdRW0wftfM37//22LPOPW7Tp6TuccBQgT4bJ/VfVq5+p9Q/vlz94VL/hHL1u6T+ieXqjxCHdiPwq3juLaBD8zW/pED9ZVK/vVz9c6X+0HL1Xy71O8rVXyH11ytX/0yp31mu/mlSv1qu/llSf1i5+qdI/eHl6vdI/a5y9c+T+iPK1e/zPUeWq3+y1O8uV3+p1F+/XP0LpP6ocvUvFn9/A7gpRl5oj4b7BWzN5uiPy9VG95B+lXgp6kNViJ7gcfvE1knbN1R46Vby2EZuqOBsqOBotNoi0mqPSGtoRFodTdrG9SLS6oxIqxqR1rCItIZHpBVT9jHHUFeT0hoRkVZMnYgp+5j6NTIirZhjO6ZOdEekFdNGrx+RVrPOj+Jnie+AvkYl56/g8D3BqRItaX+PCboqvnaNVvA6jS7vHhMImKWNFDzNz5LyGwfy5+yB6Hj2kOXgZSedf8qcFacYutrp/7NyWBxnBrK/oYc1pluhxPeZdptSFq/hgJc1b9aylUtPPXrJKacsO9k28jyuwZRm5twXpdxIqSudvjFx2mOCriEhSo30q8RLWaXWlAbbh0ojypdJdc6KJSfPWHL2eecvXzYESZuBSwyWClLFe1qfVoAz4yk3k/4/V6lnFNqoS5tAniYJoTnSDG7TJjn1eMjyvSFK+Y2J1sZKPeG9zVMfaWA91hifVodopbTDXd0mv/0hS+GSo2fDsqOn3qWwT9bu4ilhk3J4o306ijSFH5H1GCVPaMk+mY4cWlK3nco/kP3tpnLumkEYYxR+8Z7Ixy2L7yPeUbasJ/XIEekJX3gP6VdNXXpZ8fUbto/1ZEw5vA1C5I78iKw3VfKE1mbZ/ztyaEnddir/huxvN5VzF+vJpgq/eA/15LXEO8qW9aSkHKeH6onQr5q69LLi6zdsH+vJpuXwDgyRO/Ijst5MyRNaY7P/d+TQkrrtVP692d9uKucu1pPNFH7xHurJO7LfnTn89piga7km6wL1L+w0g2VXoP5KqT+2XP1Tpf64cvUvlfqbl6u/q9Tfolz9y0X3toSbPM574H6Rx5Wh47wn+10lXsqO8x7C4/ZxCH0rhZduJY+XhFspOFspOBqt9oi0OiLS6o5Iqy0ira4mpdUZkVY1Iq1hEWkNj0hrTERaMfW+WeW1aURaMXV1s4i0xkakFVP2Mds4IiKtZtXVcRFpbR6RlvhGMt/3QL1K9rdTqVd0bYj0hE+8h/SrxEtBvIpPLj1wj9c0W5fDG1Wh+oiHNIUfkfV4JU9oybsIHTm0pG47lV8vE2g3lXMXr2nGK/ziPVzTSJh4pMIvx3eK6iPWZxlhPdbHevoL6QmfeA/pV01d+l/x6YcmF2nf+HJ464f0L/Ijst5GyRNa8s5cRw4tqdtO5TchfdwGeGJ93EbhF++hPopR6TKDZct6UlKOM0P1ROhXTV16WfH1G7aP9WSbcngHh8gd+RFZb6vkCS1577Mjh5bUbafy25Ce4DuarCfbKvziPdSTLTO6nTn89piwi8eI0EDaKJfwfqg8HapnQr9q6ur3ik+O2niT9m1XCq/yFOsG4iFN4UdkPUHJE1rbZ//vyKElddup/GTSM8Rg3ZA85BfvoZ7tRPYIZct6Uk6O/zt2ZgA94QvvIf2qqUcv+/VE6zdtvEn7JpTDmx4id+RHZL29kie0dsj+35FDS+q2U/lppCfbA09sj7ZX+MV7qCf7kj1Cft3VY4KuiibrAvUHyQ5pCO0d4H6BfnwuVE+FftUM7scyeroD4eX1g7R9osJLt5KHMsY8xJmo4LRotWi1aLVotWi1aLVovbBpbdei9aKgtS7oV2sMtfqxZSda4/GFSqulXy1dXRd1teVPtOTVamNL9i9UWi1dbenEuiivln61+nFdpNUaQy2dWBdl37KrrTHUkleLVi1arbVVq40tG93S1RcqrZZ+tfhq0WqNx5RtbNFq2ZzWPNRqY6uNLZvTklerH1v69cKl1Yp1tNrYsjktO9Gi1dL71hhqyb41hlq0mllXW/5ESydasm/JPiWt1jzUkldrDLVo1aLV7Doh58LimWH8PRftfK4dPDhYX8p1KfUq2d9OhT+H02OCruBzy4R+1QxucwG8ik/+mlyk7ZMUXrqVPO7nSQrOJAWnRat+WhOalFarjS8Oea0LfLVovTjGY8tOtGi1dLVl71Py1erHVhtb+tWaO16ofLV0oiWvln61+rFFqzWGWjqxbsq+ZVdbY6glrxatWrRaa6tWG1s2uqWrL1RaLf1q8dWi1RqPKdvYotWyOa15qNXGVhtbNqclr1Y/tvTrhUurFetotbFlc1p2okWrpfetMdSSfWsMtWg1s662/ImWTrRk35J9Slqteaglr9YYatGqRaulEy1aLVotWi1aLVotWi1aL3Zacm4Znhm2A+EUPR8N60s57Wwyl3pM0HV0p9KGAvVPlPo7lqt/jtTfqVz9i+Tssp3hZiX7K7R3gftt4bR3qxA9k9XHe0i/SrwUxOs7t20XwuP2iV5I23dVeOlW8lhHdlVwdlVwNFpjI9Jqi0hreERa3RFpjYlIa0REWp0Raa0XkVZMnRgZkdakiLS6ItLaMSKt9oi0NotIK+bYHheRVkxbGHM8ViPSitmPW0SkFVMnYso+5tiO2caYOtERkVaz2omYfK0LPlNrTlt7so85HodGpBWzjTs1KV8x/YmYbZS5VlsLu9Rjgq7zea0pNJD2bnC/wLr3gArRM0ZfZwv9qtHtYY8JuvrW2bsRXp5cpe2TFV66lTxeZ09WcCYrOBqtsRFptUWkNbxJ29gZkVY1Iq3NItKKKftxEWm1+rEYrS0i0oqpEyMj0uqISCum/eqKSCum7GPqakzZN6v9iqmrMfVrvYi0YvZjTP2KOYZi6ld7RFojmrSNzerLxWxjTH+iWfuxWX25nSLSalY/J6aP2fInXhxjKKadiMlXTP3aMSKtXSLSiin7mD6AzLUSB9oR6lWyv3XGwLaqED3hE+8h/aoZ3JexYmDYPpGLtG9yObyekH5AfkTWuyt5QmtK9v+OHFpSt53KT8sMWbeCMZ4wJA/5xXsiHxcv3zejO1Lhl8ecJvfdFLrdSn2WEdZjfSzZX22h+ij0q6Yu/a/49EOTi6YfUlfrV5Z/aL/6aHFcWPLd1anUKyCP9lD5C/2qqau/Kz65aHZS2j5F4aWb8tw1A8pxXptyb0hiWtxf7uox3ku6Y5AshDekuwfcL9AvQ0P1QOhXzeB+KaMHexBenkyl7XsqvHRTnru47/ZUcPZUcF4otFCH2EZJvrvq1ItRZfWipD3y6oVmN6V9e5bDWz+kH5AfkfVeSp7Q2jv7f0cOLanbTuXPIX8BMdhfkDzkF++hv7Cc/AXkd3eiq8l9D4WuNl9JuRcbTpdSj8dXSf0LtrtCv2rqGs8Vn75rctH0XepqesryD9XTFyIt0b89PThF7TvW37OFEx1ncp04kwNxptSJM0XB6VLqsR1CPQ23C5WfhtohoV81ddm9im8canKR9u1dCq/yE56bEQ9pCj8i632UPKG1b/b/jhxaUredyr+W5nnE4Hle8pBfvIfz/EM0zyO/vC4tav+wPssI67E+lusv0x2qj0K/aurR/3591PRDk4u0b59yeCND+hf5EVnvq+QJranZ/ztyaEnddir/btLHfYGnGYSxr8Iv3kN9fFtGtzOH3x4TdB2hybpA/Z91msGyK1B/N6k/tVz9NVJ/v3L1d5D6+5er/16pf0C5+jOl/rRy9d8t9Q8sV/8qqT+9XP1jpf5B5eofL/VnlKu/vdQ/uFz93aX+zHL1fyP1Z5WrP1vqH1Ku/vuk/uxy9c+W+oeWq3+H1D+sXP0ZUv/wcvX/JvXnlKt/p9SfW67+U1J/HtQv8kxF6h9Zrn6b8Dsfbyo8CX2Z646A8pWcv0KL8wSrSrQK8l7x8Y78sb80H/CwjXm05hek1anklemTeSa/XUi/y8OLxufm8LveNo+MSGvviLTaI9LaJyKtfSPSmhqR1n4Rae0fkdaQiLQOiEhrWkRaBzYprekRaR0UkdaMiLQOjkhrZkRasyLSGhWR1iERac2OSOvQiLQOi0gr5txxeERacyLSmhuR1vgmpOWuhdnfOuMdh9YZr9i3znjF3DrjFQvqjDdMrzPecEid8YKD64wXzBFf+2C4Wcn+arGAAn7/ERWiZ4y+fhL6VeKlIF7f+mkm4XH7+HnjLIWXbiWPx8gsBWeWgqPRqkaktX5EWiMi0hoTkVZnRFojI9IaHpHWehFptUWk1dWktGLq6rCItGLKfmpEWjF1NeZ43KxJ2xhzPO4SkVbMMdSssh8bkVZMOxFzro1pJ2LKPqa8mlW/YvomMfsxpuzXBTsxLiKt/SLSOiAirf2blNa0iLQOjEgrpuwnNSlf0yPSGhKRVkyd2DsirYMi0orZjzH5iqmrzWoLJ0akFVNXY/ZjTL6aVV4xdXVGRFoxdTWm/doiIq2Y/tfQiLRixhRi+uQx1woxY4/i30scezrUq2R/64zhj6wQPeET7yH9KvFSEM8bw8f28d7oWeXwRoT0A/Ijsj5EyRNa8uy2I4eW1G2n8l/MAk7dVM5dbOMOUfjFe7g3+jPrDeQdZct6UlKO40L1ROhXTV16WfH1G7aPn/UcovDSreSxTxwqb41We0RaHRFpdUek1RaRVleT0uqMSKsakdawiLSGR6Q1OyKtmGMoZj+uH5HWiIi0NotIK+bYjqlfMcdQTLu6Lsh+vYi0YtposYXyXiL6M6MJp6jvjfWlXJ3vuxxV5/sux9T5vsq8Ot83mSV+1Ry4Wcn+au+SFPDxrqoQPWN0n1LoV4mXgnh9PuVcwuP2sU85T+GlW8nj/UPzFJx5Co5GqxqR1voRaY2ISGtMRFqdEWmNjEhreERasyPSao9IK6bsm1VXN4tIqy0irZj6FdPmdESktS7Ifr0mbWNXk9KKObaHRaQVU/ZTI9KKqavN6gPEpNWat4vRas3ba0+/WvP22pN9a95ee2O7WeftmPJqVl3dJSKtmPKKaXNiyn5sRFoxx1DMebtZbXSz+hMx2xjT943ZjzFlvy7YiXERaQ2JSGtWRFox4+SHRKQ1LSKtiRFpHRCR1qSItPaOSOvQiLTWBdnvF5HW/hFpHRiRVkx5HRaRVkxdjTmGmlXvm7WN64ItjMlXa+54ccwdh0ekFdOXiymvGRFpHRSRVsy5NqZOxJRXs84dW0SkFXPNNzQirZjPdGLGAWLGJ2Luz+F3bHBvWCX7W+eZxyMqRE/4xHtIv0q8FMSr+OSC7RO51Hn+b1eF6iOedsavyPpIJU9oHZX9vyOHltRtp/I92cOwbirnLrZxRyr84j2RjxufY6sDeUfZsp6UlOM2oXrC51GX1EvvedTa+NH6Tep2K3kcfwqVt0arPSKtjoi0uiPSaotIq6tJaXVGpFWNSGtYRFrDI9KaHZHWiIi0Yo7HzSLSiqlfMeU1JiKtmPoVcwzFtKsxdSKmXW3WsR1zPMYcQ+tHpBVzPK4L+rVeRFoxfQB+hwv9ZX6Hq+gZ2Fg/73sjku+uOr9Hc0eF6AmfeA/pV83gNpfx2TX5a3KRth+l8NKt5HE87ygF5ygFR6NVjUhr/Yi0RkSkNSYirc6ItEZGpDU8Iq3ZEWm1R6QVU/bNqqubRaTVFpFWTP2KaXM6ItJaF2S/XpO2satJacUc28Mi0oop+6kRacXU1Wb1AWLSatZ5O6bsY/oAMW10TH+iWXW1NW+vPbva8smL0Wr55GtPv1p+4drTr2b1C2PKq1l1dZeItGLKK6bNiSn7sRFpxRxDMeeOZrXRzTqnxWxjTN83Zj/GlP26YCfGRaQ1JCKtaRFpzYpIa2JEWjGfD8WU14yItCZFpLV3RFqHRqQVUycOiEgrpuxjju2Y4zHmGDokIq2Y43Fd0K/9ItLaPyKtAyPSiimvwyLSimkLY9roZtX7Zm3jujDXxuSr5Zu8OOaOwyPSiulPxJRXTJ/8oIi0Ys61MXUipryade7YIiKtmDGFoRFpxXxuFTPOFDP+FXN/Ib+DiXtbK9nfTqPLpscEXV0Void84j2kXyVeCuJVfHLR9klL+xaUwxteofqIhzSFH5H10Uqe0FqY/b8jh5bUbafya7KHTt1Uzl1s445W+MV7Ih83Pu8fNpB3lC3rSUk5fixUT4R+1dSllxVfv2njR9p3dDm8j4bIHfkRvIXl8NqkrxYptIWXY7P/d+TwInXbqfw7SB+OUep0U567WAcxr025N2Qt0Vqk0EI5Sp+4sfH6TBaa/rvUY4KuyWwXhAbSLqkLi0LHltCvmrp0vcJ2TPDybIymR1K3W8njeFnZvne/N2tSWm0Raa0XkdbsiLRiyqszIq1qRFrDItIa3qRt7GhSvroj0oo5HmP248iItGKOoa6ItGL2Y0xdXT8irZj61R6R1qiItGLqfbPanJhtHBeR1uYRaW0RkVZMecX0TWLqV7P6hTH1vll9uRERaY2JSGtd8OWaVe9j+iatOa0YrWb15ZrVFsb05WLawpj9GFNezep/7RuRVrP6X0Mj0oo5tmOOoZjyijkPxRxDzSr7mPYrZlyuWWNDMfUrpu/brD5ms84dCyLSkrmji2hLvrvqfN60eYXoCZ94D+lXzeB2xnrehO0r+7xpCPxuJnsYcxw1a6w8pg2LSav1vKkYrZixuZhjKGY/xnweENPXadY4TEz9islXsz7XadYYRcx+jLlXIaa957NT0Tfis1M1P2ShBwfrS7kupV4l+9tpdD3rMUHXNRWiJ3ziPaRfNYPbXMY/0+SvyUXbuyZ1u5U83ofv27+FOBqtakRa60ekNSIirTERaXVGpDUyIq3hEWnNjkirPSKtmLJvVl3dLCKttoi0YupXTL5i9mNMvmLa1Zg6EbMf14tIK6bsu5qUVkw7MSwirZiynxqRVkxdbVZ/Iiatlg+w9uaOlg+w9vhq+QBrrx9bPsDasxPN6gPElFez6uouEWnFlFez2omxEWnFHEPNOnc0q+/brPoV04+O2Y8xZb8u2IlxEWkNiUhrVkRaMeP3h0SkNS0irYkRaR0QkdakJuUrZj/G5GvviLRi6kTMftwvIq39I9I6MCKtmPI6LCKtQyPSalZdbY3HtdfGZtWv1jzU0numdXhEWjF9zJj9OCMirYMi0oo5b8fUiZjyatbxuEVEWjHXokMj0or53CpmfCJm3CTmfiaJdcj+Q1zLTyacIQrOEA8O1pe8TqVejwm6psr+vYlws0J00R63hdNurxA9Ywb2vyH6VeKlIF7f3sV9CI/bJ3KStk9VeOlW8rAfMQ9xpio43UrejAbQ6szhs8cEXQu1/i5Q/wyWp9BA3nC9WqBvx4TqktCvmsH9V0aX9iO8vH6Rtu+v8NKt5HEf7a/g7K/gaLSqEWnt06R8dUSktWlEWjHbODwirfUi0uqKSGtYRFox5bVZRFqjItKaHZFWW0RaMWXfGZHWyCZt47iItDaPSEvWL6l8VQ1nSp04UxScLqVeJftbpy+yY4XoCZ94D+lXzeA2x/JFNLkU9UU4dtMs8/QuEWnFnKeb1casH5HWiIi0xkSktS7MFc3qN8fkqzsirZh+TUxfN6ZODI1IK6ZOtEekFVNeMe1Xs64zYvZjTL6ade6I2Y8xZR9zbK9La5Zmk1ezztsxx3Yj5lpZr+D6ppL97czhoccEXcFrNaFfJV4K4lV8csH28VrtQIWXbiXvIPiNeYhzoIKj0eqMSKsrIq3uiLQ6ItJaPyKttoi02puUr5ERaQ2PSGtcRFqbR6S1RURaMeVVjUgr5njcLCKtmHof0xbG7MehEWnFtDkxdWK9iLRiyn5Ek/I1OyKtmDoR0zeJOW/H7MdmtV8x9SvmeGxWGx2TVkz9GhaRlshent/hemwu4RRdE2L9/RPjaOtLl3pM0HUSr9+EBtKeAfcLrCWXVoieMQPHgCH6VaP3W48JuvrWrjMIL09PpO2zFF66lTzewztLwZml4Gi0dopIa3ZEWm0RaXVHpLVZk7ZxZERawyPSiqkTIyLSiqkT+0SktS7oRDUirY6ItJp1bMeUfUx5DW3SNo6JSCtmP8bU+2ERacXU+7ERacXUiXERacXUiZb/9eKw0THn2kkRaa0LtnCLiLRi2pz9I9LaJSKtmGMoprxizmkdEWk1q7xizmnNuraKKfuYYyimvGLa6Nbc8eKYO2KurToi0mqPSKsVU1h7Yyim7GO2cVREWs26Hoop+86ItJo1XhjTz2nZiWK0YvoTLTux9mTfrHZC/C8+M8NdPSboqsjz0wPwJtGdAfcLPMsdWiF6xgzsY0P0q8RLQTzvs2NsX9lnx7GeVRkz+OyVZqMlex+Q9nTC0eQ8w4OD9aVcl1KP9Y9tRI8JuqaG6p/Qr5q69L3ik78mF2n7IQov3UoevyN9iIJziIKj0RoRkVZnRFpjItJqi0hrZERawyPS2iwirY6ItGK2sbtJ27heRFqzI9LaJSKtmPoVczzG1K+YtjAmX9WItGLq/bqgE2Mj0oqpX7zPt1naGFP2QyPSiqn37RFptezEi8NOxGzjqIi0YvoTzSr7cRFptcZQMVqTmrSN68IYiin7mGv3mGtkPhMQ28xnAk5ScCZ5cLD+JA/OlDpxpgTiNKI9nUq9HuO9xL0ZFBcV2kiXdbvHBF3BMWGhXyVeCuJVfLqoxUSl7YcqvHRTnrtmQDnOa1PuDXmB0aqlu9MJp6juTg/EaY355mlPp9HnoR4TdF2i2ZAC9XfiMSo0kLdj4H4BezEn1D4J/aoZPF7K2KdjCC9vfErbFym8dCt5Mb8z0hGR1rrwjfZm/WZvs35fOmYbY/IV83tEMXW1PSKtmGM7puyrTdrGlv16cdivmG2MKfvuiLRi6v0uEWnFHNvNOh5j2uhmnWtj9mPMb6CtC/PQutDGmHzFtKvNOm8f0qR8xZTXThFpxfy2ZEzfpFnntNZ4XHttbNZ5e11Yp8XUif0j0mpWvZ8dkVazxjrWj0irETZaeybAZ+AVfSaA9ZvhGcesOnFmNVl7Ws+gWu1xv+fWiTM3EKelB83TnhL7NuSaIs8Gd4KbFaKLzwMLPKccWSF6xgycrwzRrxIvBfH6novuTXjcPn4ueozCS7eSx890tOevxyg43UrejBatFq0WrSi0mnh/nCy9+2wN2ia2syX3nwTvj+P9JyXtunf/CbaP7ewihRdeh7iLdaTsmqZZaa3jvsiQr4w+4fyOR49futOEETOfHrPBXaumffKWq6dN2JHnY6GNdHntS7TzrvbQMSL0q6auMVnx6Yhm36Ttxyq8dCt5fK7AsQrOsQqORmtSRFoTst+tNcMLeJw+c953XvuFW97xycdXvu6xu0d9f8R9w3ccduU11/x57J/Gveqpax6tcywukvrHlqs/Wuq/pFz9DaT+S8vVHyX1jytX/2Cp/7Jy9adL/eNL1a/09f0JcLcnqG5/20/so1aI9wOl/uJy9beU+kvK1f+v1D+pVP3KU1J/aan65v+k/slws0d+HPCetpee+rZ/rxh+yKq3XPj97x1x/ohxSz6+5fWPvfRTd2z52xOvk7rLymGPlfov17D91xCpewpgDwmv3yn1Ty1Xf0+pf1q5+ntJ/dOhfgHZ9Uj9M0rVr/xE6i9Hotnfbb79/vX+8cRt7W//7lMrLvzbxDs/f8gtH37Dfq/40k4H9C74xd1/mit1z1Tq1sDtG+tn9d0pFsOR+isKY5t2qXu2Vvc3N99/ZfdbXrGmZ9KX/tZxyG1/OPGvhw7d+/tfumzTT1z97G+fukvqnqPV/fpLn/3RO7vvvOSiW9536d7bj17yxju/8/TvPvOFN3f/9WdvOuc7fbpybla8YJs3lPrnadj+q1vqrlTqjt7NfGfLn+xx8aSN91wx74LVPzn6TVds+MgOT3aP+dP5+13wrx+ukLrnK3VrXHu4999Pyx4siQ9xQZbpfm8Ev126MPu/qyc+xIZQRuq2U/kfbNtf78wMT3zXDYChSvZX2jQa7hfoi00rRM8Y3W8X+lXipSBen98+mvC4fey3b6Tw0q3k8fvHGyk4Gyk4Gq0tItIaHpHW7Ii02iLSqkakNTIirc4mbeOwiLSaVb9GRKTVHpHWZhFpxdSvmPIaE5FWTP2KOYY6ItKKqRMx7arsX+xS6lWyv+IHbEk89Jiga0iF6AmfeA/pV43e5h4TdPX5AVsSXp5cnP6Jf3D+ytOWn7by4jkrlpw8Y8nZ552/fNkQJG0GekMsFaSK9ypmYOsxr43ucblD6P9zlXpGod0G9LaCPE0SQlO8T2zTVjn1UBZGuTdEKb8l0dpSqSe8t3nqu6tL4WFta2xJT9mrsdg+9ly3UnjpVvJ4BaFZDM1DLsrXcNO/+zUbSQcvO+n8U+asOMXQ1U7/n5XD4hgqNzeHtYpCt0KJ74+he23GP1R9i6UQlXEXG2Nc7GxIOC1j3DLGLwxj3KbUY40Zqdzn0VzUlZmr4Gk4R9aJc6SC06nU65EfVz36+I+m3/KlXX/x7LAb5y5ZfdHuN31j0R8vGfO6bX91+pvGvXEDF4L5KoV8UP4bEL/S7xjy0fqrncpPgJDPNzM8N8I2yfKzEXbQ+cvPOGrZynNPW3bBMmurMXjWJyJDLOE1j/4/X6mnXSFzeEnDE2zohH6sOVxTrby5MtzQsUKgVJAq3qvH0M2n/5cxdLW8BjZ0PuOEvbKBgiv3hph8Q6QZMY41+gyZu1pT8/NXcY1dl6fmEI0NnZrzNDZvauZ6Q02+hrdT2aezKaNOzR5wSiPz2JoDnr9ac8ALZQ5oU+qxxvi0OkQrpR3u6jb57e80g+XRIz9+vnLGHSs3OXPPP3Z+5ZbdHhq7+U+eed07n/z7xcv2/sOTv3n3Vs/UObqOqdMqLHSWaGhmGqT/twJavLjbOvt/3nNPqdtO5YeP6q9XzX67kZf5xjLyjlmy/LSTl6xcNvOsc85fdv6yk49YsXLZedPPOnnmBcvOWlnYJZ5N/z9Uqaddw4DezkC/jRrpLl497Zr9vwNwsAwLSMp3Z0JZz6ax07J7ZnAnCD9dVF/y3SVKsRvx3mOCrmCTLfSrxEtZk70b4XH7yplsVGeWClLFe2vbZO8OeZok2GRjm3bPqceay/eGKOV3I1q7KfXYZGv1kQbWY43hUYRmZmcFm0dRD4yiLabl4+5sBsuBR9IGCp6Mut2prLtk1O1BbeoxQdei0FEn9KvES9lRtwfhcfvKjTrUFEQ5hqhKGSyL1zHAmckpp/XeRko9vkRi7cTzPjBZTaTJEdvVQ/xo2o732JnA+lJOw9mkTpxNFBzR5K0hbwLljffkbQN5PZS3PeRxPH0H4HMG5U00g9sseZM8NHdUaLq+++6o/jouzYFymqazVZ0JmFgX/z9UKSsvF7RT2TmgVweQXuEo7jED+d69Bt8+vdrd5ONsUifOJgqO9AnqL+vOHkpbJW9PyON+3gt4Yd2ZqrRL8vbz0DxYoen65yujBpbj/neXWPwj4H4R5z3U4gv9KvFS1uIfQXjcPulnad+8cngLK1Qf8ZCm8COynq/kCa0F2f87cmhJ3XYq/5KsP7upnLtmEMZ8hV+8J/JxenI06QnKtpLzV+jyPR5f2HbpH8FBe7Mh8HNCjs1DTwrrysKRbdWG8NRiCdkqrM99p42Tsu2fo7RxpBksm43hd55+H+HB2djTnkb158aEs7vS1v9tEqb+nAd5bUpdeamnncr/3zb99c6m/tTGoibnHjOQl6Jy7lFwGi3nHsKZHxEH7RQGQVxaSLRYztJPIucFkLeQ6uGLYlgOV10L4b720qRGX2jU0sGrRulty9NBwWqn8j8HHVxdUgfnUx72AdoL5APlgOVfYvR2deSUz2vXTbDq3GraQJpSH2WFfcH2V8rfCjS3mabzie2aCfd465CmDwuVdmkyXWRqY6Oc5+Zgdxi/LrZT+VcqMtXmhYXEO9LelnhZUIN3Ht9YX8p1KfXqtSMaz7XG5AMFx6S8LMm6+wUYkw/RmPTpCPLM64iict5EwWm0nHmNsCgiDo4ZnheOI1osZ+knkTO+5Hsc1cMXWPll4Daqg+WRhkY/dF54+yi9bXk6KFjtVP6toIPv8qyLfTq4iPJQpjwv1LKHL6PywneH8c+37VT+g555QRuvqDc8L0j5j3jmBe3gAd+8oOmidoCCJtPjiNZMhRbKmecFTabY/pnUfin/6cB5Qepr8YjtKA/jEfMoD+MR7LPuBXnzKQ/jERwbwXgE27uDIQ91hOMRW3vaMx7yON6Hcbs9KA/jdntS3g6QtxflYdxuKuVh3G4/ytsR8g6Gtkrcjh8i/iC7X+fzLXUrRF5clMvhX2PC5gPsqwrh7BYRB2kdQji7R8RBm8zt2VPBkf7C8dKI55FCv2oGj90ycbK9CI/bV+7JCFoblgpSxXsoac5L8TxyKuRpkuDIObZpak49lIVR7g1Ryu9FtPZS6gnvbZ76SAPrscZU6H7e80ih0U7ln4HZagLN1hoWyoNnTOE9b2cB8yDl/6nsLGCa7Tnt2jOH5vAN+uXxn1E6TaPQ1No1ldrFPOxFPEj55xRPoI3KMD/aPfd/fNY7NYc/rZ+YV5zl8trD/STlh27Q3x7upz0UHnBMzq3BA5eZmsNDVeFBsW4zVpx9cWbdDF3auz/4f5Y8P7fdQ6GTd4k0nBaKRvLzDLZU2r2KGagBUte1XNY7fa9SLV+2cllO29lyV3Iwhxj9CplDSz5rCp5D+VlTvXOoFiPW5lBpuxYH7FbyeE03JxDH9eno7HfWpwtWrjg3r0tDJ9eKwhbXNzVoyf8b+MixtBqkeuRYzJVC5WSpIFW855N8rd6Osb9dexg6R6GpBb/n5dSrZeSGKOWPIFpHKPWE9zZPfaSB9VhjeITkuVLsckj5CTA1ydYuriP/Pxl+b5X99j1oqvNB96jQUSX0q6auUVzx6ZL2AK7YqGLTKijrE1Upg2XxWh84MznlNM09QqnHl0iMtWQqOKa7Zr9HmsHaeSTxgzz4pg/tZUQOleCmxrytL+6aQXkh21u0vP2UdmnhJN76MlOh6eR2+QYDy8V4pC9y1rZWoMay9dO2dgitBTVoHUW0tEd5QmthDVpHEy3tERaHIbV6GEKdG8AD3vO9eCvlupR6Zfus28Ozb7uW06E5G5gBbVsEedr4krM0+THgffBoYB6NZwwX82NA5JnHelE5H6ngNFrOPI6PjYiDIX5+PKU9IsIwvvSTyFl7vCT1ToA8frSkPcI6QcHW6AuNWjq4eAO9bZoOIlY7lb8CdHCpZ07x6eCxlIe6y/Ot9hhH64MK8Z33KCXvsdvp4FHx4yltvCJfRxBNKX8m0OTHU9rjJs1b8enicUq7NJkeT7Q0bxXbw7ZYkymOG26/lF+pyFR7PMWPktBnKPJ4KvQRFD9mQp+B/RftERT7DKwj4jPwCxm92f1OM3i8FPB41Uc2QmukGSxDfMyFecb096f2alG3Un9XD87EOnEmKjhdSj1pd51yDF7/C/1Yr3Zp/rUmF/Y5sa42jjiYOj77/9AsxuN08zbyZ7dCBrO/Ild8VFegnXuGylXoV4mXsnLdmvC4fSzX8Qov3Ure4fAb8xBnvIKj0eqISGuXiLSqEWmNjEhreJO2MWY/xmxjd5O2cb2ItGZHpDUmIq22iLQ2i0irMyKtmDoRczzGHEMxdSKmvIZFpNUVkVZM2Q+NSCum7Nsj0oopr5i2cEREWjHl1ay2MKa8YtqcdcFniqkTbRFpxZT9phFpxdT7mLIfG5FWTNnHbGNMOxHTB4gpr3ERacm3SCTGtDXk7Uo42pp/aw8O1t86gNZWCi1fG/OO6Il0CrWwyHtF5+awVlHoVijx/T3oXptSFmnjsVkN3K4zuUL0jBloug3RT71dp+iurcPgN+YhzjwFR6PVEZHWehFpzY5Ia0xEWm0RaW0WkVZnRFoxdaIakdbwiLRi6kRMeQ2LSCumvIZGpBVTXrtEpBVTV0dGpLUu9GN7RFox5RVzHhoRkVZMeTXrPBRTXjHtfUz9imlzYo7HmDoR02eKKftNI9KKqfcxZT82Iq2Yso/Zxph2oln9r3ERaXGYBNfVHCYpejoV1j8igJa2Hva1scFhEmFxNyo3N4e1ikK3Qonv88vqtcIkvCvn/GxXjoRFSu4qUneD8S4tDAfhbjfMMyYsUof1x3twtqkTZxsFp0upJ+2uU44jUH7IJ95D+lUzuM1lwkvaLjlNLtK+kuGsrooZPFTbFJq8885nVmT8dOTQ4p2hUv76TPe7zWCTMoMwQk2XWxKtGj2Qd23XYEg/I13NJIboY1kc1Cc+6BFly+PY168aDtbPe4FUdjy7C3daH0zlsZ81mhMgH8u/MusvF3KcmO0QrrWT/Z7Rfl657sGELeUXw072V2U0NTn3fZTADNaDOZQ3XsHVaLJtLNp32yg8+Ghhf21P5aUvOnLKCz3uu0eh73jHPB5go+nPnBweUH+Qhzz9ebyE/jwx2s8r192esKX8QaA/byL9wfo+/eHdvKg/IiNtbuWd1kXnVqzvm8P5wGyNd9885tvtrclIwzmqTpyjFJxGzw9HEc7BEXG0txi1JcDR8BvzBIfvMQ7W9x1COrFOnIkKTpuCMwlo8KM2KeMu8ZPmw/0CflJ7SL8g/SrxUhCvzw/U3gbVloJ8GCTW7VbyePlW9EBKpDU+Iq29iJamN0crtIrKqwHLymOo3NE5rLUpdCuU+P4xdC9vWSm0tSGZdxSEMWFDUjvnL9XQ13Am14kzORBnSp04UwJxDqwT58BAnAPqxDkgEGdGnTgzAnFebHqQqj2z6sSZ1WTtebH1T6r2HFonzqGBOKnsTmv8lGtPa/yse+1p4JFPwaFzoZ/6yKc6l4R9oXPft5CQH22JhrJ1qez3NXbK1vy8pHIX+2GhyzMXwto+oztS4Zf1vuhTS6wv5TScKXXiTAnEebG1Z6c6cXYKxEklt73rxNm7ydqTSg+OqRPnmECclj1onvZo3yvAxx0v2VDHxMcdWFfCrPzIdqNN+uu9jOaK8VA/5CUZ36MJrO97NMGPDLAN/OhtkkKzQnnI3yQPf1h/Uk495Mdd/I0HKeOuOrctBB9iw9sWdiyH5922gO3jcPVUhZduJQ9lmIczRMGpEK1afEUMCwuLk6hc3uHuFYVuhRLfn0T38sLC8n9RfexmVn0Ui09UmurvmBiHaeEh/Zrpa6fye238/F9nvi7KCoWcLcUH3veYoGv30GEp9GOdLaWpv+9sqYMVXrQnjQfBb8xDnIMVHI1WZ0RaXRFpdUek1RGR1voRabVFpNXepHyNjEhreERa4yLS2jwirS0i0oopr2pEWjHH42YRacXU+5i2MGY/Do1IK2Y/tkekFVNesyPSGhGRVkx5xRxDMf2JmPIaE5FWy66uPbsaU/abRqQVU+9jyn5sRFoxZR+zjTHtxLCItJrVX903Ii1+8Q3X6OMJR1sPT/XgYH3+fCvWq2R/O41ue3pM0NVWIXrCJ95D+lUzuM1l4gSa/DW5aG8BSd1uJY/Dd0UfXSMt/jioFqrVYhsVql+rjRFDgcLiZCp3VA5rQxS6FUp8fzLdywsFCm0tCr5fDt/GhEXBsf4kD86edeLsGYizTZ042wTiTKwTZ2Igju/FCzZxRV+I8D1FQZzpdeJMV3DaFBx8YYmflLjf+DSrY6OBPO0OeW1KXX55R8pP36i/XnWjgTJA+WxtBuZtDXn8lWx84sPTA34xvBFPd4R+lXgpOz3sQHjcPjSd4R9T41GKUkGqeK9iBlu2CnCG98bT/7ememU+UTgR8jRJ8Ee6sE0Tc+qhLIxyb4hSfgeitYNST3hv89RHGliPNaZC9/M+USg02qn82GxUaV971rBQHvzgTHjP+4Iv8yDltwQe+CvCO0AdrV08mifS/9ES7JODPwWszPiNdHyj4HP7cHbI+5LyDsSDlJ8AMuAvQ09S6puceygDrJv3fyy7FbUF/6/p4s5Ufscabef+l/I7e/p/G4UH4ctdc2vwwGW2yuFhssJDfV+RZivHvcQ9sY1CJ+8SaTiNFe1l6fDoYBz5v6YB9X5FenwO5hCjX11G581dnaauuTJ4bhb6VaNrXo8JuipsPQWP28dLtx0UXrqVvLxRWgunzq9I503amrHg+obqVpR77sIjamWixtUlL4e0lSPe8y2HpJyGs2edOHsG4mxTJw7W9+HwcqgozsRAnPF14oxXcJhW3hLixOx3O5VfAIadv+6Hy3um6S5+YVSLxoxX2iPla53xwLLEaNGcAGyUJU+ERxTkdZ5SXosmjVT4m1eQ16MS8+r7GmEDXrQInnKEfnN/Wxs1lqWCVPFexQxsPebxzML78WbT/8ssB2N8s9mnWUa5N0QpP49ozVPqCe9tnvpIA+uxxmj13P/PVur4RkCIBruLnZj5EWktUGjJyFwI9wuMlI1CR6bQrxIvZUem9v1m7RUfabv2nehuJY/j+IsUnEUKjkZrr4i0pkai5a4ZLVotWi1aLVovcFras9MFlIfzp6w+tNUBr1CLPj/H+lM9ONPrxJmu4Pie0/NfweF7jKPxLO3BuZvlVvRkJKzP3yffHfLwYdibN9IxcSW7O2DKCXztVH57eDfibRvltxHlLO1injsBQ/IK+DUj3Wp6JzrJD30c3kuqjR8sL6t3zZfwvYbE33rP64MPUB9MhTytDziaIOVHQR98mPoAsfEV8bxxo+GxjnQo5ZEe68gnlMcIGn9H5OChPFDO5+bgfUaJrmh6J9h16t1Gmt7heGW9C/W7Q/QUZaLpKUdsdldooR5wxEbqdxi9D4ReO5X/utLnIXqu9auU/1Zgv0ayJ2q/oqy4X7XImjYP+fQA+0tk0m0G93leJBJpYV+H9OvuCn3u1596+lXbUIF8cr9K+V8E9qvIshH9irIK6Vcsz/2qzd/YryKTbjN4ntyBaGk22hdh1foV+4BttJT/k6dftSi3zw5L+aebwA6jrEL6VXsSENqvbIexX2dSnm+vYiob/X9Kn7PPz3Yhjz9NbnU+3ONn0fNy2NhQqW+oboXubZhDS+i4exhWZZFLc/MOvmaR95nTzFXTdlTsodR3l2aipD11vmoc/FCAXzXevRye91VjzaQWfdW46LTYAFV11+wcNipKfUO0Kso9zNNUFZ8Piqpq2yFxhu6glQKqEK8UNMunef5SXjzQPO+CD6iS8hsrw4NpIg/oQbG1PlYpj54xb5PFNhxLeVjviBwcnB3R8vPsKOU3h7b6ZkfBbsTsiDLi2fE4yGtTyrO8j1fKHwdlOKp0POTxkEYZH0s4tUwH67+mp9rqW/PG9zT57a21KmP9Qp1YRHnaak7TBSnXiEgJtod1wTeW3MWy8ekOyqbb1NYTHJeLCMdnl9zl0wWMLkg0rBNoI06PCbomCI729FlobwD3C/TZUuRJLm2qFvpV4qXsVL0B4XH7eKoerfDSreRNg9+YhzijFRyN1vCItGZHpDUiIq32iLQ2i0irMyKtmPIaE5FWTP2qRqTVEZFWTJ1oi0irEpFWV0RaMXWiOyKtmDqxXkRaMe1qzLEdU1eb1a7G1ImY9ivmGIqpEzHlNSwirZjyGhmRVkxdjclXa95ee/KK6a/GtNExfYBdItKKab+aVSdi2olmnYdirmFitnFURFotu/risF8x+3H/iLRiyqtZbU6z+oVDI9KKOR5jzrUx+7FZ/dVDmpSvmHZ1bERaMe1Es9romHzFlH2z2omYPvm6sK6NOW+v36R8xVzXxuzHmOMx5homZtw3Jq2YOsFjqJL9H3VlAvzeDvKxvHwop1PhscCz25PlWSwf/4K0h5akXSF6xgzk0xD9LgVP+Krm5PUY/3XD2z5x/5w/fu63FaovvPA93p/QoZTXnmmLrPA5SAFZnaTt4RBsyUMdGUp5KBfhwf09aNpA/jpK8hciP6TfrZSfAeWK9MUoM9ieipxkXwzuQ+O3pHwfVEQc7S2p+R6ciXXiTFRwmFbeB7T4DR8pv0VmF7TzQhYo/E1U+JPyvrdPkB9NNvxmE2JXcv4KDt9juSEPexLOwog4uNdqDuEsioijvcWu7burFwf3VfHbjMdFxME9WuMJ5/iIOLgvcFfCOSEizglQ5mCo5/6/GPK0j7EtUfgQW3wS3C9gi9tD2oH0q8RLQby+/V0nER63j/d3LVV46VbyXg6/MQ9xlio4Gq0dI9JanP0eaQb3NX/McbGCs9iDMzkQZ0qdOFMUnC6lXr1jZDGUmUw4J0XEwTEzhXCWRsRBPdiQcJZFxFkGZSYQzjyFB+cPHLNJ/32XToG8NqrrLnkTv53K/2J8f72XZDRFB5cANvKI9dEfW6K0g/FOoDXLqVCngD0a8HzKEK1asltMslsCeSGyk/KfBtktJdlhuxabgXmnQd5JlHc65C2lvDMgD2lgnoE24D3WOawv5bqUejxfLYf7BfpraMjYQPpVM7jNZear5YSHbXcXr93OLIfXLnhnKXhaP6xvdJkivtCSMabZ2VMpD23jGZSH9ux0ysPxvR38Rpp5beKTyBZDfdZv5G8B5aFPv5Dy0A/n9yHQd+Z3cbDN7N9Km4cSHXfNyP62U9lV8HHiK7Pfmr1hO75EoS15pyh5jv5tYwe2BW0KyhHz3NWm3PPNoVJOwzmwTpwDFRymhQdj4xqR7a6Uf4TmELRlBcbsKSL/0+Em27uS9ueUUHuXZ3uRL80WhsS92j/zyMfef/oz84vOET7beaBSvk7bqca9BFuLe51BeRh7Eh60uFfJueukEPkh/W6lPJ9AWXS+xryjI9Fim1svrUUlaUlsD30f9m+09+dwXuI5aIGHr1Nr0DqKaGF9tmGn1aDFJ2CdqrSR/RIuN1ShzdhdZnDb2JaVtJPBsQahX1XaUMZ302SrzTVsx7Fut5LHOn+6gnO6gqPRWhSRFsdLY8QxNR0+gHguejIc1l9EeQsVHF4zu9+4HvvwJjo/qPe43ma/QMq/c3x/vY/Regyxfb4lx3S0+Lf2HrkW0/HhzKoTZ5aC0+j4N8d0TouIg7ZpFuGcHhEHxxvHdM6IiIPzIq8FFik8OJ39No2D5ZCnjUuxY+1UfiGMg+95xgHyiPXR19JiU4z3Y/LHS/qBakxHaNWS3U9Jdri202THNkTK7w2y+0UBG4K+5WmUh/I4nfLOgjykgXkG2oD3WOewvpTrUuqJfKW/zoH7jYjpCP2qGdzmMn7BOYSHbXcXr0suKIfXF9O5UMHT+gFjOihTxBdaHNNBO7uM8tA2nkV5aM/OpDwc3xzTWVajTexPa/z5YuFry+dcVg7P63Ni+8r6nPvAb8xDnKJ+YgxaHJ9bG77QlDpxpig4LxZfiJ9vrSu+0MZj+u+jfQ+dz6X897bur7dpRrORvtAWGcba9IV6SHZlfaEPguzGk+y0rztocmVfCH0U9oVQVvy8UfIMtAHv+Z6pstywHs9XJX2TYF9I6FdNXfrRN19pPqI2X9Xp6/X5QhcoeFo/oC+EMtX8Ip8vxPEFtI3s76A9y4vFut/sCy2q0SafL8R7wDB24f6/GPJnmP72YtnHYJztm40zbY/ZMWZgHur4YsDdn8YqyoXjl0V9B6x/OvETY27SnnVzvKpojBrr8zPR0xUcntPZvs4eo/OD9hX9AbavUv5O6PfDqc8Qm+0k8sw+WtH+nByIM6tOnFkKTqN9GvbRGuXTcLxqeUQcnC/ZRzszIg7OQ+yjnarw8L99NDQOzoI8LV7P8SopPwXGwVLPOEAesT76aKcp7WC8U8lHKzknqj6a0Kolu9NJdqdBniY7tiFSfhOQ3ZkFbAjOyWdQHspjOeVhLANpYJ6BNuA91jmsL+W6lHoiX+mvC+F+I3w0oV81g9tcxkcLjR9J+y4qh9fno12s4Gn9gD4ayhTxhRb7aL64B9rGCygP7dk5lIfjm32002u0iX00TfcbuN8jOF4l9KtmsBzL6JbmC2nzMM9NWFfrG45XaXtBtJirRuu0iLR8+8nYF9L2rZ3kwZkciDOlTpwpCk6j90mvrXhVo3wu9oUa5XOF+kJraD4/E/JC5nMp/96t+us94lnH8bOiM4GeUcpPyMF7nHyhkvEP1RfiZ1B5snuCZHc65IXITsrfD7J7k0d2PLZx3uF4VaifxL6p9owK7/n8b/YhsR7PVyV9k2BfSOhXzeA2l5mvQuNHdfp6fb7QRQqe1g/oC2nP65AW+0JoZ3lfNdpG9nfQnvFzPRzf7AudVqNN7Atpe8aYFr5brsWceN3x6Wx8ubH2SYpZafuUXbk5mw4s1/LDBtbV+n4F/MY8xAn1nZZGpNXyw/px+F4RP6xR/hH7YS+2mFRebPZXATEpX2xWyu+3VX+933h8iZCYlM8Pk/J/TBiTypPdnwP8MJ/spPyWILu/FPDDWjGpfj7xHtJvxaTyY1I+P6wZYlIaf0wr1A+T8sMyn6pOv0m1G/xuUstfG1iX9cdd/J5PPT7Wsoi0Wv5aPw7fa/lrcXDK+Gs7bNp/H+egov7aR3v66+2Y0Wykv7Yb2d214a/tTrIr66890tNfb0+SXehZBeyvafvaNV+O58GicTOsv67FzbT56oUaN/M9Q2SfTHvPIcRfixE3C41xMWaeX7eI8qX8kZv205xHcTPk61TA/k4rvvaiia/xmQxIm/21pQrOUg/OZIVnDWdKnThTFJwupV4l56/g8D3G0WTD4zQGDo75F/tzzjyf42yyb9pzTp/PIeUP7umvd57HX4v1nPMi8tca+ZwzT3aXRPLXJvT017vcIzse2zg3sn1pPed8/mo958z319DOcnwNbWOs55yn1mgT+2vIn++sIbnn88Ok/CvJbpT0Y1S7wfvStPNk6zwnL9hfE/pV4qWs/mt9p50pwb4q1uU1nrs4vlbPu4/LItLy+VEtf20gjs9fWxYRB/uX/bVG+YXsrzXq3YZQf+2d5HOUfVfls1v213uPJ0bE8ZwzgJ5Ryk/Iwfsg2V2cJ+q1u0KL7S7L7sM5a/nQ9yil/BtAdh8j2SE2j22U0zLKwzmVfbmYe2+xPstNW4vU+d5rsL8m9KumLv3om6+090t954SWXD/0+WuhZ1igv6adDYq0fP4av0eJtpHflUR75ntfjv21pTXaxP6apvtajAvfqfwO2YWLoVyBfrhEcC5RMiXvUqCNZ4bx1Ub/R77cOYRzp/XT5XKMiX12KeVhn11Gedhnl1MejuErKA/780rKQxvTS3k43q6iPNTTqykP9XYV5eGaazXl4VrlGsrDtcu1lIf7Bq7Lfov+oe4cAb8xz11tyj22k1j/YuIB61Vy/goO32McjWdNl+vFuQTKbAj1eFygH+XzrWS8Xgb3G7GOEfqxziC8jPC4fbyOuVzhpVvJ41jx5QrO5QqORmtZRFpsc/J8o8pmAzGXQl6IbyTl7wLfqD2jqa1tLqE2aucXLVXwKtSuDqU80mun8tWMJ2fHt8rsuDZGluXwgnbUXb51TqcZPL4aMUb62mYG60+ZMXIp4XH7eIxcpvDSreSx76qNxcsUHI3W6RFpsa+SN0bGRBojl8MYGduEY6QnwhjBvYchY6Qe/xvpCT94D+nHGiOh57RovifHTDGPn49oY/FSBUejdWZEWqFjZJdIY+TlMEYmN3CMiLxDx4iU3yvCGME9uyFjpOSaOHiMCP1YY0SLTfjGyJkKL77nTBXKQxzfWVJI64KItELHyKxIY2QejJFDm3CMHFFwjGi889orRjxZi6vtBL/zdNcXV8P6rLvLFJxaOnLsZjo/eToi37PjPtgfdOQ4j45wHyDP/LxD0x9tXGvPO3w4e9eJs7eC0+jnEPy8o1H7OfYmnEbt8+XnHWdFxEEfL/TcyLNpHJwDedo44G+oSvkfb9Ff7zzPOOD3jTgWy+Un5OBdlGHUud9Bfd7B7zHlye6SSPPMx0B2lxewIaHveJ1JeRj/47lee88J77HOYX0p16XUE/nWGYcOft4h9KtmcJvL+FpafFPbLyLtu6QcXt/zDm0tofUDPu9AmSK+0OLnHWhnl1Ie2sYLKU/z7zQbFHKGNrbJtz8lZL5p+fED886D35iHOEV97xi05BlDa+/H4HtF9n40yhfivR/rii/01oK+EM/nUv4kmM/fQfM52ooQX2iZ0g7Ge28T+ELvJ9ktg7wQ2Un5mSC7D3lkx2P7hewLlXxXPNgXEvqxfKHQvbN1+np9vtAlCl4tX0h7/x1p+fZ+LKO8ZvWF2hT+sByOPW3/ilHuVTx4jDFEqbuS+Ma8YwijaAzoGIXfBu6tagsdXyn2Vmly0faI8BnvmMfPvbVnLNqZFhqtEJ+nU8FthD8u9KtmsO6Wkb82No+Be2zf6tGvvH5Y7sEr+a7FEMHT3rXQfF1nTzvM4D6sta8OMbC/8sY8YrPd0+yWb5wgLf4u6fKcNuT1gRaz194NwnfiMa8t+x61s8N/3WxgGdnj8Nxm/WX+lv32+cMxvkuB9P7HJ91D+o38Bplma5zOrWf8fa+dP+l+a+/XIzbr4mk1ePLpIr/frM2X/9v3M7ZcOW2vpys31FPuNKWcimX07/2yL96Z0XD9ccO0gbLA+vzuEH6TvE2553sfwPeN+8l14kwOxJlSJ84UBadLqVfJ+Ss4fI9xNNmwXsTAQR3j2ECjnvtwbKBR5y9zbGCpwoMbM1uO7b+PtgZ9bG2+4HdRf715f72tM5qig9q3rhkPYwOnKu0Y9O5rhpHivKs82e1AssMzGEJkJ+U/B7Lb0SM7Htva96e190L4+QrOObwfrujaRXtHu4Frl6Z6L8R37soL4b0Qba7TbKNvXwK/F4LjO+T7Wr73QrS5vM73by/g9wjw4piWNs9hjGgGlOOrjf6PPDu/4+YC74JgX3D8DfviIspD28H7YbCfLqE8bS6vU+7B/rnQr5rBOlBm3Grv8mo+jvaui+/syPPhN+Yhju9bZEjrpIi0+Nz61vl++Ti+8/1a33HNx/F9xzXPVzqdfCV8ly/EV5Lyp4OvdCb5Smgn+TuuS4GeUcqznynlzyU/s2TMT/Uz+dk/2jqU3coA2aFNy5PdXJDdhSQ7xOaxra3Ftfg9f1sMZYU0MM8Y/94AzR8psmei5HtfwX4mn5dR756J0PMyYuwJcUnza7V+QD8TZarFr3zn+y2gPO3ddt+5GpoNCvEzsU0hfqbo1jwFR/KWQB5/b/wUpc1u3N1G4w6/ITuD2lH0++czFH40nGOz3+3UxsfJ1pU8+2X/LsIRGkj7pJK0Q8dlnt+AfFWVvPYAXv4x+sCd/rLm6fsrVF944XtDgD7qMpafoZSvc87ZtwswDGFLHs6HJ1HeUMgTHtza5aBpA/kr+Vxq3xD5aWMf8/j7dEV9TaS1sCStUWagXuHYkfGHduS47HeXGTymeZyUHIPB6y2hXzWDZVBm/tJsr2az2EZg3W4lbwX8ZtvSptwb4qE1LyKtJdlvrZ95vTVPwZnnwZms8KzhTKkTZ4qC06XUq+T8FRy+xziabFLH9Y+NiIN6wOut4yLiHAdleL2Vt2b4LK0ZToK8kDWDlP/TuP56X/D4Lsgj1sf5ZaHSDsb7KvkgJecWdb3FezvyZPd1kt1CyAuRnZT/GsjuWx7Z8djWzrzR1lvHUh76CRxTKrrewvrr2npLm+OlfaeVw+tbb2nxyCLrLW1fAK+30M4upDxtHa3ZM/a5cHzzemthjTbxekvjr+ULhflC7joYynFeUf9lcURaPh+l5QsNxGn5QuVwyvhCneP676N9L+oLnQvz+fDsdyN9ofUzjLXpC21AsivrCy0E2W1EskNsHtsoJ/aFtJiO5ifxul6Lv+A91jmsz3LDejxflfRNgn2hFPuDtfkqxlnULmn7FLV+QF8IZar5RT5fiGPP2l5EzZ6dRHk+X2hBjTb5fCF+7o5xYy47H9qLZXeEcXbUuHys44mP+ZB3AuWFjk+kgfJFW4Hl+Z17Kb97xreLNd45Tac5xOg6KvZHi31KOzoBV/IK6O/HHF87wf4N1Bd3YdwU9cUYv08l5Y9XyqPOsW94POQtJlqaPqJ/IfqoyUt4bIS8kIcQeWnPwELlxeMe5bWEaGn+L8rQJy/co+SumPJCHkLkpe1xCZWXyECT1ylEq9YaZy6VF9odRrcJvGdbys8Dm8BnAvls/HyFNtrGCtHAdmyvtKOL8rCuo/uSzHlKFedhX1Pbg4r2G/dBYPmXwbyxgmSjzdO+51tajAPjFryPFefxvO/husvnk0h53/fBNGzki/fI8N4czd/Q7IDIpk47MFSzAxivYjug9ZN2Rq1PVlo/ac/ceW9caMyJ95mGxpzwPY8VOWsSbEeezebxgOsZXuto6wSf7mn+M45j1j0txqqNf7Yb2r4abSyx3cC+Zbuh7cP3fZ9Byl9Oa9RG7MNn/W43un7nfXfhTrBtvTm2bWhBmqtgPtqG9vJqz9vrtAXtmi3A8c62wGeD3VXUbvK49e1f1Z6bo0zZJxAZdSjlkR7vzbs10Cfgb4qGxsB96z4ZD07ub8v4qLUH8pWke9pZEmhz8s6SeCfo8720xothN46jPG2Plm/O0fRMe3eA3zXU9tzWue88OJbC+85LPufx7jvXnvPUaTf7YinLFTytHzCWkvdeqdASW5XarqGcQuya9qxJ20PI4xltBNsBbc+r9iyG8dBGoC/+tpwYNLYj1GfB+HUnjX8cXzz+cYzz+Ed9Z78BZch+g/YdKbRB/N1jKf8BsGFfJtlouuzzY33nSiA/2rtxZwbQWubBPkspf6YHG/ni9+D5PCptTGpjUWTTiPUG+gU8FrV+0t5T8clK6yftXA4+/yN07PL7aTi/87hG3cb3YL+cM29jO7QYb61341/peYbUzLGC78LY/X0rVjAIm/lsxQoG5qWMFfy+QbEC3iPWihX0/86LFfzrBRAr6IZ3pJ6NFCt4rhUr6MtbW7GCYVm/ru1YwU4ZH7ViBaM2H9jusrGCXUGfN8x+t2IF6tWKFRBeK1awdmIFO9HYjxUr+CztQX+hxAr2Aht2GMmmFSvIH5OtWEGxsRsjVnBYzryN7SgTKxhFczfyze/ra2NKG/P8vv6piiy4//JiBUKXvyN0NIzdU0g2tc65LDp+eM2kjR8fLd8eI985jxq29t0x5sUofEq9Bs6j6tjF8cljN/TcXp+stH7qpvIoG+09JN73pn2TXpvLecyjbuO8y/qp7W0KnXdxrxGf37GsBl2Wp/aOEo5jnje0GIrvHTHfOX2+M+M0XWe7gWfIGqU8xwqk/PlZX9R5LqwaK8j7DiDGClC/eW0l5W8C23ZRjm0bWpDmpbBO9cUKpB8b4VPjeGdb4LPB7ipqN3ncYt/wmTGh58fxOOswug+Rdz7stZ5YAdoj9jPQHnEMRDurUbNHGCt4PcUKcOxirOAW0j0tro82J+8cyjeCPt9O/kYMu3EG5aEd4LN2i36HB+vjHMr1xA7UeU5jcKxA6FfN4DaXiRVo409b78Q4T9sl7Ux1rR8wVqCdPYm0fLGCRto13/OQWnLltTu2kccz2gi2A2gj2H6c7sHT1ndoI3w2MnS9gT7L6Z5zaHn84xjn8Y/6zn4DypD9Bu0bRWiDcM7G8u8AG/Zpko2myz4/9kKlPH5zh5/DaN/J8dHyxSkuUspf6MFGvrAuY+eNSW0simwasd5Av4DHotZP2nd4fLLS+qmbyqNsio7dcygP53ce16jbZ0GbP50zb2M7tHil5g/gnH8Lzd2NPkOaz/TWfF+0M0KXfd+vwtj9BclGs8/a+ctsP7A82hteM/m+E67R8o1dn/5q2MgX1mVs5lPqaWNXZNOIsRtzfaDJSuunbjN4XPMYDD3PmscnjiPfedY47/4iYOyGzrs4dvlMee1Zq0/3fHFWTfe089u18e+LrbHdQB1lu4F9y3ZD+04gls/7TuDTFCtoxHcCWb8xVoD6zWsrKb8efP/vmRzbNrQgzX8ExgqkHxvhU+N4Z1sQ+m2cULvJ4xb7JmQvGMqUYwUiow6jxyxxzwuWH5L1qxYrQHvEcc3Q8/V575S2z8bJfduMD34W435jrKC6xcB2a3F9tDmse1J+e9Dnrux3TLvB6wgtZuSbczQ961bq4xzK9cQO1LmWDo4VpPg2lbbeqdNu9sUKtDWO1g8YK9DWIkjLFytopF3zPQ+pJVdeu2MbeTyjjWA7gDaC7YdvH4MWY0Ab4bORoT4LPvPckmIFOL58z8V4/KO++9bW7DdcALxoPg/O2Vh+F7BhB5FsNF32+bG11usc+9TW6z5avjjFxUr5izzYyBfWZey8MamNRZFNI9Yb6BfwWPTFaNwVIiutn7qpPMqm6Njl7+fi/M7jWosxaPpZaz8Fj928+GGV5m7fc8UY36Lm5/AXAS/8HB7ptlP5OTB2TyTZaH3six9p32HGfmc7hWPrkgBavj1BlyrlL/FgI19Yl7GZT/z+j2BJnsimEWMX7QmPXZ/dcleIrLR+6qbyKBvJw7mM44M4f/GYD/0u9oXQZtZP7fl/3pk8PB5wTxB/m15bP/l0r1Z8m3VPi29r45/tBo5/thuoo2w3sG/ZbvD3zrk8xwqk/JlZX4j/iTpSb6zgUuLxYuBB029eW0n5VWDbzs6xbUML0jwP1qm+WIH0YyN8ahzvbAt8NthdRe0mj1vsm5D4LsqUYwUiow6j+1sYx8LyV3hiBWiPLibe0R7x8wotbq3ZI4wVPESxAhy7GCu4JscnRt1Dm8O6J+UfBX2+nvyNGHbjLMpDO8DP4bQ5R9OzbqU+f0OPfWd3iV1BXWxErEDoV83gNpeJFWjjD+cHjhWUtJt9sYLLFDytHzBWgDJFfKHlixU00q6hnELsGpbntTu2kccz2gi2A2gj2H6c6cFDG4G++EM09jUbGeqz4DrmrZnPoo1xHv84xnn8o76z34AyZL/hUuBF83lwzsbybwAb9mGSjabLPj/2cqX8ZVDmAmoP6vrlAbQu9GBfoZS/3IONfGFdxs4bk9pYFNk0Yr2BfgGPRa2fsHyIrLR+6qbyKJuiY/dSysP5ncc16vYl0OYPB8SycN7msavFfNAf0N4z8MXrYsUKNN/XFyuQ8p+FsfsDko1mn32xghjrdR+tpR5sn/5q2MgX1mVs5hO/ByxYktfIWEHM9YEmK62fus3gcc1jUIuJFZl3NVuRFytg/VyqtCN03l0KdC8JiBX4dK9RsQK2Gz6fv945H3UVy3OsQMr/lmIFqCP1xgouIx4xnqHpN6+tpPxzYNv+kGPbhhak+ecmiBXgeGdb4LPB7ipqN3ncYt+ExApQpiGxgosV+hwr+LcnVoD2iOOasWMFm2/5/O9asYLKlgPbXTZW0LNlf7327HdMu8GxArQDHCvQ5hxNz7RYAc6hXE/sQJ1r6eBYgdCvmsFtLhMr0MafL1ZQ0m72xQq0NY7WDxgr0NYiSKsZYwW15Mprdy2mqdkI33qD7UdorAB98c1p7MeKFZztiRXw+McxzuMf9Z39BpQh+w2XAS+az4NzNpafADZsX5KNpss+PzbGet1HyxcruFIpf4UHG/nCuoydNya1sSiyacR6A/0CHou+GI27QmSl9VM3lUfZFB27l1Eezu88rlG3MQa2b868je0oEytgf0Dbr6DZhArxi+V965Na+/19ew3PoTxtHxLj5L3Xe2L2l/coz8zkUcunFuw69X1ko9+5qbUe5P0waLt9++8FU5sbcN/KsTQ3YCyK92T4dI/rIn8dOeXxzCMsfzT08VbTdJrIg+/ZvO89Ck2fsQ3s42oxRMbJ0+cTqK1S/rhAfY60L2zE2t57zvqsPbfU9oyxTxErnjOrCfX/jHVI/89tcv3X1hI+/a8VI2H9R/9tbej/LgX0/1IPpqb/0rY8/cd4Ipa/2qP/mnx9+l/rGaFP/y+nPKx3cQ4O6j/Ki/Vfyt8QqP+C3Qj9Rxmx/vvWTe4qutbhZwLov/v0n5/XxtL/MQX037ffUNN/aWue/gs9jpff59F/bQz63mMs+qwL23AZ5WmxXsbRzhlwF+u/lF8TqP+C3Qj9j7l+rRVn4D2yODZ8+s/POWLpf4X0/zSlnPY+mu89dj4rS3v/z+c3+HwkKf92iA19KiBu5jsjsZbP6nu/5oIAWr4zoGM8D2RejMInrgcFS/Iivf81tNFrC01WWj9pa2WOG6Gd4zMpfe+V4BkQ7MtpZ1do+qmd3xw6dvHs9A9vOpBurdhQ0TNc+d1R7QxXbfyz3Qh9j53thva+H48z1FUsz8+ipfw3sr6Q5xuoIwV0XX0Wzc+98Jmkpt/87E7K/xZs27dzbNvQgjS/FzjPRjqrpn1tx8143GrvplXo/0gLZcoxVZFRh9FjpHwui5T/peLXafbI9wyKY37aWbOaPcJn0ev1PP+b39F1v/FZ9O9J98qexTisp7/en+hZdAy7wedhaWcd+OYcTc98z/o1fRY7UOc74MHPooV+1Qxuc5ln0aHn09VpN/ueRWvv5mr9gM+itWckSMv3LLqRds13jk8tufKzYWwjj2e0ESGxf7YRGh7aCPTFxUb4bORpCt0uysO6ju47M59FG+M8/rXnR9oYZ7/Bd56Jtp8GbRDvI5Lyo3r6623TM5Cmpss+P7bWe+b83F17d8ZHy/d+fa13dH3vB/HeG35vRxuTDXw2N7TovhDf2QLuCpGV1k/aOye8Fy507PJzapzffWfl4dkNrJ8+P99dPHaXK7yiPzBSwffN3Tw+NV/Jt9+9orSRbRDSZZ9/557+etN7BtKMfT4Fr5mKnk/hO4uvlt1gbM1uMC/G5M+tL+bzKXjN7zufAscunzuD45NjDNrZKdr+E1zTTe8Z2I5a3xTzzbt4tswlFCvQngvWcw6k77xa374Qthuh87rvLBa2G+wfcnmOFUj5eT3P/xX/s+S7oWqsgOdxPKdJ0++8fb7Lep7/6/r4qB6dZtG9wwszOon22LQ3eh6vZTd53GrvR/jmUm1fF4+zDqPHKfj8ZSm/uOf5v7ViBUX8BS1+p9kjjBWs6nn+N8dz3W+MFZzSM7DdZeNU1/b01zs9+x3Tbvh8a35HQZtzND3TzifDOZTriR0Qu4K62IhYgdCvmsFtLhMrCF2712k3+2IFoe/UY6xAO7MHafliBY20a74YaC258tpdO/MlJJ6INoLtxxkePLQR6IuLjfDZyFCfBdcbZ1OswHf2M45xHv9a7Fdb37LfoL0nizYI52wsf0tPf701PQNparrs82NrvSfLe7SKvifri7HX2jvgewco1nuykd4hWevvybL/73tPNnTscowB53fffnc8n4L1s9YzWR672jNm9Ae0WMFJZmBe0XiANubZT9N8X+1MQPZ9n+jpr/ehnoE0Y8f5QtbrPlq+9VqtOB9jt+J8A8tr/RQS5zsJ8jhWEDo+ecxr779r+hkrVrA7xQo0m+DTvVr7aXxnUvO7UFiP7UbReICm62w38Nwao5TnWIGU/0LP83/rPLdKjRXwPkSMZ2j6zWsrKf+znuf/uj7+co9Oc2hBml/L6NSKFUQ676K90Wdj1rKbPG595yVoMTbtPVQeZx1Gj1lyfFvK/7Dn+b+1vrPHcU20RxwDWa7gavYIYwXP9Tz/m9c67jfGCn7RM7DdWlwfbQ7rnpQfslV/vV9nNGPaDd7jpMWMfHOOpmfac16cQ7me2IE619LBsQKhXzWD21wmVqCNP229U6fd7IsVaGscrR8wVqCtRZCWL1bQSLvmex5SS668dtfeJdFshO8ZBtuP5R48tBHoi4uN8NnIUJ8F9yvsQLECHF88/ovGA7S1NfsN2hkxaINwzsby1a36643baiDN0PMhpHyt9To/h9HW6z5avjhFrfdsGFs7i495MSZ/TGpjUWTTiPVGzHN0NFn5zqDA9wf4XfXQses738Z3NjfGwFg/a+3Z5LGrfaME/YEXWqxgOxi7+5BsWrGCwXy2YgUD81LGClg/Y8UK/jxmIN1WrKD/d16s4JCsL5o5VnA82LbDcmxb0VjB3IxOK1aw9mIFx0IfrM1YwaUZH7ViBSeS7pWNFVwB+nxS9rsVK1CvVqyA8FqxgrUTK7iUxn6sWMGvMp/lhRYruAZs2L0km1asIH9MtmIFxcZujFjBvTnzNrajTKzgRJq7fbGC0O/g1vsOAu7JyHsH4WEYu+8i2cR+B8G3/7HR7yD49l613kHQ+ynkHQRfrADnuRjvILB+arEC7Z3CLjN4PGCs4AmKFcR+B8F37ojvHQS2G774Q+p3ED6R9UUzv4PwPbBtn86xbUXfQfhcRqf1DsLaewfhm9AHvlgBxzm02Hk97yD8I+Oj1jsIPyDdK/sOwr9Bn3+c/Y5pN1rvILTeQfgf8ezvi/UdBLQRbAfQRsR4B+EfNPY1Gxnqs+A7CGsoVhAaK/Q9r0vxDkJl6/56G249kGbrHYT8Mdl6B6HY2I3xDgLrZ6x3EH5Ac7f2DDP1vgLt/Uz2fbeAsbsbySb2voKQ9bqPlu9sw1rPxxi7ta9gYHmtn0L2FWBMjPcjxN5XwPqpnW0YOu/i2YanB+wr8OlerX0FvjNJfPsK2G40076CaVlfNPO+goVg2w7KsW1F9xXMzOi09hWsvX0F86EPOFaA9qjR+wrOy/iota9gEele2X0FF4A+vzT7HdNutPYVtPYV/I949vfFuq9AO8usUfsKzqOxr9nIUJ8F9xUs9uwr4PHfTPsKLgcbdjvJprWvIH9MtvYVFBu7MfYV3J4zb2M7yuwrYH8g9LzTCvGL5X3f5dBsjm+/guYLac85Q76vgG1bkP3lZz/3B/rUjXwWjzJifa8VIyq6HuSzdn3f4NPOzK117u1smhsqUO5Q4rViBvNaUdrWnVNfo4X9MgF+bwf5WP6DtJZEeRbo17ldUMcADaRdUmfmYlvl0vxJ9J00PHdVlbz2AF4+sfdHD3/4P7uPqFB94YXvsV4OVcofqpQXWXUQ7z0m6DpcG7uCLXncdszD8Sc8uDF70LSB/A0tyV+I/JB+t1J+BpQr0hejzEBdQH2X8boM8hZSHtpm3zmYITFntm9otxdBGX5mL+U/Ab7ctwPmSvSfWTd9+52QH229e2EArWUe7Fp73BhbW8syL8bk+wDa+BDZNGJu8z2DLfotDE1WWj9pz2w5lrQQ8pZRnm9fh/btG98eNE0/lyntWAT3fN/FWQZ0eyh23OhvZob6Zmw3cPyz3SgaO+JxhrqK5Tl2LOV/SfN9yZiLGjvmPaf47Z4isbZ/g217MlL87ndp/dz2Ru85rWU3edz69h4sV2hpayseZx1G97GFHn8f5m+e2DHaI15bau93aPaI/XccMxg7HjP++d9dZvDYxdjxsznxI9Q9tDmse1J+7Pj+es9R7DiG3eC4kvZ9JN+co+lZt1If51CuJ3agzu/GBMeOhX7VDG5zmdixNv60dWaddrMvdhwaq8bYsfYsHGn5YseNtGu+9XstuXIsV3uWqtkItgO+vfGne/DQRqAvLjbCZyNDfZblQHdjig/g+OLxH7rPNCTmzPOGZsN4zsbyW4MN24Nko+myz4+t9dzT9yzskgBavvhQrT1ujK3tcWNejMkfkw18jjO00c+nNVlp/dRN5VE2Rccux4dDY8743If10+fnu4vH7pkKr+gPvNBiBdNg7B5FsmnFCgbz2YoVDMxLGStg/YwVK/jpJgPptmIF/b/zYgWLs75o5ljBBWDblubYtqKxgpdndFqxgrUXKzgH+mBtxgruCowVXJTjcxSNFdwD+nxp9rsVK1CvVqyA8FqxgrUTK7irQbGCb2c+ywstVvAA2LC3tWIFg7DzxmQrVlBs7MaIFbytQbEC9gcWKXSXKXQrZrAdkvK+fWbaPjaUh2CJrmr7l0Yq9Rbm4GgxCHfxPjMp/8FAn1qwG6HvKCPWd81mY3mWt7Z+RF+Z19fanj9N3wVTeF6m0HS8f5jmhiVQbrEZmHcK5J1EebjHeSnloY4gH9hPqAfzoIzQbafyX4K54ac0RjQdPgXucR/4+gz50fQ6ZF2zxINdq/8ZWzsPg3kxCp+oD4IleSKbRowVtD88Vny2xl0hstL6SRsr7NcthrwllHcS5PHZSUshj9+xRN3GdxNZP5co7ZgH93humKfw+r/3BygWdapC16d7vncvNd07RWmfNv4XUx6Of7Ybvm/CY9+y3cD1vlHKcyxKyv+JYlGoIwV0XY1F8fsVZwAPmn7z2r2v/DbP/3V9/HSObRtakOYzgfOm9GMj1mwp500et9g3pxCtUxRa2vqNx1mH0X0koddO5Z/zxKIWQ33eW472iOf8pQquZo8wFrV1pl/a+0kYi+rYpv8+2zTNl2Tdk/Lbgj5Xs98x7Qb7pGgHkEbenKPpmbZOYJ8K64kdELuCutiIWJTQr5rBbS4Ti9LGn/a+fJ12sy8Wpa2PtH7AWBTKVFsv+WJRjbRrKKcQu6a9F6S948TjeTHksR1AG8H2Y6kHD20E+uJb09jXbGSoz3IK0D2G1hs4vhabgXm+s1pR39lvQBmy34BnNWk+D87ZWH5HsGHTSDaaLjf6XEofrUafc8G8GJM/JlOvzdEv4LFYKyYTIiutn7R3wPhZ2GLI841djm/h/M7jGnUb473TcuZtbEeZM1Y6aO4+GMrtagbmHQF5481AfuYp/GD5Pan8/Oz/HTnlhV47lZ+d8Yv+1kgq435vk4OH/OE99hGw/vwcWmhvsH0vzeH9COBd/HWhuUDhbxuFPym/UCm/AMoIP5psOG63QGkP9ucJ1B4pf7TSHs02iE7VaRtGaLYB5ca2wScjd7FMtTgsyopjEfhsZj7l7Qp5CygPx84RxMPBCg97wj0e16h3UtfJ4YnRz/+W/p8D5ZpxXL88cFzvl4OH/PnGNdYvMq7ddXwO78sLjuv9FP6aaVyfGziuRada47r2uJ6j8BA6rqWuk8M9owfSPR7yNLrcx1L+Ko/OnqDwijJk+S5Wyp8AZVhnj4e8xZSH9fg59mLIO5Z4WJL9H+WwGPjisSvlbwA53OnRdeGrTl3v0nR9CRRgXT8J8kLiv0uV8uiLLs5+a77o8UTreIXWYrjHMTSRUYdSHum1U/m7FNuvPf9aQrwfW5D30PGGY2rxBs//Fh1E2zCHMI/1YHJdl47L/t+RU17otVP5BxR5sa3DcYB8HUE0pfxDHntwnBncriPgHuugJvvjlHZpMj2e8rCPRRe08SnlGjEXYft5fPra6i6WjWZbUXel/7vNYHvIz41xbBxHONqcF6r/qENzNhhI9zjIE7q7Q92XZb9ZZ9/h0S9NhjjHF5Wh8DPSDJbNCZSH9RZQniZ7nvNQDlj+RDNQDlL+A4HzjfBVpz5P1/R5MRRgfV4CeZrN577wzU8oEy0uwjqr2Rnsa55vREYdRu8Doce+z6c98w362ouJ90UFed9d4b3LDB4zOKbenj2EFB3EMc7zzSIPJtdFG9mRU17otVP5r3rmm4XAO/uK7veWRFPKf8NjD7R5dCbcYx3UZH+s0i5NpsdRHvIuuqCNTylX5/g8SBuf2H4en762uqvoXCz9320G28OFlIdjg/1vbU0Wqv+oQw+M0unmzTcvyX6zfv3Ko1/auMF1MctQ00fUE55vUL98vs4RlIcy5diENu9ieY45Svk/Bs43kfR5g7XtP4lMNP+J7aGms9jXPN+IjDqM3gdCj33rf3rmG4wTHEe8zy/Ie5nxdhXNN/iMj+eb+R5Mrov2Im++EXocfxqy7fN/tflmHvDO8T5tvukrDzRDYnS++aZWjE740WTKMQ3kXXRBG59Srs7xOXptx9p4vkF7yHE4HBsLCEeLS4fqP+rQmTTfcJwOaaFe+PQRx81G2W/WxzEeffSNM3exzDX9Rb0SfjR95DUP8u7Tx0ix32M0fcT2sz762uquomNV+lNbU/v0kednLb6LNoT1EfUI47snjBpYDp8BVrK/sndme7hfQOZDKkRPeMZ7SL9KvBTE69uPtD3hcfuk74bblIUdzPkrT1t+2sqL56xYcvKMJWefd/7yZUOQtBn8xAqlglTxXsUMbD3mtdE9LncI/X+uUs8otNuA3g6Qp0lCaMqoxDbtkFMPZWGUe0OU8tsTre2VesJ7m6c+0sB6rDEVuo9Wc0sFu53K7wVWc4tp+bhbmsFy2JL+f7KC18BRN2rdGHXrE1Upg2XxWh84MznltB49QqnHl0isnXg+ONMip33Ts9/S81tBXdlfK3lbA+0Zpp/GRURjPPGg/UXe8R7PXzEsBT+fdNfRVG8HqDc3gIcdFJ67lfpSrkupV1Y23R6eBQetCe5/PnJbM6BtEyGPLZG7+PmplP8k6NDR2W+RJY5Y4VGT85FmIC9F5XykgtNoOR9JOBMj4kyEMhvCb5d2JFo8DjiuPwnq70j1doY8LIez3I5wf2cFW6MvNGrp4LJt9bblzYaC1U7lXw86eCrpoDab8uxrjF/nWS87cvjbhviT8md61vFbKm1Gvvg5pZQ/27Nu2lJpl2Yrfe3CsbtlTrtWKu3S9oBIfW1u2Y7ytoY8seE4t7QTjUuz+51mcH8U8BLUd57y+MZygju+HG7wGkToV81gGZbxhsYTHrevnDeE0mepIFW8VzEDW495tdYg8+j/ZdYgmhXYSqEpFkXz67kej0K+N0QpP55oaSOIrbNWH2lgPdYYrZ77/0ZKnZARUNI/bwsdAUI/1gio1e+iq9L27RVeupU81mtt3bG9gqPR2ppobR3Isxu12QY5GbULVq44d1k2bA1dtRYd43PYGKLUNx5aWKeisK9NwnNzsPMmYaHXTuXvVSYrX313hag9dlEjDL/Qj6X2oSrEizis65vkK2ZwHyZSVXfNy2FDm1FMDVryf82X3IDqpVLj13l8rg2U+s53+ur6A7F9fra7eK0n5d/o8Tm1tYHvvY1dlfK4HhF+RhIPWHekUo/XmbhPeSLxsFv2f5QD8sX7NKX8O0EOvmfJwlcj9sruBgX42QA+I2lTynNf7KGUx+dEIpNuKs/9gv9HWihTHgciow6lPNJrp/If8YwDXKfvRrxPLMi7Noa1dS2OqWW0BkVMnkoneTA1nRWcPLuRt0b+nGcNqsV+kC9eg0r5L3rsQa04BeugZj92VNqlyXRnysOYBMaDhDbTbMReWWw/j09fW91V1lZq72ZMpDwcG6z/ExWcUP1HHeLY4pVQTuhq38aV8r3Z/0XHuQyfqSflfwL6OJZsAq5qrqR29Paz0jfni3t3FfHeY4KuYPdO6FeJl4J4fe7dVYTH7Su3rueva6NUkCreq5iBrce8Wl7cTPp/mXX91ZCnSYLX9dimq3PqsebyvSFK+auI1lVKPeG9zVMfaWC9XqLBowit+pUKNo+ipzzPFhH3SjPw0kbSJAVPRt3VVNZdMupWUZt6TNB1bOioE/pV4qXsqFtFeNy+cqMONQVRFhFVKYNl8VoEnJmcclrvafX4Eom1E8/VLLDrtO/f5A/1Qt2NiZ9eoO2zX91KfSmn4WxSJ84mCo5oMp4Py89KL1LaKnl49ueGlIdnoc6gvEuVdkneZR6al3toXqHkub67dbuB5a6CcpWcv+5qU+6xTK9SeJW+QwvAa21ttK3y4GB9Kdel1Ku3PRrP7GNgW518N9yu/75LqyFPmw34XTgp/98D+uttktEcSWWQR03OPBaLynljBafRcuYxdU1EnGugDD+HvY5osZx5v/u1kHcd1bse8rAcegTXwf3rFWyNvtCopYPbb6e3LU8HBaudyv8CdHBSSR28hvKwD64yA/kUPlAOWJ7fzRA+O3LK57VrctYWLdZwlVJf450j+dd4eHcX6yLWl3KN1vmtCacX8lB/ppL+XAt5mv7w+2hS/ougPweQ/qCH1oj2+8Y1enK8atDGHctSq4djdNsAHq5TeO5W6ku5LqVevbqh8VxLN+aQblwPeZpu8HuzUv5doBvzSDfQfgqPmpzZBywq500UnEbLmf27GyLi3ABleH67iWixnKWfRM43Qt5NVO9myMNyOL/dBPdvVrA1+qHz2+Lt9Lbl6aBgtVP5V4EOLiUdxPo+HbyB8lCmaHu5r319UCG+O3LK30DtkvKnK/Obb7yi3rAtl/JnAk2ODQsutktbLft08UalXZpMbzK1sVHOc3OwO4ze/jxdWemRqdQfmtMelqmUv9AjU01GPplqY+wmpV0jlTbfTLS0SBvKOUSm2P6rqf1S/gqPH3aNUl/zHa4iXjQ/DMvz++3aGNN8Ex5jqwN9SPZtMLbAe+UwtrCa8jC2wGsx/D7LtZSHsYVeysPYAs9/l0Pe9ZR3BeSh7ktsoZ3aekd2v84YvLqn7yrijb9xqf01Jmw+5W93Is5VEXGu8uBcHREHac3M/mprNt76UTRugPV9a8OL6sS5SMFhWmiT0SfCb4Jh+UdgXN9NNnm1wh9+H2iup608npGW9JmMD7R9jXhGJfSrxEtBvIrP5mL7eAvStQov3UpeXp8izpYKTlG+hmf47sqi+AcvO+n8U+asOMXQ1U7/n5XD4lgqNzeHtYpCt0KJ74+le21KWaSdauitTZyeOnF6FJxGhzp7CKcX8nC586GCIWU+MkPKXw/LnY96ljt5ww51DT+VxroteHmP+y/O4e9TYHrHkum9WGnzSz08rwYMxnW/J+Tw8HlyVUqaYtVV4VAo8nMh5aHr0WsGtk37ZCTeY53rVXCYVt40KXJll+5rBafJXrg319PW1ZSHU1OvqY2jmXdNDj6crerE2UrB8U37ZW2JxrO2lEBb8mOyJddAnubS8FYxKX8B2JKfeWwJ8sj/1+xy3jyZZ0tW5fD3a48tYdcQ26nxjEtAxtVsiZT/PdkSfhTUY8IuzZbwownkZxviv+hciPVTzYXbEE6jH/tp4f5e+I15gsP3fPaFl+F54/FfAY9atLAAP2o5AMbjswFze8ijukbbXqYVOgf1ySAbeDHmoFUB/LWbwWPK/R4Pbc6jZZR7Uh7nPw5fXENlV3vK5tkt91teAWj0+Non+62NL36pquj4wvqh42v0BB0zb3wtyX7z+NoBxtfGEwa2ER8HsFz5EQCW3YfKXg/tDqU7lOq6awaVvY7ook7yMYNC96oJ/fQ3z353KVj16g6G9ll3MESN25wxT3D4nu9VfynHY4F1Z9sJOibqDtZl3ZHyy0GW20/IbyOHWWPIWe7fCPcZlx9B3kRlMZTPYeIbqa72txaP3QrOTUT3Zg///Jj+eqVeox+33kQ4N0XEQVovJZw83d2XdPdmyNN0d1n2u53KTwfd3Z90F+uz7qJN5S2UWvjP0X+MeL4FyomcjlPqSvlbqTzScBevLW7L/p+3tpC67VR+FvgdY+k1kZsVPNe22Tltw/7Ax3C3EraUfzn0x+HUHygv6Y+RZrBseAzcBrxw2X1yZLAA+Jg/IR+Lx4XWRkdj4YT8cvso5ZjGEEUGQkOzC1JvpILHY/cWwrjZg3GTUk/DYHuMMrsN8EU3bq+Rf5vSNqPcG6KUvyWnvUbBvrUG3ZsVOpp9v5XyblDy2HZhe7WtWJpNRLu3r2e85I0JTa9u8fB+G/F+i8L7zR7eNfmh/fD5DfL/kLm+ovxf+FsK99jGao/6sYzU5Uf95yo2k2nmbUlZkkPzfKDJ2yc0ndGOnArpJ+RnpMkf5xrvaEv4ns+XMQoPaAs1nc3z41geGg/a9hvNbvL2G80PDx2b6E9vu46uMW6ItMbYENanN7/A1xgcM2+GNcZqotNaYxjzQKQ1xm/376/3UMk1Bm+lqrXGkDyR7xClHr8+IHifB9/3caJ3EWCh3rhrBpRDXWxX6rvf/FxByr8R5r376JOSWH9XwsPnOtqzHtaJXRW+8tqpzWEst89kfHeawWOxwPOQ6T79F9o3l6QdMn60Ma+tH6pKXnsAL2f9Y8nuSzou+RyPK+GF74X4Mrsq5UVWvG7uMUHX/l2AYQhb8lC3b6a8oZAnPDidPmjaQP5uKclfiPyQfreS93L4XaQvNFrXRqS1uiStUWagjuI41Ow9x260OLPrx9+Q3UY7tDPxWtQOYf0idoif20jZX5Ed4tfrekzQNcXnnwjtm0rSDrVDeT4B8lVV8kLs0KnPTj/740d9Y/OKGWxv25R7IVvSd1bK1znOd9XsENsatEM3UR7aIeFBs0Ml55RdQ+SH9LVYEtuh0L7QaF0bkdbqkrTEDvmeLaAdYv9Oe8UW7RA/z/oz+Gy/o7WmL1at+W/sY2p51yk0HfZ/c/zPjuwvHn3NzwO1Nbr8H++hrmOdVZCP5f8BsnmG+MNn2dhO5E/rL9xj868J+eWu95Tz+ffac3Cf7x/aLzxXVLKHznUeZKLu4RFaw03/a+/Z9uNDlq1ccOqSc5edvGDZ0nOXrWwDSsgdU5L/S6uxHl/CSTvdu4L+zzvWrqX/X6fQqYWp7TDZEX4zbsgOkx0Vntcmzm514uym4GhWqZLzV3D4nm8X4W6EgztTcOW//vZmQNu0XYS4O+Wo7C9b5Y336683OqOpeZAsZxyFeLAhj4WQ3W5Yf1ULJzrOHnXi7KHgNHo34h7UHhwjLLei4xrrr06MU2tc77y9jhk6rqX856b219vNM65XBbSx6AtWbJPyaB1FtLA+74S8xsOzhoP3fHrmwwlpjw9nbbZHaGk7/LAPjvbwxauU62rQ4g/+aQd5aDrIPBeNTmD9izw419aJc20gTqr29NaJ0xuIs3udOLsrOF1KvXrnD43nWvZ2Edlb7aAmtLdHZH/bqfx7wN6+lOwtrnhe7HJu1FNjPngvrz9fTv2pPc319aeUfxD687SA/tRkk7crEnF9fa0dnFNRaEn5az3la+0S4BeEGxBRDf5MIT+9KfmUqu/laC0Kiu3Dl5BFl7IowPRl5+02ee+DbQjg4rNX5kVX10dQM/DJOpY39H+u53hrpzIXKRjuYv25nspxv8t9ph/CU62ytfI1W3djTjuNCbN1WP+iHFp5b7NI/3Ck6dJsnGtvs2g+mXYgi88f0J7IY7k2pQ3DjD5e+aAiXv8jT1qbpfzVnjZfW6PN7L9rviPbJi7XprSh0wzWAaShyXhPM5D3ovqE9VPNnXsSTt6cdivNadobNFj3jOw3v0FzM8xpd9Cc1gv1U7W/1wxsV6/SrjOgTN7apj2HJu/ekPKvoohyyaePakSZn6BcqPDv2vdq6tNeyAvpUyl/BfTpgwF96hsfvXCP5y7NFqz2lNfWiquU8j6/UfqHd8j2mJCr8tMQHUX6VeKloD70+RvagWjYvrL+htD9CTQI+a/lb3A9n7/BZfPGHvsA19H9Wv6GxlNe2Xr8jetz2mlM2PyA9aWc6Gcv8d9jgq4e4WUV8CG8oM73Eu/49iqPLa285mNouzTYFrUbfR7eEPKx/DvAl3i1Z1fcXjn8GRPWF1g/1Vy1F+H0RsTphTK+Q9vZ5y8ax8f6vucF19eJc72CE6rrp2e/a/lEnyoQJ0dcjpPvDPPnZ2n+RN5D4nAhJ/lInjH+eVeL7fbm0Ko1TrX4+sFEq+izDay/OodWqF8m5Z8kv4zXCT0m6Jqv7Q6R8Venzzc/ZIwjfW3Xg/BVVfJCdoX9trrf53//jvu/UqH6wgvfC4kdHayUr8//MnO1XWG4Y8VdqCPXUd5QyBMetF1hJf21uSHyQ/raYdL4NlCRvuhW8uaWpCU7ubQ19tqySXmxF7FP7Dv80ROH0GwTzj9zPW1dTfVWK7y7i22Ou3qMfj1Hl9AT+a+nYAldXos+A+1+kD4NdY3Cq9iINg+GUe5VTL5sGGOIUne5GcjbtQG8afEgpNGbw6ejoT1DZL0tenrJKoUfDWd6nTjTFRzfnMR/BYfv+Z5HTiecPL+pYwczoG21nnedmP3l513jwG+qZjS10+T4mSv2gebrsw2U+vK2K5dhe9LXrxlP2tuuHB/Gdvr0rF3Bdb/z4kyjMx4aGWfiNrWbwbbVXYcZvU158WKWgaYnG3rKa8+bUK/YZvsO1Ze2bbpjPw+b7VCs/Yfn0BwzqZ/m5gVpzsmhufMO/TR7PGNjqhmIV/RUSazPO3C1Q7g7zWDdLaCHwYcbC/2qGdzmMvE0LT6gyUXafrHCS7eSF7JPY6qCUyFatfiKeLixsLgJlZubw1pFoVuhxPc3oXtaSA5pOzV/bzY0Rc3xzPsFRP9SoNGm3GM1x/pSTsMZXSfOaAXHR2uBQkvKX6aUH62Uj6gawuI4KMNWmlljurVUg2nnqYZcbYTpfq+m+tw1zONIhcaFnja1Kfe4qy9UsDSchXXiLFRw2Es4mrwExC9gLa8T64efpGTL31uSdqjl781+dyl4wpf2WeaQqMfED1/+8NTxp86rUH3hhe/xkNRWkQuV8nVGn1ZrUQ/c/esuLTKmRT2EBy3qsbokfyHyQ/palJqjHj5a7sqLeLtrbklaEvXAz6T4xnIqm9EIHB8tLRIi5UU2HUZ/UsQ2ScqfAKunrSgqocnbKPeGmMH26Njs70iF1uQc3jVsoe+ubqW+lGugTRxa1CZWzeA2l/GGewkvTy7ae3pSl3eou2sGlMuzl74nAs1OC3WzywzW30rOX8Hheyzn3oi0VkekdU0EWlqUbCL8xjyhxfe4X7D+tZR3mYKjzUOXUx7KbS7laWcqaHaI7XdRO3Shwp/2Pi1G5VbvoGNitEV7a4ft9tsm9te7bof8NobspMLyeRGumxNEuGrJ7tYCsnPX0dQWKX8XyO4Oj+x47tci4dpO8dWUp70/X6E8Y/w7iLRIcMj5YnU+2Que+2LvrNKiipqNqfN8o3bB832yFfHWN7pMtbPOZIxpto7tWS/k8VNInNf4TQPt3AafPcM2cWRW4y+V3dRw5taJM1fB8fmJIbqu4Wg817JlbyVb1gt5mi2TbwpwdPpqsGXvIFuG2Mgj/z9kfdGb/T/02zBS/r2epzO91GZsp8YzYhgzeNzw3CXlP0RzV8n1tDp34XqfZcg2uCRucDRe6FeJl7I2uNbTeAxtbpD9zkKbc1YsOXnGkrPPO3/5Mj65shd+s1SQKt6rmIGtx7w2uncxlTuU/j9XqWcU2hjx1N4J8e1L0J7Va6vyXgVX7g1RyofscRDe2zz1kQbWY43R6rn/n6PUiXlOQMwVTQP3iI0OHZlCv0q8lB2Z2n4hzTvSTnDKe1cRx06F8hDH550irUsj0XLXjBatFq0WrRattUDLt6eMV2Hu4ncl0Q7yu1lFH1xjfd8D8ul14kxXcLqUemXn5G4Pz1q0heVWNAKpvVtaa/9c50QdM2//HK/QpPx5sEIbPnEgz9oKzRh9NYz9IDS4bifwIHkF/IuRbpW2E31lB+WKTyxD/BDZa6ftp+b9OqgLoX20MfWR9j64b4+jlH8Z9NGm2W9tH1fIPiINj8dhh1Ie6bVT+S0ynvApncbfqhy8vOjyS3Lwtga8bUAfpJ2GsOvUu9Ga3qGdYb3TIkGaPfPZCxxbrItoe/jJrLZ3z7evVep3GL0PhF47ld9J6fMQPdf6VcrvGtivIstG9CvKivtVe+qtvR/o0wPtCb0WqbuEaF2i0NL2sYaOZaHHY2uqp1+1L4Qjn9yvUv6AwH7F91mFjuTV268oK+5Xzf/Q9k/69ADnB5GJFlm/gvLQJnLkWrPfqAchfY79k2e/D1P63HcGWOj8ghE42XSYReAWrFxx7rIsBGfo8oXM3P9X57CxgVLfUN0K3duA8jTz2Qv35uZgdxg9ZMXmU8ofqYjcZ37dFbKlGru7EUFcoR9rS3Uts8ahIt8w8y1l1oKquuvQHDYqSn1DtCrKPXdp25x9p/75rJsmKm2vFpYXevzceoln5tBmQt8pYZrnrj3j09rPJzxivVU5ODijoRrxjCblTw2c0SKtfNQZDWXEM5oWWfC9ias9z9aipdq3qNg7RRnnvR2EOJoXo62s0KvklVWtE0FD3jxGXlm/tH0N2t4K3ypYyjViFYztYV3w9a278k53wfLY3+y14t4CjjzhWOLTHLRVT6guYLSDIyG9Cl3fCmg10NKmfF6VS/lrFRsgNK+p0baQFaD21q32BI/fIMV6uK9AaBsqV6c+jogdlSk6Vtn+oJ7x3nGcCziKo52kgXshUu3B4vlbOzlUm+/aqfz9EDV6M40RbYz7+kDbf6SdfKh9Z/KmAFqXe7BvVsrf5MFGvrAuYzOf+O0rwZI8kU2dY2WoNlbQPvNY8dlid4XISusn7TtiN1Fe6H4w/kZs6H6w66HNrJ+av6jZcG3s4r7LW2ns4vjk1XbRqL02H7FP/G6YI+7O8Ynz9lSdmEPzfZ55p9acGuJn+04XR9vHfrYWldRsXy/lafZasyNsF7VvZmL5CZCP5T+ZyU+WzCVPEVb3W+V9E7nd6L4X7wGW8t8H2/2ZiTrNoQVpfj5wzRLJ1rU32tbVmpN4nyr2Td5+Q6Sl7UXlcdZh9PWS0OOnbd/yRNrQ3rJN7YU8tqmrFVzfuwZO7v/M+GB/zf3GJ1g/zFlnoe6hzWHdk/L/AX3+CT3BimE3+JQh7Ru0PH6M8euZ9lSQv+Wtfd+5zj3fwXva+ZuOJffQe08L1WIGddrNvj3tmq+i9QPuadf2sSMtsVWp7ZovFlNLrvx+ELaRxzPaCLYDvZCX55NpeHk+2T8b5JOtJp8MxxePfxzjvZSnnRyqrQHYb7gJeNF8Hj71pe8UfTihZaNJA2lquuyLsWjfZUZfnNf0qOu3BNDyxfpuVcrf4sFGvrAuY+eNSd/pe41YT6FfwGPRt5Z0V4istH7qpvIom6Jjl9dhOL/zuEbdvhHazPpZK+bCY1f7YhL6A6Ib+LhpnhmIqT3awXs8z2J9KafhjK4TZ7SC46M1T6El5bVnKw0+XkVYHA9l3P0NPawx3Qolvs+025SyeGnddGEO38aEdZO2WYFp4as5R0GZVcQXhqHnE62imw+xPj8KE772z4Zfp4JfwLzd6Xs9XGiXfI3/zgrRM0Z3M/NeTUO+tCMF2gN4ef/jR474xsf37jsKJPQVOinfq5Sfr5Sv8yiV27UprDf7rR2lwmH30KNUekvyFyI/pK+Fw/kolaKvM2LeUSVpyVEqOFXyRuJG2xheuh6UjWUM4aXmRabjQxRefHZM+0Cnxrtvsza3q6i9vDAQ58g6cY5UcBq9KfxIwsl7nfZocscugzxtKXV89pc3XXbs2F9vUUZT2wKRd2oczuWrAI/HK28K5TKrcvh7Gegnv07LbcZ2ajxjCM2YwXaBw7t921Bo7u01A9veY8IuLbzbm/1u4HE+wTuxerPfqY/zKfY6LW9P7oX/I1W8VzEDW495bXSPN1wdQv8v8zotjgxNEr5jvlfl1ENZGOXeEJM/W7cpOHw4n2+2RxraQz2hodVz/z9ZqRPzoIJUr+bKyCz5emvwZyP5swolvc6+kenbHOIubrv2iQctmM2rqrKfDHC/r49Ia3UkWu6a0aLVotWi1XS0tBXoNZSH8wF/Hl57raFCecifb+WF9X2Bx7l14sxVcLqUemXnvm4Pz9rGQZbbaqU9qz04WJ8Pmsl7JfLxSTpm3iuRvBKS8v+AhzFvmDSQZ20lZIy+6sR+EBpctxEbJFGu/JBC2zyK5eVVXt8rOpouhPbRu6mPar22yq8WS/mfQh+9j1arvtdCa20SP4HKSxtDX1uV8h+G1arvtdXLc/DyVu9H5OB9HPASvLY6StM7tDMhr8Fp9sxnL7R3cLQHWfwanO/Vx6KvtGqvwfleaZXyX1b0geci1o08/jS5RX4NrjeHjfWV+obqVuje+jm0hI67h8vXkNfgtDdd2UR8SxG5r8vc1XoN7gX3GtwhOWxUlPqGaFWUe+6q9Roczyo+EWuiKvsC9a8UlfZZWM3D8nkCWmze9xqg5vVcnoOjvdjtLp7RpPwfAme0SJ6UOqOhjHhGC42cSPla26F5qPleQ/EdcxzrNTj21DR98b0GV+u1I9av0NeOfF71i+W1I34NzvfaEU5HfMSy5kWF6gKunh7PecaEdFEX8p7Rog1AGnmvIwzLbLD2OkKv8bctxN71QhneHqiNMe24YN9rmVKuTn3s0vSxFwqErPKwfNGx6jskhreR4lzQSzi19Ma3zROf8R1NK75eKDeTMHsVTLzHkYeZCv8azug6cUYrOD5aMxVavv5u8Fax3uz/Y6GMu7+hhzWmW6HE95l2m1IWL62bLs3h25iwbtLUWcO5sE6cCwNx5tSJM0fB4a0gB2Zmt87HzatCHpiVfLNgVYXoGaOvpvLeqkC+tLccQraY/al74aeWP/PaJypUX3jheyFvw89Rytf5VkSvNjXxG6k4Nd1AeTi9CA/aFrOSb6X0hsgP6WsnRfAWs6Jv4mDe3JK0ZIuZ7+36XshrhM3gLWYzwYXiLWaN5kXDKfslNO1Bh5TTXKJKzl/B4XuM06vwXGsr1vwdzYC2aUtf35cNpPywqf31FnjCEL1mIB7+X/BWAR7LXvBCv2wg5Y8FneKtWKuozdhOjedrAINx3e8JOTwcT3NUyY0X6lYsXn4iPxzKQflqMvc92FrlwTmqThxtS13MzTDdHp5jnmGvPYiSMae95Xk0/MY8weF7jIP1r/XgXFonjnbmqxYWwiWT9kagyKxOf6o9pF+QfpV4KYjn/dqR9sBf2n6jwovvtKAK5SHOjQqORuviiLRCTio6WqFVVF4Rl3rC4jFU7ugc1toUuhVKfP8Yupe31BPaqY7KTjX0az03v3ZHHVN7bo5mg5d2P9qpv94Nnu+Zh7yM5tsxj/V9O/N5CsTIGkfdtCPBK5SH/PneKNGeWLQpOJr51abPF/uHjnhKx7raFB1yCMYQBacoXxHNnLA4icrlnelWUejWMnOT6F6emZP/p1J9DWe/OnH2C8RJ1Z5VdeKsUnB8tPZTaLXUewBtrZvyjow1JqybtKMh1uYM0gs0as3y76RZvhfyQmZ5Kf8UvMv1HvjNexqQ1lVmYB7K8WriX9tRWuf7yMEzoNCvEi9lZ8DQnWnF3k3iJQNKBaniPd9IaaN7vEHpIqpX5t0k7emcdiS85sddllMPZWGUe0OU8pcSrUuVesJ7m6c+0sB6rDEVuo+j7UoFm/defh7CYRMoHKZhoTxq7S/kMsxD3/5CT0gOTxLQ2sWjmU8EQEuwTw7+L8DKfH1HHd8o+Nw+tJ4dOfzmHRL+bZABb/jTLL/JuYcywLp5/8eyF1Bb8P+aLl5J5a+o0Xbufyn/I0//X6zwIHy5a24NHrjMBTk8/EzhQbGaM1acfXHOXj/2NdjKcS9xT1ys0Mm7RBpOY0V7WTo8OhhH/q9pgGu5zO19rtvyZSvz9jnyjHBhDuYQo19dRufNXWtr6+rF5fC8W1exfWW3ruaN0lo4dW5dzZu0NWPB9Q3VrSj33OXU+bRsy/XafH5xaZ04WpCIaeW5xbydTMr/y7OdbBXwwTTdxcFO3/ZZoYPla22xYllq2yF92L7nfNcV5NUXY0Z8LTh6Q0Fej0rM6yqF1wY+Vwk2nWvruUqxZQ1vNkapIFW8VzEDW495bCF5qTCb/l9mWRN6RqZ29uONOfVYs/neEKX8DUQr7/zpthw8rUexHmuMVs/9/2yljm8EhGiwu/Ke1MWgdZNCS0bmzXC/wEjZKHRkCv0q8VJ2ZIaeEyltv0XhpVvJ45CDdnbnLQqORuv6iLRWR6LlrhktWi1aLVotWi9wWtpLXnw2L86ffERFo49a0HCm14kzXcHRjiyo5PwVHL7HOBrP2lnXLDftmw83eXCw/k3Unl7IG3BY3046Jq5kewGTd4hK+S/DNo5FO+W3EeUs7WKeG/HNOPRx+OUk3/nk7uIvp6MvwS8bYV/jmeC+PlhCfYAvuml9kPeNtvdAH5xMfYDYuPsrb9z0KnisI3mfgV1N/En50zKetCMosP51OXgoD5TzuTl4ZwKe74Xd3ux3nXq3UaPPZ691jj5vf9HOuRdavQot1IO5VF77Bgz2gdDj7V0XKX0eoudav0r5SwP7NZI92ajokTZaZE2bh3x6oH1br9sM7vNVREuLavbCvZB+7VXoc79e6+lXqY/9inxyv0r5GwL7VWTZiH7thQIh/YrluV+1+Rv7VWTSbQbPk3wsTK39OSH9in3ANlrK3+XpVy3K7bPDUv6eJrDDKKuQftWeBIT2K9th7Fc+CgjnOh7LvQpOI2z0I0qfazvFewP40+QW+SigG3LY2FCpb6huhe5tmENL6Lh7GFZlkUtzO4weAhV6PCSeUESuDdNewPa9VLa2dvv2lsPz7vbtRcayv0V3+xadFhugqu6ancNGRalviFZFuYd5vcSHuxd6lIbUxS1+2gqbVwqa5euFMnmR1TzvQui1U/kPemahWqs1tta3KuXRM+41+e2/lfKw3nU5ODg7ouXn2VHKfyJwdhTsRsyOKCOeHW+DvDalPMv7dqX8bVCGo0q3Qx4PaZTxrYRTy3Sw/vcqONrqW/PGfccK1VqV9Wa/fV83074+5ouUSLlGREqwPawLvrHkLpaNT3dQNt2mtp7guLyFcHx2yV0+XcDowtEUNdGOvKpQHmL6DgbWvmKu4VxaJ86lCg7TCt2nIuV/rdgooak9Bfbtj/B9+Rb50WSDZ0QwdiXnr+DwvbzzFrCvYj459nnUvqfKZXHQzlxPODdHxMmzWWwb6sXRnixr81e9OGifVhHObRFx0NZdA/V4TtROA71D4UOWAK+A+wXmguD3rYV+lXgpiNe3BHgF4XH7eAlwp8JLt5L3cviNeYhzp4Kj0bo8Ii3p25FmcF9PJhzNl7rdgzM5EGdKnThTFJwupV69Y0STjeC8IiIOjpkphHNnRBzUgw0J566IOHdBmQmEk/f18y127r/v0ishj6Nc7uKvn0v5N+zbX2+rjKboINoK5BHroy97h9IOxtsuwxD7dzfUKWCP1HNXhFYt2W1PsrsD8kJkJ+VvBdlNItlhu3hs3wN5r6C8eyHvTsq7D/KQBuYZaAPeY53D+lKuS6nH89Wr4H6B/gr+crzQr5rBbS4zX72K8LDt7uIz0u4vh9f35fhXK3haP+CX41GmiC+0ZIxpdvZuykPbeB/loT27l/JwfG8Hv5FmXpt4Byzyx/qN/N1AedrOWe2r6TdRnvZl75FKm9m/lTYPJTrumpH9baeyh+/cX+eQ7Ldmb9iO36HQlrxXKnn/25kxeWBb0KagHDHPXW3KPd8cKuU0nAPrxDlQwWFa+GIhrhHZ7kr5M2gOQVtWYMyeIvK/F26yvStpf04JtXd5thf50mxhewAv7Z955GPvP/2Z+UXnCJ/tPFApX6ftPEmLmQm2dr7kfZSHcS/hQTtfsuTcdVKI/JB+t1L+YChXpC80WkdHosU2t15aN5WkJedeou/D/o0WM8R5yfcWBvN1dw1a/DlirM827J4atHjn5d1KG9kv4XJDFdqM3WUGt41tWUk7GRxrEPpVpQ1lfDdNttpcw3Yc63Yreazz9yo49yo4Gq2bItLieGmMOKamwwcQz0V3rmL9vF3HWI7XzO73gMPJdtb5Qb3H9Tb7BVL+MliP3UDrMcT2+ZYc0yl6Vt/kQJxZdeLMUnAaHf/mmM49EXHQNs0inHsj4uB445jOfRFxcF7ktcBNCg9OZx+gcfAqyNPG5YLsbzuV3xzGwUOecYA8Yn30tbTYFOO9lvzxkn6gGtMRWrVk9zjJDtd2muzYhvTZF5DdGwrYEPQt76E8lMe9lPdqyEMamGegDXiPdQ7rS7kupZ7IV/rrNXC/ETEdoV81g9tcxi94DeFh293F65IHyuH1xXQeVPC0fsCYDsoU8YUWx3TQzt5FeWgbX015aM/upzwc3xzTuatGm9if1vjzxcLXls95Vzk8r8+J7Svrc+4DvzEPcYr6iTFocXxubfhCU+rEmaLgvFh8IX6+ta74Qj8u6AvxfC7lH9qnv97PEvhCv24CX+g3kXyh1SC735PsEJvHNsqJfSH0UdgXQlnx80bJM9AGvOd7pspyw3o8X5X0TYJ9IaFfNXXpR998pfmI2nxVp6/X5ws9oOBp/YC+EMpU84t8vhDHF9A2sr+D9iwvFut+sy90U402+Xwh3gOGsQv3f9xfMcP0txfLngnjbMguz//W9pjJIfdaPOV2wB26y0B+US4cvyzqO2D9e4mfGHOT9qyb41VFY9RYn5+J3qvg8JzO9nX9XXR+0L6iP8D2VcofB/0+mvoMsdlOIs/soxXtz8mBOLPqxJml4DTap2EfrVE+DcerXhURB+dL9tHuj4iD8xD7aHcrPPxvHw2Ng1dDnhav53iVlH927/56kzzjAHnE+uij3aO0g/F2zTDqnBNVH01o1ZLdZJLdPZCnyY5tiJT/CchujwI2BOfk+ygP5fEqysNYBtLAPANtwHusc1hfynUp9US+0l8Pwv1G+GhCv2oGt7mMjxYaP5L2rSmH1+ejPaTgaf2APhrKdA38Flrso/niHmgbH6A8tGevoTwc3+yj3VujTeyjabrfwP0ewfEqoV81g+VYRrc0X0ibh3luwrpa33C8StsLosVcNVr3RKTl20/GvpC2b+0VHpzJgThT6sSZouA0ep/02opXNcrnYl+oUT5XqC90Ks3n90NeyHwu5XthPj/Ds47jZ0X3Az2jlJ+Qg3c2+UIl4x+qL8TPoPJkdy7J7l7IC5GdlF8KsjvfIzse2zjvcLwq1E9i31R7RoX3fP43+5BYj+erkr5JsC8k9KtmcJvLzFeh8aM6fb0+X2iNgqf1A/pC2vM6pMW+ENpZ3leNtpH9HbRn/FwPxzf7QvfUaBP7QtqeMabVDve0mBOvO27NxpcbazdTzErbp+zKbbjrwHItP2xgXa3vV8BvzEOcUN/pzoi0Wn5YPw7fK+KHNco/Yj/sxRaTyovNvikgJuWLzfbFlMCXeKvHlwiJSfn8MCn/roQxqTzZvSfAD/PJTso/uVd/vfcX8MNaMal+PvEe0m/FpPJjUj4/rBliUhp/TCvUD5PyXye7UdJvUu0Gv5vU8tcG1mX9cRe/51OPj3VXRFotf60fh++1/LU4OGX8tacj+WvXg8/xTAJ/7V9N4K/9J5K/dgbI7r+eZ4i+swrYX9P2tWu+HM+DReNmWH9di5tp89ULNW7me4bIPpn2nkOIvxYjbhYa42LMPL9uEeVL+U137ae5CcXNtHf3XbkHW/G1F018jc9kQNrsrxU932qywrOGM6VOnCkKTqPPaWJ/7e6IODjmX+zPOfN8jr3JvmnPOX0+R99ebPA5pmY0G/mc88AMI8VzzjzZHUSyK+uv/XnP/nozPbLjsY1zI9uX1nPO56/Wc858f813fhTaxljPOe+u0Sb215A/31lDcs/nh0n548lulPRjVLvB+9J8XykteZZGsL8m9GN9pVTrO99XSrV3FHiN5y6Or9Xz7uNdEWn5/KiWvzYQx+evNepcTfbXGuUXsr/WqHcbQv21y8jnKPuuyu3gc1xJPoe215bxQvfoS/nVZHdLnt2l2l08W4xt3YBzaXLW8qHvUUr580B2N5DsEJvHNsrpLsrDOZV9uZh7b7E+y01bi9T53muwvyb0q6Yu/eibr7T3S33nhJZcP/T5a6FnWKC/pp0NirR8/hq/R4m2kd+VRHvme1+O/bU7a7SJ/TVN97UYF75T+SDZhYegXIF+eFhwHlYyJe8RoI1nhvHVRv9Hvtw5hHPpOzFGocXzLOJr73s+SnnYZ49RHo7h11Ie9ufrKA9tzOOUh+Pt9ZSHevoE5aHevoHycM31RsrDtcqbKA/XLm+mvDWQ95bst+gf6g5/Kkzy3NWm3GM7ifUfIh6wXiXnr+DwPcbReNZ0uV6ch6EMfqqNxwX6USFnED4K9xuxjhH6sc4gfJTwuH28jnlM4aVbyeNY8WMKzmMKjkbrroi02Obk+UafI9/oTsgL8Y2k/MvAN/oi+UYoo4epjdr5RXcqeBVqV4dSHum1U/mvZTxpX1t8WKmv0cbYcMiZSTi+GjFGhH6sM5MeITxuH4+RRxVeupU89l21sfiogqPRujciLfZV8sbITyONkZkwRn7RhGPkNxHGCO49DBkj9fjfSE/4wXtIP9YYCT2nRfM9OWaKefx8RBuLjyg4Gq37I9IKHSP/iDRGdoYx8u8GjhGRd+gYkfLPRRgjuGc3ZIyUXBMHjxH+Vke9Y0SLTfjGyP0KL77nTBXKQxzfWVJI64GItELHyMjdBmKWHSObwBgZldFspjGyccZT6BjReH8o+x0znqzF1XaC33m664urYX3W3bsUnFo60rObzk+ejpyQ/eU+GAo6Mt6jI9wHyDM/79D0RxvX2vMOH87edeLsreA0+jkEP+9o1H6OvQmnUft8+XnHqyPioI8Xem7k3jQOXgN52jjgb6hK+dfu0V9vqmcc8PtGHIvl8hNy8A7MMOrc76A+7+D3mPJkd1CkeeYGkN3MAjYk9B2v+ykP438812vvOeE91jmsL+W6lHoi3zrj0MHPO4R+1Qxucxlf6yHCw7a7i593PFwOr+95h7aW0PoBn3egTBFfaPHzDrSzd1Ie2sYHKU/z7zQbFHKGNrbJtz8lZL5p+fED886D35iHOEV97xi01mS/W3s/Bt8rsvejUb4Q7/1YV3yhiwr6QjyfS/mJMJ9fSvM52ooQX+gupR2M19sEvtDVJLu7IC9EdlJ+BMjuGo/seGy/kH2hNXC/Eb7Qmux3LF9oDeFh293FvtBD5fD6fKGHFbxavtAawER8oeXb+3EX5TWrL9Sm8IfltO+BYXmj3Kt48BhjiFJ3JfGNeccQRtEY0DEKvw3cW9UWOr5S7K3S5KLtEeEz3jEPdQDzEMf3vSSkFeLzdCq4jfDHhX7VDNbdMvLXxuYxcI/tWz36ldcPvu8zlXzXYojgae9aaL6us6cdZnAf1tpXhxjYX3ljHrHZ7ml2yzdOkNZRRCvvu+F5faDF7LV3g/CdeMz7Qua/ODv8gd0GlpE9Dp+BMh/Kfvv84RjfpUB6xuhjKsU3yPK+Cbae8fe9dv6k+629X4/YrIv31ODJp4v8frM2X/5v389u5cppez1duS95yt2jlNOw3P+17/2yL/5VeL50w7SBssD6/O4QfpO8Tbnnex/A9437yXXiTA7EmVInzhQFp0upV8n5Kzh8j3E02fjejSqLgzrGsYFGPffh2ECjzl/m2MCdCg9uzDxJ61vtXVRtvuB3Ud88pb/e72h9q33rmvEwNnC30o5B775SbKCR513lye5pkh2ewRAiOyl/B8juGY/seGxr35/W3gvh5yvat7cqlGdM2NpFe0d7XXkvxHfuygvhvRBtrtNso29fAr8XguM75PtavvdCtLm8zvdv79POaZBLe6eB5znUgxlQjq82+j/y7PyOmwu8C6L1hfYuCH/fDm2H72wCfv9em8vrlHuwfy70q2awDpQZt9q7vJqPo73r4js78nz4zfrUptzzne3xioi0+Nz61vl++TjN8F2MF9t3XPN8pcmT+++jTQv1laT8ZPCV9shoau8R8ndc7wR6RinPfqaU3zfDqDPmp/qZ/OwfbR3Kbr8A2aFNy5PdRiC7aSQ7xOaxra3Ftfg9f1sMZYU0MM8Y/94AzR8psmei5HtfwX4mn5dR756J0PMyYuwJcUnza7V+QD8TZarFr3zn+91Aedq77b5zNTQbFOJnYptC/EzRrWsVHMm7A/L4e+OvVNrsxt0iGnf4DdkZ1I6i3z+fofCj4dyc/W6nNp5Ntq7k2S/7dxGO0EDaryhJO3Rc5vkNyFdVyWsP4OUfow/c6S9rnr6/QvWFF743BOijLmP5GUr5OuecfbsAwxC25OF8+ArKGwp5woNbuxw0bSB/JZ9L7RsiP23sY94+8LtIX2i0bixJa5QZqFc4dmT8oR25JfvdZQaPaR4nJcdg8HpL6FfNYBmUmb8026vZLLYRWLdbyVsBv9m2tCn3hnhoXRuRlswBWj/zeutaBedaD85khWcNZ0qdOFMUnC6lXiXnr+DwPcbRZJM6rn9zRBzUA15v3RIR5xYow+utvDXD7bRmwLOJQ9YMUv7du/fXu9PjuyCPWB/nlxuVdjDeveSDlJxb1PUW7+3Ik92rSHY3Ql6I7KT8fSC713hkx2NbO/NGW2/dTHnoJ3BMqeh6C+uva+stbY6X9t1TDq9vvaXFI4ust7R9AbzeQjt7I+Vp62jNnrHPheOb11s31mgTr7c0/lq+UJgv5K6DoRznFfVfbo9Iy+ejtHyhgTgtX6gcThlf6KuRfKF9YT7/RgJf6LtN4At9P5IvtDnI7kee2DOPbZQT+0JaTEfzk3hdX/SdKKyfYH9wsC+UYn+wNl/FOIvaJW2fYt5+XU2mml/k84U49qztRdTs2Ssoz+cL3VCjTT5fiJ+7Y9yYy14H7cWyz0zur7PZ7vlYtxIf10HebZQXOj6RBsoXbQWW53fupfx/sja4WOOd03SaQ4yuo2J/tNintKMTcCWvgP5+zPG1E+zfQH1xF8ZNUV+M8ftUUv5WpTzqHPuGt0Ie+3OaPqJ/gWdHShlDPDZCXshDiLy0Z2Ch8uJxj/K6g2hp/i/K0Ccv3KPkrpjyQh5C5KXtcQmVl8hAk9criVatNQ6fpyq0O4xuE3jPtpTfJLNl2plAPht/nUIbbWOFaGA7LlTa0UV5WPd/Z4Xv+PzvVHEe9jW1Pahov3EfBJbfBvyzvUg22jzte76lxTgwbsH7WHEevzeA1o0ebN/3wTRs5Iv3yPDeHM3f0OyAyKZOOzBUswMYr2I7oPWTdkatT1ZaP2nP3HlvXGjMifeZhsac8D0P1k8t/pRns3k84HqG1zraOsGne5r/jOOYdU+LsWrjn+2Gtq9GG0tsN7Bv2W5o+/B932eQ8jOzvmjkPnzW73aj6zevPaX8cWDbZufYtqEFaR4O89E2tJdXe95epy1o12wBjne2BT4b7K6idpPHrW//qvbcHGXKPoHIqEMpj/R4b94xgT4Bf1M0NAbuW/fJeHByvzjjo9YeyONJ97SzJHx7IKX8ZaDPi2mNF8Nu3EJ52h4t35yj6Zn27gC/a6jtua1z33lwLIX3nZd8zuPdd64954nxHVaXtPd2tH7AWEree6VCS2xVaruGcgqxa9qzJm0PIY9ntBFsB7Q9r9qzGMZDG4G++MU09jUbGeqzYPz6qxRLxfHF4x/HOI9/1Hf2G1CG7Ddo35FCG8TfPZbyq8CG3U2y0XTZ58f6zpVAfrR34+4PoHWXB1t7v/5+D7b2zWrmxZj8MamNRZFNI9Yb6BfwWNT6SXtPxScrrZ+0czn4/I/Qscvvp+H8zuMadRvfg707Z97Gdmgx3lrvxh9Pc/cLJVawBsbuO1qxgkHYzGcrVjAwL2Ws4B0NihW8qhUrKBwr+NgLIFbwHbBtn4wUK/hMK1bQl7e2YgVfb5JYwd8CYwXfixQr+Cfo8w9bsQLf1YoVEF4rVrB2YgV/a1Cs4PYXaKzgObBhG0wZSLMVK8gfk61YQbGxGyNWwPoZK1bwPZq7kW9+X18bU9qY5/f1te89c//lxQqELn9HaBycObALyabWOZdFxw+vmbTx46Pl22PkO+dRw9a+O8a8GIVPPMNHsCQv0jyqjl0cnzx2Q8/t9clK6yftfHH+xqEW99LODuAzqnAe4jGPuo3zLuuntrcpdN7FvUZ8fsddNeiyPLV3lHAc87yhxVB874j5zunznRmn6TrbDTxD1ijlOVYg5ffP+qLOc2HVWEHedwAxVoD6zWsrKb8AbNuBObZtaEGaMzI6tWIF0o+N8KlxvLMt8NlgdxW1mzxusW/4zJjQ8+N4nHUY3YfIOx/2COgDjhWgPWI/A+0Rx0C0sxp95yk5uZ+T8cFrHfcbYwULSfe0uD7aHNY9Kb8S9PnY7HdMu3Ef5aEd4LN2i36HB+vzOXjad17qPKcxOFbA3w8uee6l9/vB2nonxnnaLmlnqmv9gLGCWmen+2IFjbRrvuchteTKa3dsI49ntBFsB9BGsP2414Onre/QRvhsZOh6A32WyRQr0GKs2hjn8Y/6zn4DypD9Bu0bRWiDcM7G8peCDbuVZKPpss+P1b6Tg9/c4ecw2ndyfLR8cYo1SvkHPdjIF9Zl7LwxqY1FkU0j1hvoF/BY1PpJ+w6PT1ZaP3VTeZRN0bH7GsrD+Z3HNer2q6HNt+bM29gOLV6p+QM45y+kubvRZ0jzmd6a74t2Ruiy73svjN03kGw0+6ydv8z2A8tr33nxrdd9tHxj16e/GjbyhXUZm/nEM30FS/JENo0YuzHXB5qstH7qNoPHNY/B0POseXziOPKdZ43z7hsCxm7ovItjl8+U1561+nTPF2fVdE87v10b/77YGtsN1FG2G9i3bDe07wRq3zvkOf99FCtoxHcCWb8xVoD6zWsrKf8VsG0fzLFtQwvS/EhgrED6sRE+NY53tgWh38YJtZs8brFvQvaCoUw5ViAy6jB6zBL3vGD5z3tiBWiPOK4Zer4+753S9tk4uf+RYgU4djFW8LWc52eoe2hzWPek/FOgz98kfyOG3eB1hBYz8s05vu+9ac8FNH0WO1DnWjo4VpDi21S+76+VtJt9sQJtjZP3LSxNpogvtHyxgkbaNd/zkFpy5bU7tpHHM9oItgNoI9h++PYxaDEGtBE+Gxnqs+AzzyfpmzXa9zO0Mc7jX/umo7a2Zr/hAeBF83n4O3ZS/h9gw4btMZCmpss+P3aNUh7X6xz71NbrPlq+OMVDSvk1HmzkC+sydt6Y1MaiyKYR6w30C3gs+mI07gqRldZP3VQeZVN07PL3c3F+53GtxRg0/ay1n4LHbl788GueOD+vFWJ8i5qfw68BXvg5PNJtp/Ibwve0J5BstD72xY8eVspjv7OdWgN5DwfQ8u0JekQp/7AHG/nCuozNfEo9beyKbBoxdtdgAaBby265K0RWWj91U3mUjeRp+2w0/3AN5YV+F/tBaDPrp/b8P+9MHh4PuCeIv02vrZ98ulcrvs26p8W3tfHPdgPHP9uNNZDHdgP7lu0Gf++cy3OsQMrvkfWF+J+oI/XGCh4hHh8CHjT95rWVlD8cbNveObZtaEGaUzM6tWIF0o+N8KkfggJsC3w22F1F7eaa7LdmC0Liu2vgHscKREYdRve3MI6F5WdBH3CsAO3RQ8Q72iN+XqHFrTV7hLGC0zI+2L9yvzFWMDfHJ0bdQ5vDuifll4M+z89+x7Qbr6Y8tAP8HA51yqdn3Up9Kafps9gBsSuoi42IFQj9qhnc5jKxAm384fzAsYKSdrMvVvCogqf1A8YKUKaIL7R8sYJG2jWUU4hdw/K8dsc28nhGG8F2AG0E24/7PXhoI9ZAG06jsa/ZyFCfBdcxF1GsAMcXj/81kMfjH/Wd/QaUIfsNjwAvms8jdNup/Hlgw64l2Wi6vAbu8dz1mFL+USjzALUHdf2xAFoPerBfq5R/zIONfGFdxs4bk9pYXJP9bsR6A/2C/2/vWqD0qqrz/eeVmWQyIwEtgkCQJURFUV4lvFISk/BKQFBERYYxGSQYEgwTCD66xiaZvEN4xEpV+IeA2oVUrVb7kGWX1bJoWVWsq69FlbZKXVSxrtoqy2WVS+7OfPP939333PvfOzOB/66VNTf/2Weffc7Ze599vvO4bIuqn5A+pK1UP/UTPbZNXtvdR2k4vo9RGur2fVDn0QAsC8dttl2F+WA8oM4ZeHhdWVjBGMgSghUY/R6w3X3UNso/e1hBGfN1j5d3/sHTX1U2yoV5uWyW0/JNNlYwhgTAN62fkD6krVQ/9UeNds02qDCxPOOu8hVpWAHrp7pXIHTcvRP4LgzACjzdqworYL/hxfyoo0XGfNRVpGeswOg/T1gB6kgOXZdYwf0kI+IZSr95bmX0j4Bv+2KKb+vMyfPL0wArQHtnX+D54PjJ6zfZbrFvQrACbNMQrGBM8Ges4GsOVoD+iHHNsrGCHwRiBY+WhBX8EPT5MQcrKOo3GCtAP8BYgRpzlJ4prADHUM5nfqDJuXQwVmD8e6LGOhfBCpT9eVhBQb95ACtQcxzVD4gVqLkI8pqOWEFWu/LcXWGaykd48w32H6FYwRjU4QcVYQVnOFgB2z/aONs/6jvHDdiGHDfcD7KomAfHbKT/CfiwttMn8lS6PAa/VTFf93h5WMGnBP0nnbJRLszLZafZpLJFa5sq5hsYF7AtehhN/IS0leqnfqLHtslru/dTGo7vbNeo24iBsX6WhRU8GrBfQfmEGsmL9N78JGu/v7fX8BOUpvYhcTlp53oHkr+8R3l20s5ZMbWV3aS+91V95iZrPsj7YdB3e/vvrUw1NuC+lbk0NiAWxXsyPN3jvChfVwo93nmE9K+APj52geaJMjRzV4x3ByjHuApD5HLS9PlqqqvRHxeozyXtC5s91XvPWZ/VuqXaM8YxRVl4Tt801P9TXkT6f+Y01381l/D0PwsjYf3H+G0q9P/nb9j/HqL/+5wylf5b3dL0H/FEpL/Q0X/Vvp7+Z60Revr/AKVhvrGUclD/sb1Y/43+zYH6b2VXof/YRqz/3rwpfvLOdXhNAON3T/95vbYs/X8yh/57+w2V/ltd0/Sf7/oy+kFH/5UNeucY8651YR3upzSF9XI56p6B+GH9N/rrAvXfyq5C/8ucv2bhDLxHFm3D039e5yhL/x8l/f99QZf3HDvflaXO/1k9VNzgxUhG//7Tx/Ptorm3ilm9OxKzYlbvfM09Aby8O6DLWA9kWSIhJ84HrSxLK+n8V2fVcwvVVqqf1FyZcSN1t2PIuRK8A8K7Kw/Pi7F+qvubQ20X704ffcNEvlnYUN47XPnsqLrDVdm/dyeEd46d/YY678d2hrqK9LwWbfQfS/rC1jdQR3LoulyL5nUvXJNU+s1rd0b/efBt96T4ts6cPMcCx9mS7qrpmGrcjO1WnU2r0f+RF7YpY6rWRl2Rxkj5Xhaj/4yI65Q/8tagGPNTd80qf4Rr0d9M5OAzuvE7rkV/gXSv6F2M3wZ9/lLyXqbf4Puw1F0H3pij9Mxb61f6bH6gyTPgwWvRxr8naqxzkbXo0PvpmvSbB9ai66I81Q+4Fq3WSJCXtxZdpV/z7vHJaldeG8Y6sj2jjwjB/tlHqPLQR2As/k2yfe+7RciXvyuBeWO+H6T5hndve+g5do4bvPtM1H4a9EG8j8jo/xl82I+oberR+BMSx44J+jrQ8Lq7Ojvj8fLO12ed0fXOB/HemzH6v7LJCtfmOvPuC6lDWsi6vWqrOtBw/I940Rilhdour1Pj+O7dlYd3N/woZdzGeqh7NlQ8gGP+F2jsxvK9sZvtU8VK3n73mqgj+yDkyzH//4Ht9vz2RJ5l30/Bc6a891N4d/GNCfq6U7byGyxLFKWPrS/k+yl4zo8+sE5p6r4WZZ+MMai7U9T+E5zTsX5mfVPMG3fxbpmFhBWUfQ+kd1+tty/EuxvDG9e9u1jYb9ST/6OuIj1jBUb/W0lfWPyJOtIsVjBGMuI9TUq/0/b5vi6RMe7jI1J8W969w0clfCZpj01H1eP4mKCvAw3bLfZNyLeK1L4utrOuSOMUfP+y0c+DPvCwgjzxgsLvlD9CrOCiRA7Gc+N3xApOIt0rilMtB30+OXkv0294sTWfUVBjjtIzdT8ZjqGcz/yA+ZU6/F4FVlBP3nuixjoXwQrqVB7WPX4YKxgrVt4BrCD0TD1iBXUoE8vn+04m2695GGgd0lS78ty9DvnZnj08EX0E+4+7nfLQR2AsfhHZvvKRoTELzjfOIKzAu/sZbZztX2G/3tl4HjeUD+MxG+nfCj7sOmobpcteHLtP0KszekXPyXoYe9beAe8MUFnnZEs6QzLl52Q5/vfOyYba7hil4fju7XevR+N1vi5l3MZ6qLUQFQ/gmH8Sjd3qm6BF8QDv/DuP3WlYQRrOtw5sdzO1TT0af8rA+ULm6x4vb76WhfNx2XVIa+F8up9CcD787gVjBaH2yTavzr8r/SwLK/jlSRP5Kp/g6V7WfhrvTmo+C4X52G/kxQO8u/LYzlBXkZ6xAqO/k7CCgmdDJVbA+xDrIIPSb55bGf0fgm/7SIpv68zJ8+5ArKCk+y46qr4bM8tvst169yUojE2dQ2U764o0Zsn4ttHf72AF6I/qJDv6I8ZA1N3uyh8hVvAIYQVou4gVPEi6p3B99Dmse0b/N6DPf0TxRhl+g/c41SGN9/1ZWhT5eqbWeY1O6bP5gSbn0sFYgfHviRrrXAQrGKPysO7xw1hBQb95ACtQc5y6KA+xAmxTdTeehxVU6de89ZCsduW5O9bR+zawt4ZRpzTvrn70ERiLP0K2r3xkaMyC+xV+msQsysbZ/vPiAd69OTxuKB/GYzbSPw4+7PvUNkqXvTg2a77O6zBqvu7x8nCKBwT9/U7ZKBfm5bLTbFLZorVNFfONMu/RUW2l+qmf6LFt8tqud79NndLUOT+ln1l7Ntl21TdKMB442LCCZ8B2a2dM5FmPxp8WVjAxXwsraLTdqrEC1s+ysIIvt7CC3FhBf9IX0xkreFUiY9zHc1J8W16s4KUJnxZWMHVYwVzog6nEChYlcmRhBSeQ7hXFCpaAPr8meW9hBfJpYQVUXgsrmBqsYBHZfllYwUMHKVawDHzYNdQ2Lawg3SZbWEE+2y0DK7gmZdzGehTBCk6gsdvDCkK/g9vsGQTck5F2BuF6sN0PUduUfQbB2/9YD+DVzBkEb+8V5uWyWc4XwxkEa6uQMwgeVoDjXBlnED4UgBWoM4W9UaM9IFawjrCCss8gePeOeGcQ2G94+MNkn0HYQVgB6kizWMEYyVj0DMIY+LbdKb6tMyfP2wOxgtYZhMY2LesMwscDsQLGORR23swZhK8SVpB2BmEf6V7RMwhfA33+JMUbZfiN1hmE1hmE55knf1+oZxDQR7AfQB9RxhmEr5LtKx8ZGrPgGYTrCCsIxQq99brJOIPwKPiwJ6htWmcQ0m2ydQYhn+2OUVqRMwhPpIzbWI8iZxD20dit1jAne1+BOp/Jse9TYLvPVryvIGS+7vHy7jbMWh/jsuuQ1tpXoPspZF8BYmK8H6HsfQWsn+puw9BxF+82PDlgX4Gne1n7Crw7Sbx9Bew3ptO+ghnz9/+dzvsKjkpkjPt45nzNM+++gtkJn9a+gqnbV3A49AFjBeiP6iR72fsKzkrkyNpXcAzpXtF9BeeCPr8yeS/Tb7T2FbT2FTzPPPn7Qt1XoO4yq2pfwVlk+8pHhsYsuK9gnrOvgO1/Ou0rWAw+7Epqm9a+gnSbbO0ryGe7ZewruDJl3MZ6FNlXwPFA6H2nNZIX6b3vcmR9l4nxQxULFf2+Atbt8uQvr/2sCIypq1yLn8zvkvFdu2q9xrszN+ve25fQ2FADugtI1lrUKGtN1K0/Jb/ihf1yArwfD+lIv4nmktieOfp1WS/kiYAH8i6oM8uwrvaoeBJjJ1Ve/PSItI4AWf7qjL+86L5fnjK7RvlNFv6N9bJT0F8g6K2tukj2uVHQc5GyXSvb0rjumIb2ZzLENrtwwUT5OgvKF9J+yL9f0C8Cujx9cUg0URdQ381e8Y7e7ZTmfTND+WYPc2b/hn4bvwPCa/ZGvwNiuXsCxkqMn1k3vf1OKI+a794bwMv7bltd0N/rlK3msixLFKXHABXeGd9Z9bcw6oJe9ZNas2UsaTuk8beqvH0d6ts33h40pZ/e99Xix/suzl3A94evn8i36m9mhsZm7De8+3PzYkdsZ6irSM/YsdF/hsb7OuTJoesSO66TjPjtnjxY29fAt322JPzujyc3zu2oes9pXdCr/UXKF/DeA/U9KTW3YjvrinSMnfa924cd7Bj9Ec8t1fkO5Y84fkebQez4ScKO0XYRO/56Cn6Euoc+h3XP6P8D9PkRwo7L8BuMK6nvI3ljjtKzfpEfx1DOZ36gye/GBGPHxr8naqxzEexY2Z+aZzbpNw9gx2OiPNUPiB2rtXDkZb5qsv2aN3/PalfGctVaqvIR7Ae8vfEfdcpDH4Gx+JNk+1nf3PNilj8Avt9NYhZl42z/oftMQzBnHjeUD+MxG+mfBh/2K2obpcteHJu17umthd0XwMvDh/YJ+vucslEu3lfGe1fq8G75KlzH6ax6fVq1leqnfqLHtslru3VKC8Wccd3nVwHrPurbXCoewDH/6zR2HyxYwYwzx/MdceZEni2soFHOFlYwMW0ysQLWz7Kwgk+3sILcWMG8pC+mM1ZwLvi216b4trxYwesTPi2sYOqwgvnQB1OJFVyVyJGFFfwO6V5RrGAA9HlR8t7CCuTTwgqovBZWMDVYwVVk+2VhBfccpFjBteDDbqW2Ubrcwgr2Py2sIJ/t1imtCFZwa8q4jfUoghVwPLBD8L1L8K1FjX4oZJ+Z2seG7cHf1Vb7l9RdO9tTylEYRPzwPjOj3xQYU1vZVeg7thHru/LZSM/t7X1rGdtE7XPks1rYxlamyXyX4BnLPkpjw+1AtyeamLYX0vgsM+5x5m+toY6gHNhPqAejQGN8O4h+L4wNnyYbUTq8F37jPvD6DOVReh0yr7ndKTur/7lsdR8GyxIJOVEfrCxLs7apwlbQ/7CteL4mfkLaSvWTshWO6/ZA2u2U5t2dhN9a4zOWqNt4NpH183ZRj1H4jceGUSHr8+cHCIv6iODr6Z539lLp3l5RP2X/7DfQ/tlveN+Ex75lv4Hz/UjQMxZl9F8iLAp1JIeuSyyKz1fcDTIo/ea5u9E/Br7tz1J8W2dOnl8JHDetH6uYs03muMl2i32zl3jtFbzU/I3trCvSMZLx6yD6RxwsCv0R7y1Hf8Rj/p2iXOWPEIt6mrAotF3Eov6OdA99moolWfeM/segz48TFlWG3+CYFP0A8kgbc5SeqXkCx1SYz/yA+RXUxSqwKOPfEzXWuQgWpexPnZdv0m8ewKLU/Ej1A2JR2KZqvuRhUVX6NWynEL+mzgWpM05sz+gj2A+gj2D/cadTHvoIjMWfJttXPjI0ZtkLfI+m+QbaF9u/d1cr6jvHDdiGHDfgXU0q5sExG+l/Bj5sxlkTeU7FvZQer6rvuWBZoijdJid7bo5xAdtiFiYT0laqn9QZMF4LC7Vd77vsbNeo24j3sn6WdccKxwObBd8Ngq/RjwKvdsFjIPnbQfR9SX0wdjWeW4QMt8Bv3KfbBP0WoDF5+qJGP7aN0jDfSPKu9N3omtT32UrfsT6s79shrV3Qc9sobBExJevbfqLHdrK0EUizMnuJD7Z3LPulJ06UJ6tvWb+2Ai/Vt2uS9w6in+vol9KXjfAbt6HX5ihPH8mAeftEPmtfpV9G16R+9Sn9wvqwfnn6Ej/cNjsFPeqQ9W0/0WM7WRrapZXZS3ywvWPZu149kQ59Ty3lr8nKv/E8AXktInlGSywH630ClbMJ0nAedzqNB9gm7SLv9cl7B9FfdtZ4vvnJe5/IP0r5Le1ssLP7FqTnZx+8GdI2UBq2x0iUXU+kX5NSz4Ug550OVmJyNWl3/cru0PeF+HWkz+vX2XejTW4iXpsELzUP4BihK9J9YPw6iH4Z9AFjJTh+bCHZR3LKrsYT5Ucsb9wX35i3/13FAVupTDWGqb7qF/m3pPBqE/Kj3XK/t0d6PGR60wnEK5V/7iD6d0BfPbBA84xSZNiUInNXCv12ksHorxb64vkB1P9txNPoB4HnR3LyfG8Kz5VOrKHsdCv8lnc85XgC23EnpaHsPC7ugPKZ9gYqH9NQz7ncyJGXx9QseXm8sbQPwHi1NnnvJn45fXW711fLhbyhfbXJqR/zsnwdUaM+ejaC7XHzWZpnZ06et4oxXcUqxwP/D6TEI1HUGI/ED/tl9Bloh6dTTILlbyD5R5L/f1jYoxrrjVdzY33tSTXWjwAFj/WqbZCefcJWQY/9yDE2jjfHURqOsyNUzogoJ3QsHYG6fnzeRL6jDt/4/R0kR1aM9+7knf3wHscPqzYcgd9CMAVsV15Hxf5gTEHp7GTrI9af9dGra/zknQ+zPqrxQ+kjx1me3sSPp4+IS+2m2A5l5bnHdkeerJj7FqI3H9+VQs8+3+gfcOKeXUIGb56wW9DvEjL3kQyYl8tO29+1nOpj9A8G+uOSMI9DlP5ju7H+e20UP9ymtwl6bCve33UbpO2kNNT/XZSmcCTPZkNtw/LG7XAt+eqy8Tn21Ub/FznxuRH4bbLwOc9XV6mr0xWfQ10NxefeFhALbHDkV/o4KuRXuBL3O+bbHGXLNSrkUvOYUaecU5os5xRRTtUY5ClUny1OffJiIZh/C9VnS4n1UTJnYar/SnMY5dtwDsPjndH/HOZkTwZgqnl1d2M0UU4PQ4qfy6Lx+kdRFTGnXredzJiT40ocL0MwQ9Q9HDuNJiIZq2gvtOeQOaPyG177KoyuP2psy82Uhvo2SuWUhb++fl62/Jud+mbpB2Mx02iNbspjANaFvGt07C+xHOUvuY/Rv2K/8JqV0c84O/kbNcaOSg88vcma05k8Sjf4XL/C+Sv0IdNab7ZRmsIdQ/XGwwpxjLbx28PIatHEcRL1GenT1ldGiU+Nfp8Jv2O+91CdOUZi3tcRvdWzK4Xe+HEscjTYyrEOJqZ4riIZtmXIsJVkMPpXChm89o8fLybsjhptMYfddNSIn8mDvyH/nkjrx9wo6Klx+1l5Sg/ih21Z2ZNaK/F8oLJzxWtDibwsblAx7MlUTt55Eeb35l+nNlnOqaKcqudfJ1M520osB23mVCpne4nloB4cRuXsKLEcHI9OoHI2CxnicWLh2eO/47iVtoeRz0AY/fZzxvMtTniqOTPKiPlx3N8i6sHlXZiUYf4Pcdwc/kieczJeWW13MbWdWqvx2s7ob4C2u8RpO7ZtFWP0RY3twTE94rO89qrwX/yNdU5h5L0iH49XiAPnmSuG2Aby74ka61xkvFI4N8aEfH5kT7HyDpwfUWcoVT/g+RFsU3X+02xM+VnGDNA37qY09GeM06N9Hw/vWEZanSy27XPkU3Eoxm4Kb2Hdm+xYaWux8txYSeFDeWMl3n81XWMllJNjpbyYK+bf4pRzapPlnCrKqRrbbcVK4eUUiZU2lhQr9cF4P0rjPfqKkFhpq6gHl7djGsRKu6jt1HqC13ZG/9Ozx/PtcdqObbsVK43Lib8h/1aslB4rqXijylhpa0adOFZS8ql4J37mRmFPSCyF9cvRd8eG6qbxLyuWUnGJiqWsfjuKlTc31rWZST6MY98F72r/E/ZXWf2nsJmp6r/RYuW5/acwqzL7D20rT/8p2zwR3jEN6+PFlZh/suLKE6mctDH+KzTGqzUtHON5z4DRPwZj/FdpjA/dF7AJZOY6l7TO3x5j+HnONXl7l+Mn775b3q/krVurPeW1qLFP8q5b4/nWl8zT8teA7/UiL9s20m8Tchg9n6VhGj73YvSPwxrMkSn77dLOvaStw37HWYet+twLtjOfI8F83jqs0TVpE8cqm8D6sE2oPbwqVjT6rD28rPcYy24jXmxf8bNc8PJkHW1CVu5H7Cveb2y0qJdYH9ZLo39K6KXqf2vzKvrfW4dXbeqtw2e1KeNd3l5kbx0+a88N+8TNQgYcEydrjsqYwW0gS7uQ1fh2EP0vYAyedc5EnjZfiqIwm1XzM5xz8XlonJvdHsDL86V3CPrbnbJRLszLZbOclq9C25L75HCuzbal+gnpQ9pK9ZO614XvmAydL99GaaHz5d1QZ9ZPFWeF2i7iUoxZKV/l6V7oWOWdN1H2z35DjXHKlthvYN+y32AchOkZazT6lyd9YfMv1JEcui6xxjtIxj0gg9JvxhCN/iTAX1+R4ts6c/I8JuGTNc5aP1ZxTxvaO/sCzwfHT16/yXaLfRNyNhjblON6a6MuQY/8+GzVa6AP+E4F9Ed7SPZQ/I7PK6k1hLjdlyVy8Hmr+B3ny28k3UOfxv4iflj3jP5S0OdTk/cy/Qbv7UQ/wHGqGnOUnqn4DMdQzmd+wPwK6mIVmLjx74ka61wEtwrFqJv0mwcw8TtFeaofEBPHNsXyjZd3/2SVfg3bKcSvKZy8P2qsI9sz+gj2A+gj2H9sd8pDH4Gx+DKyfeUjQ2MWXIfcSPMNtC+2f7Rxtn/Ud44bsA05brgDZFExD47ZSP828GHXU9soXfbiWPUtPLxncBfVB3X9rgBeu52y1T2idzllq/uNWZYoSrdJZYvWNlXMNzAuYFtU/YT0IW2l+qmf6LFt8truHZSG4zvbNeo23kt/fcq4jfXAcZttd5eQFeOBydr7VxZWMAy2u2WaYwUe3t7CCsblyfKxZWIFofsQy8AKWD/V+lvouIv7fS8OwAqauZuiKFbAfmM6YQV7DwKs4EHwbR8tCSv4WAsrOJA2VVjBJx2sAP1R1VjBo4FYwUMlYQWPgT5/zsEKivqNFlbQwgqeZ578faFiBegjqsYKHq0IK1joYAVs/9MJK/h78GFPtbCChrLTbLKFFeSz3TKwgqcqwgo4HuA9/fHzTviN97LwHu80OYze9CRtr1UaNvAMxFlHOvuClkHd/julbugn1PyHY7y+c8fz/Y8T6/C9FirWiaJGv8y08yPdBr8Ef/WLc9LLMh3qdeoY8/jVOel08wUd82gTbcDj21aRT809+UzOLipjp1PGDpFPlbGdeGKbqbMGezLSbxN1i8RvbYJ+V0p9I1H27gy+OwUf5Ws8H8UxdVmxwT3JJEXZS5pNKL3a5ch+G8metReQZVfth/5D7Y/kswysW9tEPWvi/ybfCviNfay66x1pLC/vTz0i8VtqfyreY632AQ6m8DwKePL+VKUzr4bfeCz2+gnlUfsad1E+dYdQJH5T/bOJaBlLmC9kSvv/DsEnTQbvfK13fq+sPYXbyDbVXY72/y0kO9LyXSl8NoP1m8/44j087YKG9dvoT3L0W50LRLkGU3ie7Oi3avd58Fve+9N4bqTuT1Oyo+/h31T/sH6zP5ovZEr7/1bBJ00Gte5k+r05hSeXyfoQP6zfG0Q5cb8fSvqN5YxQmWqvn9qT1y/y8x1NJsMi0CX+Lob6xhvWcXkKzyWOfpZ9H7v3DaFtTj7sv25R1lx7+bX/GD+zhRlRug7yfvXl0E73LtCy1FiejKfCc4xza8QvijRGeJCeYzymjHOMfDYqfkds+8pzx39PszHMe03yzjZ2Ncz33pnCM4qa803PHj+Rb+jdHKFji3emzTv3s5HS1PduTAYVQyL9u5N3jiGvBdu8s/K762s/VZgSxoiMKXnnpuInbxzL3+tR6yOefimsl/WmK9J9wN/8Mfr3QR/wutVGyM9nXTbnlH2LkF3ZMdoG27E6V1j0+6nxu30bhe3+/c7Yqtb3R+C3vN+X4XV4Fd+p/TveeVSjaxKDlXegTua90/z9VKXP6jyqlal8L54v/S75XnXf8gj8xvqFvNqFHG9P3juIfqejX2Xf4c93M4eedzbbr/C885ypPu88kryHnHdGX8jn5EcgDe/dfpj0S42TmPeq5J3HyU/kxFo8m8sao0aSdw9rUZgq65LC90wGb69B/D4QTWwHo38gMF4oac/beXnXgxU27K3XeXvksE36iZ77Bf+PvLz1F2ujrkj3Qdr3kz7nxAuhe2ZDZB8Rsit7Q5u6JrE3Nc/nmNX7Dg7nxbGnK4U+bf7556K92J+lYa/vJJ5G/7DjD9SY+nvwW9472hl7VXikmj94dwOUE89HC/OeDS/7jvaR5F3dx8VnVL2z4Vl4jaf/qEMXk/7jeP5hKtOLYzkvlpOm/8aPdfVxR/+z5uVvI55G/52c2Jen/1kxghcjeffymL+pMD5fPNXx+UjyHhKf58V5R+A3T/9Rh86ieAv3UyudvTJ55/uTn8qpXzhvKBqDKh3yfO9GSlOxK/dj2jjD8xSjfyYw3sL74YyPpeXQ50On2p/z2puKbz3/6d0tpPynGi/Zfz4biM9434IOkX1EyK7sDW1qHo03OPf9MJW52SmT86Jdp403xo/HhvakjdR4g3MzhQfxeGP0XcAzZL7ujTdZ83XGg9Q9W2ou783Xja5J+zxM2WeZ39XKwspGkne1Nr6J0tA2Qr6rNQK/efqPOnRYov/NteuGwRrIYrzbBWUH/TWaI5I+6YHy7W9HgBz/8o3//YcvXnjyDXzuJX6sj2Y2wf/Irwx9a8ETTz9RFf9tJ3ccsvvty86viv+3ZvzXz/72r9+zpyr+3+++dHHbn+w8pir+H/3Z8tM2Hn7cT6riv/frrzv/J2/+8dFZ/PuS9y5Ib6c8M5K/HZDWJfh1EP0bExuIbecUilU6RXnxb+c5dLWUv0pmlMd+6xH07YLeyp4p6C1tFqShj0UabC/k1QPpSL8gqbv1STfksfz9ovxuKl/Jjb+1Ef0sQT9L0Mf1PIP8GtY97xp3/HRRfvwNy7b16fiZETXKi/1oMlm7dgt6S0OdYH2ZCb+3C14zKJ/RX0z9iPWx/P2ifGyLKEVu/I37Uel3j6CP22fxgnGZ43q8lGKINsiH8mA/5ezzvhC7rZHsKEsRHUN+Vh7Xz95jnX9V8r5+eNXqVcO3Lh0avnT9u1evWnHR0K03nbdm5aWD64ZXDa4+b+XKdUM33YRCY0Gz4XdMx4dpmI7pQyvDl4arhrXfOzJ4XUa8MH8H8erM4PUW4oX52cnb/zujRjkXJX/bAvjE/7oy5Lqc5EKHZnm76f85FbHTZOl2ZEH+JssMSOsuR5Yuk6Unpyw4yGBepO2MGuvJ/dUt8pVQrxlWLx78suqFAdZMeM/iFT9XEa8uwatb8M5Rrx6TpTfy6zWTZJkFaZgXaTuJNn64v2aJfCXUa6bVa3aUr169kIY+NItX/LyLeM10ePVl8LqaeGF+zIv/74wa5eT29vjE//oz5Bogufogv+Xtpf+j7nIAYP2KaWoc6I3S/XFv1OhbZ1Aa+roeSkMbnUVpSj97o8b+7aU0pUe9UXofWBraeDeloW+ztm1mEvfBx9Z96v8PefCprEkcBnBxexydpI0HMc+FL1cMrl61cnB41do1lw29b/3QTcM4qmKvooT4fx5drSWQjp8a/Z/Dyhr9v03Q4aO009NA1mrsAU+rra7N9N4XTjvxzNlXHj9S1RR/9jf+9JJ/+8WNx1fFf8u///qfdn7g5c9Uxf+ce2/Z1nvaZz9fFf+HZn174cP3dl9dFf+zXrX78CMffV9vVfw7O468e+5nr7k4i/8JyftNw2vXDQ2sWjMwtGFoxfrY0AdWDK64bmhg7brBFauHBm5ZN3jjjUPr7ERJN7HKOYDXukW1wvOPnN/NDHPlj863AKQgct5h+QsiGAdcy5sgvxr82omO88Tp7J6QxuQs2E+Lm6xnm+WfUSx/u9VLTcS8gICHH/XXeHGaldUTNaUjNU92lI9PIGGQwCswildXTl5V9gm2FfaJ0VhaG6WlDbtRNLEN7H0GyBsyrGN4shR4vBbeT0zerX2K+aZx31LQ5qI5onxG66Y7ivma5O90RjGPA5ktED4F+KXpuEL/QgCggvbWZrIowA3by/jHQfwrkvcb1626eXB46PJ4dL9gzWIb2xfFQzsXxCF8DeqYNj5hfRSPdsivnrjdm1xtPb9GZeddbT0j+Vv1aqv5lzVrh1dde+vA0JrnJlLrh1YO3Pg8Rjxw7fo1K5K4a/Vqi7eOTPK8UOKtgnFER5MAn4y3lK2aTiyBvEuoTKNZCjRLgSZ+vJhMrZIsprR2Ub6KbXAsOwTe5yTv03ksOwA+JP+P/ZZNRxK/tfx5U1mcWMr+xZQliZ0ses5MuDgO+2r0f0YQ0lCLLFSCw8bp4MaOSP5W7cZs2HzP0LC5rvc+t741MLjmOVe2f4VrYHD/EtfKhHSKvdcVTXqvK5q0glqTa58HvNP5kN+DWLHrLE9saS+H92MgT/xcAPxqlHahKNfSLkqRI34uhjTer4D7KTlaXQ5pPBu4BNJ4hnEppHVT2pshrYfSLoO0mZR2OaTNorS3QFovpb0V0gwSNj1AWD2HHlxg+fuL5Z89R5TfD7LFzyLIMDcKeyzvm4rJdcC+FxfL32b5lxTL32H5lxbL324jmS3rtPZB7H8O2n0Qpshl7INYTLya2QexlHhNl30QS0iu1j4ILcuLaR9Ek7J0myyzcsqC67azypEleB8Fy+Lto+D+Dt1HUWJ/B++j4Hqp9e8mZZllsvTllEWttzcpS6/J0p9TFhVYMW1n1FhP7u8+ka+Ees22er0kylcvDDgtb949DUX3V/AeioNxb4m3RwT3ejSJIVxRS96KYggrkr9VYwjWpyuHVqy94ca1Nw0NXLdqzbDtPJliuGBpk3DB0ukCF+B0LBQusDyx1vfBO+7+ih+cqtUobYkot8k6LW5ywb5tTpTuIWz6dnjy/3ZBi7qExw1Vu0bit5rgw22D/TA3+XvoG6N/POZ7p9362pedvvaSmzd97y0P/e5h+179n/2HP7P+7JuffWIt16XNkb3XkcFbRC3BMy1t1jMdlfyt2jNZPVcP7/dJxyb/f6H4pIL219ak/Umf5I3Wyid5CydZ/gp9kvFu0k8vabJNa3OidB9iPulIzBCNt5NFkcqWO4j2ZZDn0BR+XVG2b2hPkcNgZbXYFD9zo6CnpsqpiXK8/ZjTwVfNTf5W7atsxSdeiXluCWbg5gObdAfW7d+layD/FHuvC5v0Xhe+GLyXWr71vJelIWjNizPnC3nVgo/J3+Qy/ZIm56cdc0T5xss8onmB1l71sveqN+k3L2zWb1pvVu03bZNBshFnxbqhweGhlQNr1q9everaVUPraM+zDZ9T7EQXN+lEF79QpqW98M7gY7G2bbptgva5GHAWOy6bzkzY57JovyIuNz3kQtiH1MTvVmCTtry4WVu2TT1V27I16spV64ZWDK+6OT7DcPPQumErt5vkKWq0hxXLPwG9jUgW5MvOJcpRhj3YV/zg3ABpu+lvLX/5tTQ5aoLYIpvD4Ddrj98ANAWc7r/+CgA=",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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R9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DofXeej63x0nY+u89F1PrrOR9f56DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89l1PrvOZ9f57DqfXeez63x2nc+u89V1vrrOV9f56jpfXeer63x1na+u89V1vrrOV9f56jpfXeer63x1na+u89V1vrrOV9f56jpfXeer63x1na+u89V1vrrOV9f56jpfXeer63x1na+u89V1vrrOV9f56jpfXeer63x1na+u89V1vrrOV9f56jpfXeer63x1na+u89V1vrrOsw3JRtJomk1/Hobm4d10mqzJm6LpFn11/mg0zab2sPaw9rD2sPaw9rD28Pbw9vD28Pbw9vD28Pbw9vD28PaI9oj2iPaI9oj2iPaI9oj2iPaI9rjtcdvjtsdtj9setz1ue9z2uO1xyyMblx6Nptm0mnbTabImb4qm9hjtMdpjtMdoj9Eeoz1Ge4z2GO0x2mO2x2yP2R6zPWZ7zPaY7THbY7bHbI/VHqs9Vnus9ljtsdpjtcdqj9Ueqz12e+z22O2x22O3x26P3R67PXZ77PY47XHa47RH1/nuOt9d57vrfHedZ8uTnaRblHUOGk2zaTXtptNkTd7UHtYe3h7eHt4e3h7eHt4e3h7eHt4e3h7RHtEe0R7RHtEe0R7RHtEe0R7RHrc9bnvc9rjtcdvjtsdtj9setz1ueWRz1KPRNJtW0246TdbkTdHUHqM9RnuM9hjtMdpjtMdoj9Eeoz1Ge8z2mO0x22O2x2yP2R6zPWZ7zPaY7bHaY7XHao/VHqs9Vnus9ljtsdpjtcduj90euz12e+z22O2x22O3x26P3R6nPU57nPY47XHa47THaY/THl3np+v8dJ2frvPTdX66zk/X+ek6P13np+v8dJ2frvPTdX66zk/X+ek6P13np+v8dJ2frvPTdX66zk/X+ek6P13np+v8dJ2frvNsubJI8qZoukVZ56DRNJtW0246Te1x2+O2xy2PbMB6NJpm02raTafJmrwpmtpjtMdX576TZtNq2k2nyZq8KZpu0Vfnj9rjq3M/SatpN50ma/KmaLpFX50/Gk3tsdpjtcdqj6/O3ZO8KZpu0Vfnj0bTbFpNu+k0tcduj90euz1Oe5z2OO1x2uO0x2mP0x6nPU57nPaw9rD2sPaw9rD2sPaw9rD2sPaw9vD2+Orc84R9df5oNX0eN+k0WdOfR4ykaLpFX51Hnqavzh/Npj+P+0vaTafpz+NiFG+Kpj+P+90PZWvXo9E0m1bTbjpN1uRN0VQe2eT1aDR9HjtpNe2mz8OTrMmboukWfXX+aDTNptW0m9pjtMdoj6/ObyTdoq/OH42m2bSadtNpsiZvao/ZHqs9Vnus9ljtsdpjtcdqj9Ueqz1We+z22O2x22O3x26P3R67PXZ77PbY7XHa47THaY/THqc9Tnuc9jjtcdrjtIe1h7WHtYe1h7WHtYe1h7WHtYe1h7eHt4e3h7eHt4e3h7eHt4e3h7dHtEe0R7RHtEe0R7RHtEe0R7RHtMdtj9setz1ue9z2uO1x2+O2x22PWx7ZSPZoNM2m1bSbTpM1eVM0tcdoj9Eeoz1Ge4z2GO2Rv+f+G4lODOJt/Gq9cBAncRE38RDpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HboZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dbpdul26Xbpdul26Xbpdul26XbbbdsgCscxElcxE08RCM6MYh0G3QbdBt0G3QbdBt0Y5ZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZMlO3MRDNKITg3gbkSXAQZxEul26XbohS06iE4N4H84fsgQ4iJO4iJt4iEZ0YhDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptul26Hboduh26HbohizxRCM68XMbv8TbmFnycBAncRE38RCN6ES6Gd2cbk43p5vTzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQ7dLt0u3S7dLt0u3S7dLt0u3S7bYbvpvr4SBO4iJu4iEa0YlBpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Hboduh26Hboduh26HboRuzZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkIUtW4iYeohGdGMTbiCwBDuIk0m3RbdENWbITnRjE24gsAQ7iJC7iJh4i3TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7djG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnS7dLt0u3S7dLt0u3S7dLt0u3S77bZ/P+IgTuIibuIhGtGJQaTboBuyxBIncRHT7SYeohGdGMTbiCwBDuIkLiLdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YxuRjejm9HN6GZ0M7oZ3YxuRjenm9PN6eZ0c7o53ZxuTjenm9Mt6BZ0C7oF3YJuQbegW9At6BZ0u3S7dLt0u3S7dLt0u3S7dLt0u+12fj/iIE7iIm7iIRrRiUGk26DboNug26Abs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwSw6z5DBLDrPkMEsOs+QwS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SZJc4scWaJM0ucWeLMEmeWZCvq3+ckiUG8jZklDwdxEhdxEw/RiHQbdBt0yyz5/uTGzMbUwklcxE08RCM6MYi3cdFt0W3RbdFt0W3RbdFt0W3RLbNkfh+3Zq9q4SBO4iJu4iEa0YlBpNuh26Hboduh26Hboduh26Hboduhm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut92yz7VwECdxETfxEI3oxCDSbdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0Y1ZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1mCvtfpiUG8jcgS4CBO4iJu4iEakW6TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboduRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenG7LkJt5GZAnwc8s/8YW+14eLuImHaEQnBvE2ZpY8pNul26Xbpdul26Xbpdul2y23hb7Xh4M4iYu4iYdoRCcGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboduRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7pdul26Xbpdul26Xbpdul26XboxSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QyS9D3+v1Z3YW+14eTmG6WuImHaEQnBvE2IkuAgziJdDO6IUt+iUZ0YhBvI7IEOIiTuIibSDenm9PN6eZ0C7oF3YJuQbegW9At6BZ0C7oF3S7dLt0u3S7dLt0u3S7dLt0u3W67oe/14SBO4iJu4iEa0YlBpNug26DboNug26DboNug26BbZsk+ibcxs+Th57YtcRIXMd088RCN6MQg3kZkCXAQJ3ER6bbotui26Lbotui26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HboZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dbpdul26Xbpdul26Xbpdul26XbbTf0vT4cxElcxE08RCM6MYh0G3QbdBt0G3QbdMOz151oRCcG8Tbi2StwECdxETeRbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboduRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7pdul26Xbpdul26Xbpdul26XbrddkPf68NBnMRF3MRD/NzOSHRiED+3k/9tZsnDQfzcjiUu4iYeohGdGMTbmFnycBDpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpduh26Hboduh26Hboduh26HboduhmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNul26Xbpdul26Xbpdul26XbpdttN/S9PhzESVzETTxEIzoxiHQbdBt0Y5YYs8SYJcYsMWaJ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",
      "is_unconstrained": false,
      "name": "sign_proposal",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "MultiSig",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Wormhole"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "state",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sequences",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "receiver_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_12",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_13",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_14",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_15",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_16",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_17",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_18",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "guardian_19",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "current_guardian_set_index",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MultiSig"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "signers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "signer_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "wormhole_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_operation_type",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_proposer",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_new_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_transaction_token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_transaction_receipient",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_transaction_amount",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_signature_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_executed",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_created_at",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "next_proposal_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "signer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::_assert_is_signer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::_assert_is_signer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "initial_signers",
                    "type": {
                      "kind": "array",
                      "length": 20,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "initial_signer_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "initial_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::execute_proposal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::execute_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MultiSig::get_next_proposal_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_next_proposal_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::get_proposal_executed_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_proposal_executed_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::get_proposal_operation_type_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_proposal_operation_type_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::get_proposal_signature_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_proposal_signature_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MultiSig::get_signer_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_signer_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MultiSig::get_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MultiSig::get_wormhole_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::get_wormhole_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::increment_signature_count_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::increment_signature_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::is_signer_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::is_signer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_signer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::propose_add_signer_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::propose_add_signer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::propose_change_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::propose_change_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::propose_execute_transaction_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::propose_execute_transaction_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "signer_to_remove",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::propose_remove_signer_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::propose_remove_signer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "wormhole_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "payload_1",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_2",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_3",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_4",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_5",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_6",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_7",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "payload_8",
                    "type": {
                      "kind": "array",
                      "length": 31,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "message_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "consistency",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "token_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::send_message_to_wormhole_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::send_message_to_wormhole_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiSig::sign_proposal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::sign_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "MultiSig::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiSig::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
